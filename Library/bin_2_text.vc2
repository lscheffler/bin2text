*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="bin_2_text.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS api_apprun AS custom 		&& Ed Raus API_AppRun, see UT download
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: checkprocessexitcode
		*m: extractdword
		*m: getprochandle
		*m: killproc
		*m: launchapp
		*m: launchappandwait
		*m: parseprocessinfostruc
		*m: releasehandle
		*p: iccommandline
		*p: icerrormessage
		*p: iclaunchdir
		*p: icwindowmode
		*p: inprocesshandle
		*p: inthreadhandle
	*</DefinedPropArrayMethod>

	PROTECTED inprocesshandle,inthreadhandle
	*<PropValue>
		iccommandline = (space(0))
		icerrormessage = (space(0))
		iclaunchdir = (space(0))
		icwindowmode = (space(0))
		inprocesshandle = .NULL.
		inthreadhandle = .NULL.
		Name = "api_apprun"
	*</PropValue>
	
	PROCEDURE checkprocessexitcode
		LPARAMETER nProcessToCheck
		IF TYPE('nProcessToCheck') # 'N'
			nProcessToCheck = this.inProcessHandle
		ENDIF
		DECLARE SHORT GetExitCodeProcess IN Win32API AS CheckExitCode ;
			INTEGER hProcess, ;
			INTEGER @lpdwExitCode
		LOCAL nExitCode
		nExitCode = 0
		IF ! ISNULL(nProcessToCheck)
			IF CheckExitCode(nProcessToCheck, @nExitCode) = 1
				*	We retrieved an exit code (259 means still running, tho
				RETURN nExitCode
			ELSE
				*	Process did not exist in process table - no exit status
				this.icErrorMessage = 'Process to check not in active Process Table'
				RETURN NULL
			ENDIF
		ELSE
			this.icErrorMessage = 'NULL process handle passed to CheckProcessExitCode'
			RETURN NULL
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		WITH THIS
			IF TYPE('.inThreadHandle') = 'N' AND NOT ISNULL(.inThreadHandle)
				.ReleaseHandle(.inThreadHandle)
				.inThreadHandle = NULL
			ENDIF
			IF TYPE('.inProcessHandle') = 'N' AND NOT ISNULL(.inProcessHandle)
				.ReleaseHandle(.inProcessHandle)
				.inProcessHandle = NULL
			ENDIF
		ENDWITH
		CLEAR DLLS CheckExitCode, KillProc, CrPr, GetCurrProc, WaitInpIdle, WaitOnAppExit, CloseHand
		DODEFAULT()
		
	ENDPROC

	PROCEDURE extractdword
		LPARAMETER cStringToExtractFrom
		IF TYPE('cStringToExtractFrom')='C' AND LEN(cStringToExtractFrom) >= 4
			RETURN (((ASC(SUBST(cStringToExtractFrom,4,1))*256) + ;
									ASC(SUBST(cStringToExtractFrom,3,1)))*256 + ;
									ASC(SUBST(cStringToExtractFrom,2,1)))*256 + ;
									ASC(LEFT(cStringToExtractFrom,1))
		ELSE
			this.icErrorMessage = 'Invalid DWORD string passed for conversion'
			RETURN .NULL.
		ENDIF
		
	ENDPROC

	PROCEDURE getprochandle
		RETURN this.inProcessHandle
	ENDPROC

	PROCEDURE Init
		*
		*	API_AppRun - use the CreateProcess() API to launch, monitor, and kill an Executable
		*
		*	Properties:
		*
		*	inProcessHandle			(P)	ProcessHandle generated by CreateProcess()
		*	inThreadHandle			(P) ThreadHandle for First Thread of inProcessHandle
		*	icErrorMessage			R/O Error Message Detailed Description
		*	icCommandLine			R/W Command Line to launch via CreateProcess()
		*	icLaunchDir				R/W Directory to use as startup dir for CreateProcess()
		*	icWindowMode			R/W Window Start Mode, one of (HID, NOR, MIN, MAX) or empty
		*							defaults to empty, the default for the executable is used
		*
		*	Methods:
		*
		*	Init					(O) Command Line, (O) Start Dir, (O) Window Start Mode
		*							If sent, the icCommandLine, icLaunchDir and icWindowMode properties are set
		*	Destroy
		*	LaunchApp				// Launches .icComandLine from .icLaunchDir in .icWindowMode
		*							// NB - at least .icCommandLine must be set to not fail
		*							RETURNS: BOOL, check icErrorMessage on .F.
		*	LaunchAppAndWait		// Call LaunchApp() and wait on either user termination or process termination
		*							RETURNS: BOOL, check icErrorMessage on .F.
		*	CheckProcessExitCode	(O) Process handle to check, defaults to .inProcessHandle
		*							// Get Process named by Process Handle's Exit Code (259 = still running)
		*							RETURNS:  Integer, check on NULL, if NULL, check icErrorMessage
		*	ExtractDWORD			(R) String to convert
		*							//Converts a 4 byte or longer string to a DWORD integer
		*							RETURNS:  Integer, check on NULL, if NULL arg was invalid
		*	KillProc				(O) Process handle to Terminate, defaults to .inProcessHandle
		*							// Kills specified process using TerminateProcess()
		*							RETURNS:  BOOL, check icErrorMessage on .F.
		*	GetProcHandle			//  Returns the Process Handle for the current Process
		*							// NB - only useful for KillProc(), since Destroy will close the handle
		*							RETURNS:  Integer, check for NULL, if NULL no process was started yet
		*	ParsePROCESSINFOStruc	// Pulls the Process Handle and Thread Handle from the PROCESSINFO structure
		*							// Only used internally
		*	ReleaseHandle			(R)  Handle to Close
		*							//  Invokes CloseHandle() to explicitly release process/thread handles
		*							//  Only used internally, but can be externalized
		*							RETURNS:  BOOL, check .icErrorMessage if false
		*
		LPARAMETERS tcCommandLine, tcLaunchDir, tcWindowMode
		*	Set up the environment for the object
		LOCAL aDirTest[1,5]
		WITH THIS
			.icErrorMessage = ''
			.icCommandLine = ''
			.icLaunchDir = ''
			.icWindowMode = ''
			.inProcessHandle = NULL
			.inThreadHandle = NULL
			* store parameters if passed
			IF TYPE('tcCommandLine') = 'C'
				.icCommandLine = ALLTRIM(tcCommandLine)
			ENDIF
			DO CASE
			CASE TYPE('tcLaunchDir') # 'C'
				*	Not a character expression - ignore
			CASE ADIR(aDirTest, tcLaunchDir, 'D') # 1
				*	Either directory doesn't exist, or there's a wildcard in the expression
				.icErrorMessage = 'Invalid directory for startup passed to Init method'
			OTHERWISE
				*	Valid directory - save it
				.icLaunchDir = ALLTRIM(tcLaunchDir)
			ENDCASE
			DO CASE
			CASE TYPE('tcWindowMode') # 'C'
				*	Not passed in or not valid type
			CASE INLIST(PADR(UPPER(ALLTRIM(tcWindowMode)),3),'NOR','MIN','MAX','HID')
				*	Valid mode - set it
				.icWindowMode = PADR(UPPER(ALLTRIM(tcWindowMode)),3)
			OTHERWISE
				*	No a valid character string
				IF ! EMPTY(.icErrorMessage)
					.icErrorMessage = .icErrorMessage + ' & '
				ENDIF
				.icErrorMessage = .icErrorMessage + CHR(10) + CHR(13) + 'Invalid WindowMode passed to Init Method'
			ENDCASE
		ENDWITH
		RETURN .T.
		
	ENDPROC

	PROCEDURE killproc
		LPARAMETER nProcessToKill
		IF TYPE('nProcessToKill') # 'N'
			nProcessToKill = This.inProcessHandle
		ENDIF
		DECLARE SHORT TerminateProcess IN WIN32API AS KillProc ;
			INTEGER hProcess, ;
			INTEGER uExitCode
		LOCAL nResult
		IF ! ISNULL(nProcessToKill)
			nResult = KillProc(nProcessToKill,0)
			this.icErrorMessage = IIF(nResult = 0, 'TerminateProcess() could not kill process handle requested','')
		ELSE
			this.icErrorMessage = 'NULL handle passed to KillProc()'
			nResult = 0
		ENDIF
		RETURN (nResult = 1)
	ENDPROC

	PROCEDURE launchapp
		LOCAL cCommandLine, uFromDir, cWindowMode
		WITH This
			.icErrorMessage = ''
			IF TYPE('.icCommandLine') # 'C'
				*	Command line must be a character string
				.icErrorMessage = 'icCommand line must be set, and a string value'
				RETURN .F.
			ELSE
				cCommandLine = ALLTRIM(.icCommandLine)
			ENDIF
			IF TYPE('.icLaunchDir') # 'C' OR EMPTY(.icLaunchDir)
				*	If not a character string, pass a null pointer, defaulting to Current Working Dir
				uFromDir = 0
			ELSE
				*	Otherwise, null pad the string
				uFromDir = .icLaunchDir + CHR(0)
			ENDIF
			IF TYPE('.icWindowMode') # 'C'
				*	If not passed, set to null string
				cWindowMode = ''
			ELSE
				*	Translate the passed window mode to uppercase
				cWindowMode = UPPER(.icWindowMode)
			ENDIF
			*	This API call does the work.  The parameters are as follows:
			*		lpszModuleName - ptr-> file name of module to execute.  Since we aren't launching .CPLs, do not use
			*		lpszCommandLine - ptr-> command to execute, as passed in method
			*		lpSecurityAttributesProcess - ptr-> SECURITY_ATTRIBUTES structure for Process.  Pass a null pointer
			*		lpSecurityAttributesThread - ptr-> SECURITY_ATTRIBUTES structure for first thread.  Pass a null pointer
			*		bInheritHandles - whether or not chlid inherits parent handles.  Since no SECURITY_ATTRIBUTES passed, default to FALSE
			*		dwCreateFlags - Process Creation Mode flag set.  we use the default mode at normal priority, ie 0
			*		lpvEnvironment	- ptr-> a set of environment strings as if a MULTI_SZ.  We don't set, so pass a null pointer
			*		lpszStartupDir - ptr-> the starting directory.  If none provided to method, pass a null pointer
			*		lpStartInfo - ptr-> a STARTUPINFO structure.  We use one structure member at times.
			*		lpProcessInfo - ptr-> a PROCESS_INFORMATION structure, used to return PID/PHANDLE detail.  We use one member
		*Declare Integer Wow64EnableWow64FsRedirection In kernel32 Integer nEnable
			DECLARE SHORT CreateProcess IN WIN32API AS CrPr ;
				STRING lpszModuleName, ;
				STRING @lpszCommandLine, ;
				STRING lpSecurityAttributesProcess, ;
				STRING lpSecurityAttributesThread, ;
				SHORT bInheritHandles, ;
				INTEGER dwCreateFlags, ;
				STRING lpvEnvironment, ;
				STRING lpszStartupDir, ;
				STRING @lpStartInfo, ;
				STRING @lpProcessInfo
		
		*Wow64EnableWow64FsRedirection(.f.)
			LOCAL cProcessInfo, cStartUpInfo
		
			*	Make default Structures for the CreateProcess call
			*
			*	ProcessInfo - 4 bytes, a Process handle, a Thread Handle, a (DWORD) ProcessId and a (DWORD) ThreadID
			*					we save the Process handle and return it to caller in tnReturnProcessHandle
		
			cProcessInfo = REPL(CHR(0),16)
		
			*	StartUpInfo is a 68 byte long complex structure;  we either have 68 bytes with a cb member (byte 1) 68
			*	or with cb of 68, dwFlag low order byte (byte 45) of 1, and low order byte wShowWindow (byte 49) set to
			*	the SW_ value appropriate for the Window Mode desired.
		
			DO CASE
			CASE cWindowMode = 'HID'
				*	Hide - use STARTF_USESHOWFLAG and value of 0
				cStartUpInfo = CHR(68) + ;
								REPL(CHR(0),43) + ;
								CHR(1) + ;
								REPL(CHR(0),23)
			CASE cWindowMode = 'NOR'
				*	Normal - use STARTF_USESHOWFLAG and value of 1
				cStartUpInfo = CHR(68) + ;
								REPL(CHR(0),43) + ;
								CHR(1) + ;
								REPL(CHR(0),3) + ;
								CHR(1) + ;
								REPL(CHR(0),19)
			CASE cWindowMode = 'MIN'
				*	Minimize - use STARTF_USESHOWFLAG and value of 2
				cStartUpInfo = CHR(68) + ;
								REPL(CHR(0),43) + ;
								CHR(1) +  ;
								REPL(CHR(0),3) + ;
								CHR(2) + ;
								REPL(CHR(0),19)
			CASE cWindowMode = 'MAX'
				*	Maximize - use STARTF_USESHOWFLAG and value of 3
				cStartUpInfo = CHR(68) + ;
								REPL(CHR(0),43) + ;
								CHR(1) +  ;
								REPL(CHR(0),3) + ;
								CHR(3) + ;
								REPL(CHR(0),19)
			OTHERWISE
				*	Use default of application
				cStartUpInfo = CHR(68) + REPL(CHR(0),67)
			ENDCASE
			LOCAL lResult
			lResult = CrPr(	0, ;
							cCommandLine, ;
							0, 0, 0, 0, 0, ;
							uFromDir, ;
							@cStartUpInfo, ;
							@cProcessInfo)
			*	Strip the handles from the PROCESS_INFORMATION structure and save in private properties
			IF lResult = 1
				.ParseProcessInfoStruc(cProcessInfo)
				RETURN .T.
			ELSE
				.icErrorMessage = 'Process Specified by icCommandLine could not be started'
				RETURN .F.
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE launchappandwait
		#DEFINE cnINFINITE 		0xFFFFFFFF
		#DEFINE cnHalfASecond	500	&& milliseconds
		#DEFINE cnTimedOut		258	&& 0x0102
		*	We need some API calls, declare here
		*	GetCurrentProcess returns the pseudohandle of the current process (ie VFP instance)
		DECLARE INTEGER GetCurrentProcess IN WIN32API AS GetCurrProc
		*	WaitForIdleInput waits until the application is instantiated and at it's event loop
		DECLARE INTEGER WaitForInputIdle IN WIN32API AS WaitInpIdle ;
			INTEGER nProcessHandle, ;
			INTEGER nWaitForDuration
		*	WaitForSingleObject waits until the handle in parm 1 is signalled or the timeout period expires
		DECLARE INTEGER WaitForSingleObject IN WIN32API AS WaitOnAppExit ;
			INTEGER hProcessHandle, ;
			INTEGER dwTimeOut
		*	Save the Process handle if any and the result of LaunchApp
		*	Fire the app and save the process handle
		LOCAL uResult
		uResult = 0
		WITH This
			.icErrorMessage = ''
			IF .LaunchApp()
				uResult = 1
				*	It's been launched;  wait until we're idling along
				=WaitInpIdle(GetCurrProc(),cnINFINITE)
				*	As long as the other process exists, wait for it
				DO WHILE WaitOnAppExit(.inProcessHandle, cnHalfASecond) = cnTimedOut
					*	Give us an out in case the other app hangs - let
					IF INKEY() = 27
						*	Still running but we aren't waiting - return a -1 as a warning
						.icErrorMessage = 'Process started but user did not wait on termination'
						uResult = 0
						EXIT
					ENDIF
				ENDDO
			ELSE
				*	Return 0 to indicate failure
				uResult = 0
			ENDIF
		ENDWITH
		RETURN (uResult = 1)
		
	ENDPROC

	PROCEDURE parseprocessinfostruc
		LPARAMETER cProcessInfoStructure
		WITH This
			.inProcessHandle = .ExtractDWORD(cProcessInfoStructure)
			.inThreadHandle = .ExtractDWORD(SUBST(cProcessInfoStructure,5))
		ENDWITH
				
		
	ENDPROC

	PROTECTED PROCEDURE releasehandle
		LPARAMETER nHandleToRelease
		LOCAL nResult
		*	Use CloseHandle(), returns a BOOL;  0 = False
		DECLARE SHORT CloseHandle IN Win32API AS CloseHand INTEGER nHandleToClose
		IF TYPE('nHandleToRelease') = 'N' AND ! ISNULL(nHandleToRelease)
			nResult = CloseHand(nHandleToRelease)
			this.icErrorMessage = IIF(nResult = 0, 'TerminateProcess() failed to close handle','')
		ELSE
			this.icErrorMessage = 'Invalid handle passed to ReleaseHandle() invocation'
			nResult = 0
		ENDIF
		RETURN (nResult = 1)
	ENDPROC

ENDDEFINE

DEFINE CLASS cusenvironment AS custom 		&& Default settings for DATASESSION
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\stuff.h"
	*<DefinedPropArrayMethod>
		*m: reset_oldresource		&& Setze Resource auf den Wert beim Init
		*m: restore_		&& Setzt die SET-Befehle auf ihre ursprünglichen Werte zurück.
		*m: restore_global		&& Stellt Einstellungen zurück, die für das ganze Programm, unabhängig von DATASESSION gelten. (Wird einmal für das Programm durchgeführt)
		*m: restore_private		&& Stellt Einstellungen zurück, die für eine private DATASESSION gelten. Wird für jede Form mit privater Datasession durchgeführt.
		*m: restore_toolbars		&& Stellt die Standard-Toolbars wieder her.
		*m: set_		&& Stellt alle SET-Befehle ein.
		*m: set_global		&& Setze Einstellungen, die für das ganze Programm, unabhängig von DATASESSION gelten. (Wird einmal für das Programm durchgeführt)
		*m: set_private		&& Setze Einstellungen, die für eine private DATASESSION gelten. Wird für jede Form mit privater Datasession durchgeführt.
		*m: store_		&& Speichert die Einstellungen der SET Befehle.
		*m: store_global		&& Speichert Einstellungen die für das ganze Programm, unabhängig von DATASESSION gelten. (Wird einmal für das Programm durchgeführt)
		*m: store_private		&& Speichert Einstellungen die für eine private DATASESSION gelten. Wird für jede Form mit privater Datasession durchgeführt.
		*m: store_toolbars		&& Speichert die sichtbarkeit der Standard-Toolbars und verbirgt diese.
		*p: gcdefaultclasslib		&& Spezielle, zur Arbeit unbedingt nötige ClassLibrarys. (Frameworkspezifisch)
		*p: glisapplication		&& Wir gehören zum Hauptprogramm oder objekt, wird gestarte bevor irgend eine Einstellung getrofffen wird.
		*p: hcstartpath		&& intern, der Pfad unter dem main.prg gerufen wurde (der Pfad der Exe, nur um im Debugmode die Includes zu finden)
		*p: rnsetting		&& Zähler des letzten Satzes gespeicherter Eigenschaften
		*a: rasettings[1,3]		&& Array mit Objekten der gespeicherten Einstellungen. THIS.gnSetting hält die letzten gespeicherten Satz
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN hcstartpath
	PROTECTED gcdefaultclasslib,rasettings,rnsetting
	*<PropValue>
		gcdefaultclasslib = 
		Name = "cusenvironment"
		rnsetting = 0
		_memberdata = <VFPData>
			<memberdata name="reset_oldresource" type="method" display="Reset_OldResource" favorites="False"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE Destroy
		*THIS.gESET()
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS ;
		 tlIsApplication,;
		 tcStartPath,;
		 tlNoSet
		
		WITH THIS
		 IF VARTYPE(m.tcStartPath)='C' AND DIRECTORY(m.tcStartPath) THEN
		  .hcStartPath = ADDBS(m.tcStartPath)
		 ENDIF &&VARTYPE(m.tcStartPath ...
		
		*wenn die Klasse durch CREATEOBJECT oder ADDOBJECT gerufen wird
		*Wenn dabei tlIsApplication dann True.
		*False bekommen wir immer, wenn wir das Init durch ein Object im Container starten.
		*und dann soll THIS.glIsApplication auch schön so bleiben wie es ist
		 .glIsApplication = IIF(TYPE('tlIsApplication')='L' AND m.tlIsApplication,True,.glIsApplication)
		
		*-- Einstellungen der SET- und ON-Befehle speichern
		*dies wird in Main.prg geschrieben, da dort schon die ersten Veränderungen vorgenommen werden.
		*der Hauptsinn liegt wohl im Wiederherstellen der Umgebung.
		
		 .Store_(IIF(.glIsApplication,2^0+2^1+2^2,2^0))
		
		 IF !m.tlNoSet THEN
		  .Set_(2^0)
		 ENDIF &&!m.tlNoSet
		
		*!*	 IF .glIsApplication THEN
		*!*	  PUSH MENU _MSYSMENU
		*!*	 ENDIF &&.glIsApplication
		
		*!*	 .Store_Private()
		
		*!*	 IF .glIsApplication THEN
		*!*	  .Store_Global()
		*!*	 ENDIF &&.glIsApplication
		
		ENDWITH &&THIS
		
	ENDPROC

	PROCEDURE reset_oldresource		&& Setze Resource auf den Wert beim Init
		IF APPLICATION.STARTMODE=0 THEN
		 LOCAL;
		  lvTemp
		
		 WITH THIS
		  IF EMPTY(.rnSetting) THEN
		   RETURN
		  ENDIF &&EMPTY(.rnSetting)
		
		  WITH .raSettings(.rnSetting,1)
		   lvTemp = .gcOldResource
		   IF m.lvTemp='OFF' THEN
		    SET RESOURCE OFF
		   ELSE &&m.lvTemp='OFF'
		    lvTemp = .gcOldResource_FName
		    IF FILE(m.lvTemp) THEN
		     SET RESOURCE TO (m.lvTemp)
		    ELSE &&FILE(m.lvTemp)
		*    SET RESOURCE TO
		     SET RESOURCE OFF
		    ENDIF &&FILE(m.lvTemp)
		   ENDIF &&m.lvTemp='OFF'
		  ENDWITH &&.raSettings(.rnSetting,1)
		 ENDWITH &&THIS
		ENDIF &&APPLICATION.STARTMODE=0
		
	ENDPROC

	PROCEDURE restore_		&& Setzt die SET-Befehle auf ihre ursprünglichen Werte zurück.
		LPARAMETERS;
		 tnSet,;
		 tnPos
		
		IF PCOUNT()=0 OR VARTYPE(tnSet)#'N' THEN
		 tnSet = 2^0
		ENDIF &&PCOUNT()=0 OR VARTYPE(tnSet)#'N'
		
		*-- SET- und ON-Befehle einstellen
		WITH THIS
		 IF EMPTY(.rnSetting) THEN
		  RETURN
		 ENDIF &&EMPTY(.rnSetting)
		
		 IF PCOUNT()>1 AND BETWEEN(m.tnPos,1,.rnSetting) THEN
		  .rnSetting = m.tnPos
		 ENDIF &&PCOUNT()s>1 AND BETWEEN(m.tnPos,1,.rnSetting)
		
		 IF BITAND(m.tnSet,2^2)=2^2 AND .raSettings(.rnSetting,4) THEN
		  POP MENU _MSYSMENU TO MASTER
		  .raSettings(.rnSetting,3) = True
		 ENDIF &&BITAND(m.tnSet,2^2)=2^2 AND .raSettings(.rnSetting,4)
		
		 IF BITAND(m.tnSet,2^0)=2^0 AND .raSettings(.rnSetting,2) THEN
		  .Restore_Private(.raSettings(.rnSetting,1))
		 ENDIF &&BITAND(m.tnSet,2^0)=2^0 AND .raSettings(.rnSetting,2)
		 IF BITAND(m.tnSet,2^1)=2^1 AND .raSettings(.rnSetting,3) THEN
		  .Restore_Global(.raSettings(.rnSetting,1))
		 ENDIF &&BITAND(m.tnSet,2^1)=2^1 AND .raSettings(.rnSetting,3)
		
		 .raSettings(.rnSetting,1) = NIL
		 .raSettings(.rnSetting,2) = False
		 .raSettings(.rnSetting,3) = False
		 .raSettings(.rnSetting,4) = False
		
		 .rnSetting = .rnSetting-1
		
		 DIMENSION;
		  .raSettings(EVL(.rnSetting,1),4)
		
		ENDWITH &&THIS
		
	ENDPROC

	PROCEDURE restore_global		&& Stellt Einstellungen zurück, die für das ganze Programm, unabhängig von DATASESSION gelten. (Wird einmal für das Programm durchgeführt)
		LPARAMETERS;
		 toObject
		
		LOCAL;
		 lvTemp    AS VARIANT,;
		 lvOldTalk AS VARIANT
		
		WITH toObject
		 lvOldTalk = SET('TALK')
		 SET TALK OFF
		
		 lvTemp = .gcOldAlternate
		 SET ALTERNATE &lvTemp
		 lvTemp = .gcOldAlternate_FName
		 IF FILE(m.lvTemp) THEN
		  lvTemp = '"'+m.lvTemp+'" ADDITIVE'
		 ENDIF &&FILE(m.lvTemp)
		 SET ALTERNATE TO &lvTemp
		
		 lvTemp = .gcOldAsserts
		 SET ASSERTS &lvTemp
		
		 lvTemp = .gcOldBell
		 SET BELL &lvTemp
		 .gcOldBell              = SET('BELL')
		 lvTemp = .gcOldBell_FName
		 IF FILE(m.lvTemp) THEN
		  SET BELL TO (m.lvTemp)
		 ELSE &&FILE(m.lvTemp)
		  SET BELL TO
		 ENDIF &&FILE(m.lvTemp)
		
		 lvTemp = .gcOldBrowseIME
		 SET BROWSEIME &lvTemp
		
		 lvTemp = .gcOldClasslib
		 SET CLASSLIB TO &lvTemp
		
		 lvTemp = .gcOldClock
		 SET CLOCK &lvTemp
		 IF m.lvTemp='ON' THEN
		  lvTemp = .gcOldClock_Coord
		  SET CLOCK TO &lvTemp
		 ENDIF &&m.lvTemp='ON'
		
		 lvTemp = .gcOldCompatible+' '+.gcOldCompatible_Prompt
		 SET COMPATIBLE &lvTemp
		
		 lvTemp = .gcOldConsole
		 SET CONSOLE &lvTemp
		
		 lvTemp = .gcOldCoverage
		 IF FILE(m.lvTemp) THEN
		  lvTemp = '"'+m.lvTemp+'" ADDITIVE'
		 ENDIF &&FILE(m.lvTemp)
		
		 SET COVERAGE TO &lvTemp
		
		 lvTemp = .gcOldCpDialog
		 SET CPDIALOG &lvTemp
		
		 lvTemp = .gcOldCursor
		 SET CURSOR &lvTemp
		
		 lvTemp = .gcOldDefault
		 IF DIRECTORY(m.lvTemp) THEN
		  SET DEFAULT TO (m.lvTemp)
		 ELSE &&DIRECTORY(m.lvTemp)
		  SET DEFAULT TO
		 ENDIF &&DIRECTORY(m.lvTemp)
		
		 lvTemp = .gcOldDevice
		 SET DEVICE TO &lvTemp
		
		 lvTemp = .gcOldDisplay
		* SET DISPLAY TO &lvTemp
		
		 lvTemp = .gcOldEscape
		 SET ESCAPE &lvTemp
		
		 lvTemp = .gcOldEventList
		 SET EVENTLIST TO &lvTemp
		
		 lvTemp = .gcOldEventTracking
		 SET EVENTTRACKING &lvTemp
		 lvTemp = .gcOldEventTracking_FName
		 IF FILE(m.lvTemp) THEN
		  lvTemp = '"'+m.lvTemp+'" ADDITIVE'
		 ENDIF &&FILE(m.lvTemp)
		 SET EVENTTRACKING TO &lvTemp
		
		 lvTemp = .gnOldFDoW
		 SET FDOW TO (lvTemp)
		
		 lvTemp = .gcOldFullPath
		 SET FULLPATH &lvTemp
		
		 lvTemp = .gnOldFWeek
		 SET FWEEK TO (lvTemp)
		
		 lvTemp = .gcOldHeadings
		 SET HEADINGS &lvTemp
		
		 IF .gcOldHelp='ON' AND FILE(.gcOldHelp_FName) THEN
		  lvTemp = .gcOldHelp_FName
		  SET HELP TO (m.lvTemp)
		  SET HELP ON
		 ELSE &&.gcOldHelp='ON' ...
		  SET HELP OFF
		 ENDIF &&.gcOldHelp='ON' ...
		
		 lvTemp = .gcOldKeyComp
		 SET KEYCOMP TO &lvTemp
		
		 _VFP.LANGUAGEOPTIONS = .gnOldLanguageOptions
		
		 lvTemp = .gcOldLibrary
		 SET LIBRARY TO &lvTemp
		
		 _SCREEN.MOUSEPOINTER = .gnOldMousePointer
		
		 lvTemp = .gcOldNotify
		 SET NOTIFY &lvTemp
		
		 lvTemp = .gcOldNullDisplay
		 SET NULLDISPLAY TO (m.lvTemp)
		
		 lvTemp = .gnOldOdoMeter
		 SET ODOMETER TO (m.lvTemp)
		
		 lvTemp = .gcOldOLEObject
		 SET OLEOBJECT &lvTemp
		
		 lvTemp = .gcOldOptimize
		 SET OPTIMIZE &lvTemp
		
		 lvTemp = .gcOldPalette
		 SET PALETTE &lvTemp
		
		 lvTemp = .gcOldPath
		 SET PATH TO &lvTemp
		
		*!*	 lvTemp = .gcOld
		*!*	 SET BELL &lvTemp
		*!*	 .gcOldPrinter           = SET('PRINTER')
		*!*	 lvTemp = .gcOld
		*!*	 SET BELL &lvTemp
		*!*	 .gcOldPrinter_PortName  = SET('PRINTER',1)
		*!*	 lvTemp = .gcOld
		*!*	 SET BELL &lvTemp
		*!*	 .gcOldPrinter_WinDefa   = SET('PRINTER',2)
		*!*	 lvTemp = .gcOld
		*!*	 SET BELL &lvTemp
		*!*	 .gcOldPrinter_FoxDefa   = SET('PRINTER',3)
		 lvTemp = .gcOldProcedure
		 SET PROCEDURE TO &lvTemp
		
		 lvTemp = ;
		  STRTRAN(STR(.gnOldRefresh       ,12,3),SET('POINT'),'.')+','+;
		  STRTRAN(STR(.gnOldrefresh_Buffer,12,3),SET('POINT'),'.')
		 SET REFRESH TO &lvTemp
		
		 IF APPLICATION.STARTMODE=0 THEN
		  lvTemp = .gcOldResource
		  IF m.lvTemp='OFF' THEN
		   SET RESOURCE OFF
		  ELSE &&m.lvTemp='OFF'
		   lvTemp = .gcOldResource_FName
		   IF FILE(m.lvTemp) THEN
		    SET RESOURCE TO (m.lvTemp)
		   ELSE &&FILE(m.lvTemp)
		*    SET RESOURCE TO
		    SET RESOURCE OFF
		   ENDIF &&FILE(m.lvTemp)
		  ENDIF &&m.lvTemp='OFF'
		 ENDIF &&APPLICATION.STARTMODE=0
		
		 lvTemp = .gcOldSpace
		 SET SPACE &lvTemp
		
		 lvTemp = .gcOldStatus
		 SET STATUS &lvTemp
		
		 lvTemp = .gcOldStatusBar
		 SET STATUS BAR &lvTemp
		
		 lvTemp = .gnOldStrictDate
		 SET STRICTDATE TO (m.lvTemp)
		
		 lvTemp = .gnOldTypeAhead
		 SET TYPEAHEAD TO (m.lvTemp)
		
		 lvTemp = .gcOldUDFParms
		 SET UDFPARMS TO &lvTemp
		
		 CD (.gcOldDir)
		
		 lvTemp = .gcOldOnShutDown
		 ON SHUTDOWN &m.lvTemp
		
		 lvTemp = .gcOldOnError
		 ON ERROR &m.lvTemp
		
		 lvTemp = .gcOldOnEscape
		 ON ESCAPE &m.lvTemp
		
		 lvTemp = .gcOldOnPage
		 ON PAGE &m.lvTemp
		
		 _SCREEN.CAPTION = .gcOldScreenCaption
		 _SCREEN.ICON    = .gcOldScreenIcon
		
		 #IFNDEF dnVersion7_Prog
		  SET ENGINEBEHAVIOR (.gnOldEngineBehavior)
		  SET TABLEVALIDATE TO (.gnOldTableValidate)
		  lvTemp =  .gcOldNotifyCursor
		  SET NOTIFY CURSOR &lvTemp
		  _SCREEN.THEMES = .glOldThemes
		 #ENDIF &&dnVersion7_Prog
		
		 #IFNDEF dnVersion8_Prog THEN
		  lvTemp = .gnOldReportBehavior
		  SET REPORTBEHAVIOR (m.lvTemp)
		
		  _REPORTOUTPUT  = .gnOldReportOutput
		  _REPORTPREVIEW = .gnOldReportPreview
		  _REPORTBUILDER = .gnOldReportBuilder
		 #ENDIF &&dnVersion8_Prog
		
		*not for this project
		*THIS.Restore_ToolBars(toObject)
		
		 SET TALK &lvOldTalk
		
		 lvTemp = .goLabel.Alt_F10
		 ON KEY LABEL ALT+F10 &lvTemp
		
		 SYS(0602,.gnSys_0602)
		 SYS(2450,.gnSys_2450)
		 SYS(2700,.gnSys_2700)
		
		ENDWITH &&toObject
		
	ENDPROC

	PROCEDURE restore_private		&& Stellt Einstellungen zurück, die für eine private DATASESSION gelten. Wird für jede Form mit privater Datasession durchgeführt.
		LPARAMETERS;
		 toObject
		
		LOCAL;
		 lvTemp AS VARIANT
		
		WITH toObject
		 lvTemp = .gcOldAnsi
		 SET ANSI &lvTemp
		
		 lvTemp = .gcOldAutoSave
		 SET AUTOSAVE &lvTemp
		
		 lvTemp = .gnOldBlockSize
		 SET BLOCKSIZE TO (m.lvTemp)
		
		 lvTemp = .gcOldCarry
		 SET CARRY &lvTemp
		
		 lvTemp = .gcOldCollate
		 SET COLLATE TO (m.lvTemp)
		
		 lvTemp = .gcOldConfirm
		 SET CONFIRM &lvTemp
		
		 lvTemp = .gcOldDatabase
		 IF DBUSED(m.lvTemp) THEN
		  SET DATABASE TO (m.lvTemp)
		 ELSE &&DBUSED(m.lvTemp)
		  SET DATABASE TO
		 ENDIF &&DBUSED(m.lvTemp)
		
		 lvTemp = .gcOldDeleted
		 SET DELETED &lvTemp
		
		 lvTemp = .gcOldExact
		 SET EXACT &lvTemp
		
		 lvTemp = .gcOldExclusive
		 SET EXCLUSIVE &lvTemp
		
		 lvTemp = .gcOldFixed
		 SET FIXED &lvTemp
		
		 lvTemp = .gcOldLock
		 SET LOCK &lvTemp
		
		 lvTemp = .gnOldMemoWidth
		 SET MEMOWIDTH TO (m.lvTemp)
		
		 lvTemp = .gcOldMultiLocks
		 SET MULTILOCKS &lvTemp
		
		 lvTemp = .gcOldNear
		 SET NEAR &lvTemp
		
		 lvTemp = .gcOldNull
		 SET NULL &lvTemp
		
		 #IFDEF dnVersion8_Prog THEN
		  lvTemp = .gnOldReprocess
		  SET REPROCESS TO (m.lvTemp)
		 #ELSE &&dnVersion8_Prog
		  lvTemp = .gnOldReprocess
		  IF .gnOldReprocessMode=0 THEN
		   SET REPROCESS TO (m.lvTemp)
		  ELSE &&.gnOldReprocessMode=0
		   SET REPROCESS TO (m.lvTemp) SECONDS
		  ENDIF &&.gnOldReprocessMode=0
		
		  lvTemp = .gnOldReprocess_S
		  IF .gnOldReprocessMode_S=0 THEN
		   SET REPROCESS TO (m.lvTemp) SYSTEM
		  ELSE &&.gnOldReprocessMode_S=0
		   SET REPROCESS TO (m.lvTemp) SECONDS SYSTEM
		  ENDIF &&.gnOldReprocessMode_S=0
		 #ENDIF &&dnVersion8_Prog
		
		 lvTemp = .gcOldSafety
		 SET SAFETY &lvTemp
		
		 lvTemp = .gcOldTalk
		 SET TALK &lvTemp
		
		 lvTemp = .gcOldTalk_Window
		 SET TALK &lvTemp
		
		 lvTemp = .gcOldUnique
		 SET UNIQUE &lvTemp
		
		*Einstellungen die Länderspezifisch sind
		 lvTemp = .gcOldSysFormats
		 SET SYSFORMATS &lvTemp
		
		*Zwischen SET SYSFORMATS und den folgenden Einstellungen (bis zum Ende) gibt es Wechselwirkungen,
		*siehe Hilfe SET SYSFORMAT
		 lvTemp = 'SET CURRENCY '+.gcOldCurrency
		 &lvTemp
		
		 lvTemp = 'SET CURRENCY TO "'+.gcOldCurrency_Symbol+'"'
		 &lvTemp
		
		 lvTemp = .gnOldDecimals
		 SET DECIMALS TO (m.lvTemp)
		
		 lvTemp = .gcOldPoint
		 IF EMPTY(m.lvTemp) THEN
		  SET POINT TO
		 ELSE &&EMPTY(m.lvTemp)
		  SET POINT TO (m.lvTemp)
		 ENDIF &&EMPTY(m.lvTemp)
		
		 lvTemp = .gcOldDate
		 SET DATE &lvTemp
		
		 DO CASE
		  CASE .gnOldDateOrder=0
		   SET DATE MDY
		  CASE .gnOldDateOrder=1
		   SET DATE DMY
		  CASE .gnOldDateOrder=2
		   SET DATE YMD
		 ENDCASE
		
		*Zwischen SET DATE und den folgenden Einstellungen (bis zum Ende) gibt es Wechselwirkungen,
		*siehe Hilfe SET DATE
		 lvTemp = .gcOldCentury+;
		  ' TO '+STR(.gnOldCentury_nCentury)+' ROLLOVER '+STR(.gnOldCentury_nRollOver)
		 SET CENTURY &lvTemp
		
		 lvTemp = .gnOldHours
		 SET HOURS TO (m.lvTemp)
		
		 lvTemp = .gcOldSeconds
		 SET SECONDS &lvTemp
		
		 lvTemp = .gcOldMark
		 IF EMPTY(m.lvTemp) THEN
		  SET MARK TO
		 ELSE &&EMPTY(m.lvTemp)
		  SET MARK TO (m.lvTemp)
		 ENDIF &&EMPTY(m.lvTemp)
		
		
		 #IFNDEF dnVersion7_Prog
		  lvTemp = .gcOldAutoIncError
		  SET AUTOINCERROR &lvTemp
		 #ENDIF &&dnVersion7_Prog
		
		 #IFNDEF dnVersion8_Prog THEN
		  lvTemp = .gcOldTablePrompt
		  SET TABLEPROMPT &lvTemp
		
		  lvTemp = .gcOldVarCharMapping
		  SET VARCHARMAPPING &lvTemp
		 #ENDIF &&dnVersion8_Prog
		ENDWITH &&toObject
		
	ENDPROC

	PROCEDURE restore_toolbars		&& Stellt die Standard-Toolbars wieder her.
		LPARAMETERS;
		 toObject
		
		IF APPLICATION.STARTMODE=0 THEN
		 LOCAL;
		  lcKeyBrd AS CHARACTER,;
		  lnToolBar AS INTEGER
		
		 WITH toObject
		*-- Zeigt alle Visual FoxPro-Symbolleisten an, die vorher verborgen wurden
		
		  lcKeyBrd = ""
		
		  FOR lnToolBar = 1 TO 12
		   DO CASE
		    CASE INLIST(.gaToolBars(lnToolBar,1),dcTB_DEBUGGER_LOC,dcTB_DEBUGGER_LOC_UK);
		      AND !(WEXIST('Visual FoxPro Debugger');
		      OR WEXIST('Trace') OR WEXIST('Watch') OR WEXIST('Locals') OR WEXIST('Call Stack') OR WEXIST('Debug Output'))
		*Debugger Toolbar. Nur wenn der Debugger geöffnet ist
		     lcKeyBrd = lcKeyBrd+.gaToolBars(lnToolBar,3)
		    CASE .gaToolBars(lnToolBar,4) AND !WEXIST(.gaToolBars(lnToolBar,1))
		     lcKeyBrd = lcKeyBrd+" "+.gaToolBars(lnToolBar,3)
		    CASE .gaToolBars(lnToolBar,4) AND .gaToolBars(lnToolBar,5)
		     lcKeyBrd = lcKeyBrd+.gaToolBars(lnToolBar,3)
		     ACTIVATE WINDOW (.gaToolBars(lnToolBar,1))
		    OTHERWISE
		     lcKeyBrd = lcKeyBrd+.gaToolBars(lnToolBar,3)
		   ENDCASE
		  ENDFOR &&lnToolBar
		  IF [ ]$lcKeyBrd THEN
		* lcKeyBrd = [{F10}]+"{PAUSE 2}"+[V]+"{PAUSE 5}"+[T]+lcKeyBrd+[{CTRL+W}]
		
		   oShell = CREATEOBJECT("wscript.shell")
		   oShell.SendKeys("%")
		   oShell.SendKeys("vt")
		*WAIT WINDOW 'nun ists offen' TIMEOUT 5
		    oShell.SendKeys(lcKeyBrd)
		   oShell.SendKeys("^w")
		   RELEASE oShell
		
		* KEYBOARD lcKeyBrd CLEAR PLAIN
		   DOEVENTS
		  ENDIF &&"{SPACEBAR}"$lcKeyBrd
		
		  FOR lnToolBar = 13 TO ALEN(.gaToolBars, 1)
		   IF .gaToolBars(lnToolBar,4) AND WEXIST(.gaToolBars(lnToolBar,1)) THEN
		    SHOW WINDOW (.gaToolBars(lnToolBar,1))
		   ENDIF &&.gaToolBars(lnToolBar,4) AND WEXIST(.gaToolBars(lnToolBar,1))
		  ENDFOR &&lnToolBar
		 ENDWITH &&toObject
		ENDIF &&APPLICATION.STARTMODE=0
		
	ENDPROC

	PROCEDURE set_		&& Stellt alle SET-Befehle ein.
		LPARAMETERS;
		 tnSet
		
		IF PCOUNT()=0 OR VARTYPE(tnSet)#'N' THEN
		 tnSet = 2^0
		ENDIF &&PCOUNT()=0 OR VARTYPE(tnSet)#'N'
		*-- SET- und ON-Befehle einstellen
		WITH THIS
		 IF BITAND(m.tnSet,2^0)=2^0 THEN
		  .Set_Private()
		 ENDIF &&BITAND(m.tnSet,2^0)=2^0
		 IF BITAND(m.tnSet,2^1)=2^1 THEN
		  .Set_Global()
		 ENDIF &&BITAND(m.tnSet,2^1)=2^1
		ENDWITH &&THIS
		
	ENDPROC

	PROCEDURE set_global		&& Setze Einstellungen, die für das ganze Programm, unabhängig von DATASESSION gelten. (Wird einmal für das Programm durchgeführt)
		LOCAL ;
		 lvTemp AS VARIANT
		
		WITH THIS
		*just not this app
		 #IF .F. THEN
		  CLOSE DEBUGGER
		  IF WEXIST('Trace') THEN
		   RELEASE WINDOWS 'Trace'
		  ENDIF &&WEXIST('Trace')
		  IF WEXIST('Watch') THEN
		   RELEASE WINDOWS 'Watch'
		  ENDIF &&WEXIST('Watch')
		  IF WEXIST('Locals') THEN
		   RELEASE WINDOWS 'Locals'
		  ENDIF &&WEXIST('Locals')
		  IF WEXIST('Call Stack') THEN
		   RELEASE WINDOWS 'Call Stack')
		  ENDIF &&WEXIST('Call Stack'
		  IF WEXIST('Debug Output') THEN
		   RELEASE WINDOWS 'Debug Output'
		  ENDIF &&WEXIST('Debug Output')
		
		  DO CASE
		   CASE TYPE(dcApp)#T_Object
		   CASE PEMSTATUS(doApp,'gcPath_Proc',5) AND;
		     FILE(doApp.gcPath_Proc+doH.gcHelpFile)
		    SET HELP TO (doApp.gcPath_Proc+doH.gcHelpFile)
		    SET HELP ON
		   OTHERWISE
		    SET HELP OFF
		  ENDCASE
		 #ENDIF &&.F.
		
		 SET ALTERNATE OFF									&&Standard OFF
		 SET ALTERNATE TO
		
		 SET ASSERTS OFF									&&Standard OFF ACHTUNG! bei dlDebugMode in Set_Private überschrieben
		 SET BELL OFF										&&Standard ON
		 SET BELL TO	 									&&Standard keine Datei
		
		* SET BROWSEIME OFF									&&egal nur für DBCS
		
		* SET CLASSLIB TO
		
		 SET CLOCK STATUS									&&Standard STATUS
		* SET CLOCK TO 										&&unsinig bei STATUS
		
		 SET COMPATIBLE OFF									&&Standard OFF
		
		 SET CONSOLE OFF									&&Standard OFF
		
		 SET COVERAGE TO									&&Standard aus
		
		 SET CPDIALOG OFF									&&Standard OFF
		
		 SET CURSOR ON										&&Standard ON
		
		 SET DEFAULT TO										&&etwas besseres suchen?
		
		 SET DEVICE TO SCREEN								&&Standard Screen
		
		* SET DISPLAY TO 									&&Systemabhängig (und egal)
		
		 SET ESCAPE ON										&&Standard ON
		
		 SET EVENTLIST TO									&&Standard alle Events
		
		 SET EVENTTRACKING OFF								&&Standard OFF
		 SET EVENTTRACKING TO								&&Standard keine Datei
		
		* SET FDOW TO 1										&&Standard 1; aus SYSFORMATS Ländereinstellung von WINDOWS
		
		 SET FULLPATH ON									&&Standard nicht bezeichnet
		
		 SET FWEEK TO 1										&&Standard 1; aus SYSFORMATS Ländereinstellung von WINDOWS
		
		 SET HEADINGS ON									&&Standard ON
		
		 SET KEYCOMP TO WINDOWS								&&Standard nicht bezeichnet
		
		* SET PATH TO
		
		* SET LIBRARY TO			 							&&Standard keine Datei
		
		 SET MESSAGE TO ''
		
		 SET NOTIFY OFF										&&Standard ON
		
		 SET NULLDISPLAY TO 								&&Standard .NULL.
		
		 SET ODOMETER TO 100								&&Standard 100
		
		 SET OLEOBJECT ON									&&Standard ON
		
		 SET OPTIMIZE ON									&&Standard ON
		
		 SET PALETTE ON										&&Standard ON
		
		
		* SET PROCEDURE TO 									&&Standard kein Pfad
		
		 SET REFRESH TO 5,5									&&Standard 0,5
		
		 IF APPLICATION.STARTMODE=0 THEN
		  SET RESOURCE ON
		 ELSE &&APPLICATION.STARTMODE=0
		  SET RESOURCE OFF
		 ENDIF &&APPLICATION.STARTMODE=0
		
		 SET SPACE ON										&&Standard ON
		
		 SET STATUS OFF										&&Standard OFF
		
		 SET STATUS BAR ON									&&Standard OFF
		
		 SET STRICTDATE TO 1								&&Standard je nach dem
		
		 SET TYPEAHEAD TO 20								&&Standard 20
		
		 SET UDFPARMS TO VALUE								&&Standard VALUE
		
		 SET VIEW OFF
		
		* CD (.gcOldDir)
		
		* ON ERROR 											&&Standard kein Befehl
		
		* ON SHUTDOWN &lvTemp 								&&Standard kein Befehl
		
		* ON ESCAPE &lvTemp 								&&Standard kein Befehl
		
		* ON PAGE &lvTemp 									&&Standard kein Befehl
		
		 #IFNDEF dnVersion7_Prog
		  SET FUNCTION F5 TO CHR(245)
		
		  SET ENGINEBEHAVIOR 70								&&Standard 80
		  SET TABLEVALIDATE TO 3							&&Standard 3
		  IF _VFP.STARTMODE=4 THEN
		*nur wenn das Programm ohne DEBUG Möglichkeit läuft
		*also bei uns als EXE
		   SET NOTIFY CURSOR ON								&&Standard ON
		*   _SCREEN.THEMES = False							&&Standard True
		*    SYS(2700,0)										&&Standard 1 (XP Themes Enabled)
		  ENDIF &&_vfp.StartMode=4
		 #ENDIF &&dnVersion7_Prog
		
		*Falls wir auf dem Terminalserver sind:
		 lvTemp = VAL(OS(10))
		 IF BITAND(m.lvTemp,16+256)#0 THEN
		*Bitmap OFF
		*  SYS(602,0)
		 ENDIF &&BITAND(m.lvTemp,16+256)#0
		
		 ON KEY LABEL ALT+F10 *
		 SYS(2450,0)
		ENDWITH &&THIS
		
	ENDPROC

	PROCEDURE set_private		&& Setze Einstellungen, die für eine private DATASESSION gelten. Wird für jede Form mit privater Datasession durchgeführt.
		LOCAL;
		 lvTemp AS VARIANT
		
		WITH THIS
		*-- eigentlich Global, aber hier sinnvoller
		*off
		 #IF .F. THEN
		  DO CASE
		   CASE TYPE(dcApp)#T_Object
		   CASE SET('HELP')='OFF'
		   CASE TYPE('THISFORM')#T_Object
		   CASE !EMPTY(THISFORM.HELPCONTEXTID)
		   OTHERWISE
		    THISFORM.HELPCONTEXTID = 10
		  ENDCASE
		 #ENDIF &&.F.
		
		*damit es im Debugmode immer wieder angeht ...
		 SET ASSERTS ON 							&&Standard OFF
		
		*-- privater Teil
		 SET ANSI OFF								&&Standard OFF
		
		 SET AUTOSAVE OFF							&&Standard OFF
		
		 SET BLOCKSIZE TO 64						&&Standard 64
		
		 SET CARRY OFF								&&Standard OFF
		
		 SET COLLATE TO 'MACHINE'					&&Standard 'MACHINE'
		
		 SET CONFIRM ON								&&Standard ON
		
		* SET DATABASE TO							&&erledigt die Form selbstständig
		
		 SET DELETED ON								&&Standard OFF
		
		 SET EXACT OFF								&&Standard OFF
		
		 SET EXCLUSIVE OFF							&&Standard OFF
		
		 SET FIXED ON								&&Standard OFF
		
		 SET LOCK OFF								&&Standard OFF
		
		 SET MEMOWIDTH TO 8192						&&Standard 50
		
		 SET MULTILOCKS ON							&&Standard OFF
		
		 SET NEAR OFF								&&Standard OFF
		
		 SET NULL OFF								&&Standard OFF
		
		 SET REPROCESS TO -1						&&Standard 0
		 SET REPROCESS TO -1 SYSTEM					&&Standard 0
		
		 SET SAFETY OFF								&&Standard ON
		
		 SET TALK NOWINDOW							&&Standard NOWINDOW
		 SET TALK OFF								&&Standard ON
		
		 SET UNIQUE OFF								&&Standard OFF
		
		 #IFNDEF dnVersion7_Prog
		  SET AUTOINCERROR ON						&&Standard ON
		 #ENDIF &&dnVersion7_Prog
		
		 #IFNDEF dnVersion8_Prog THEN
		  SET TABLEPROMPT OFF						&&Standard ON (Prompt for Table)
		  SET VARCHARMAPPING OFF						&&Standard OFF
		 #ENDIF &&dnVersion8_Prog
		
		*Einstellungen die Länderspezifisch sind lesen
		 SET SYSFORMATS ON							&&Standard OFF
		*wenn sich die Systemeinstellungen ändern, Änderung ignorieren
		 SET SYSFORMATS OFF
		
		*Zwischen SET SYSFORMATS und den folgenden Einstellungen (bis zum Ende) gibt es Wechselwirkungen,
		*siehe Hilfe SET SYSFORMAT
		
		*Ab Hier Einstellbar?
		
		 SET CURRENCY LEFT							&&Standard LEFT
		* SET CURRENCY TO doH.gcCurrency 			&&STANDARD '$'
		
		* SET DECIMALS TO doH.gnDecimals				&&Standard 2
		
		* SET POINT TO 								&&Standard 		auf SYSFORMAT
		
		*Date von SYSFORMAT lösen (um Jahrtausend anzuzeigen)
		 lvTemp = SET('DATE',1)
		 DO CASE
		  CASE m.lvTemp=0
		   SET DATE MDY
		  CASE m.lvTemp=1
		   SET DATE DMY
		  CASE m.lvTemp=2
		   SET DATE YMD
		 ENDCASE
		
		*Zwischen SET DATE und den folgenden Einstellungen (bis zum Ende) gibt es Wechselwirkungen,
		*siehe Hilfe SET DATE
		 SET CENTURY ON								&&Standard ON
		*evtl später nocheinmal wegen TO und ROLLOVER nachdenken
		
		* SET HOURS TO 12							&&Standard 12	hier aber auf SYSFORMAT
		
		 SET SECONDS OFF							&&Standard ON
		
		 SET MARK TO '.'							&&Standard /
		
		
		ENDWITH &&THIS
		
	ENDPROC

	PROCEDURE store_		&& Speichert die Einstellungen der SET Befehle.
		LPARAMETERS;
		 tnSet
		
		IF PCOUNT()=0 OR VARTYPE(tnSet)#'N' THEN
		 tnSet = 2^0
		ENDIF &&PCOUNT()=0 OR VARTYPE(tnSet)#'N'
		
		*-- SET- und ON-Befehle einstellen
		WITH THIS
		 .rnSetting = .rnSetting+1
		
		 DIMENSION;
		  .raSettings(.rnSetting,4)
		
		 .raSettings(.rnSetting,1) = NIL
		 .raSettings(.rnSetting,2) = False
		 .raSettings(.rnSetting,3) = False
		 .raSettings(.rnSetting,4) = False
		
		* .goGlobal
		 #IFNDEF dnVersion7_Prog THEN
		  .raSettings(.rnSetting,1) = CREATEOBJECT('EMPTY')
		 #ELSE &&dnVersion7_Prog
		  .raSettings(.rnSetting,1) = CREATEOBJECT('RELATION')
		 #ENDIF &&dnVersion7_Prog
		
		 IF BITAND(m.tnSet,2^2)=2^2 THEN
		  PUSH MENU _MSYSMENU
		  .raSettings(.rnSetting,4) = True
		 ENDIF &&BITAND(m.tnSet,2^2)=2^2
		
		 IF BITAND(m.tnSet,2^0+2^1)>0 THEN
		*Privat auch speichern wenn global
		  .Store_Private(.raSettings(.rnSetting,1))
		  .raSettings(.rnSetting,2) = True
		 ENDIF &&BITAND(m.tnSet,2^0+2^1)>0
		 IF BITAND(m.tnSet,2^1)=2^1 THEN
		  .Store_Global(.raSettings(.rnSetting,1))
		  .raSettings(.rnSetting,3) = True
		 ENDIF &&BITAND(m.tnSet,2^1)=2^1
		
		 RETURN .rnSetting
		ENDWITH &&THIS
		
	ENDPROC

	PROCEDURE store_global		&& Speichert Einstellungen die für das ganze Programm, unabhängig von DATASESSION gelten. (Wird einmal für das Programm durchgeführt)
		LPARAMETERS;
		 toObject
		
		ADDPROPERTY(toObject,'gcOldAlternate'              ,SET("ALTERNATE")      )
		ADDPROPERTY(toObject,'gcOldAlternate_FName'        ,SET("ALTERNATE",1)    )
		ADDPROPERTY(toObject,'gcOldAsserts'                ,SET("ASSERTS")        )
		ADDPROPERTY(toObject,'gcOldBell'                   ,SET("BELL")           )
		ADDPROPERTY(toObject,'gcOldBell_FName'             ,SET("BELL",1)         )
		ADDPROPERTY(toObject,'gcOldBrowseIME'              ,SET("BROWSEIME")      )
		ADDPROPERTY(toObject,'gcOldClasslib'               ,SET("CLASSLIB")       )
		ADDPROPERTY(toObject,'gcOldClock'                  ,SET("CLOCK")          )
		ADDPROPERTY(toObject,'gcOldClock_Coord'            ,SET("CLOCK",1)        )
		ADDPROPERTY(toObject,'gcOldCompatible'             ,SET("COMPATIBLE")     )
		ADDPROPERTY(toObject,'gcOldCompatible_Prompt'      ,SET("COMPATIBLE",1)   )
		ADDPROPERTY(toObject,'gcOldConsole'                ,SET("CONSOLE")        )
		ADDPROPERTY(toObject,'gcOldCoverage'               ,SET("COVERAGE")       )
		ADDPROPERTY(toObject,'gcOldCpDialog'               ,SET("CPDIALOG")       )
		ADDPROPERTY(toObject,'gcOldCursor'                 ,SET("CURSOR")         )
		ADDPROPERTY(toObject,'gcOldDefault'                ,SYS(5)+SYS(2003)      )	&&besser als SET("DEFAULT")
		ADDPROPERTY(toObject,'gcOldDevice'                 ,SET("DEVICE")         )
		ADDPROPERTY(toObject,'gcOldDisplay'                ,SET("DISPLAY")        )
		ADDPROPERTY(toObject,'gcOldEscape'                 ,SET("ESCAPE")         )
		ADDPROPERTY(toObject,'gcOldEventList'              ,SET("EVENTLIST")      )
		ADDPROPERTY(toObject,'gcOldEventTracking'          ,SET("EVENTTRACKING")  )
		ADDPROPERTY(toObject,'gcOldEventTracking_FName'    ,SET("EVENTTRACKING",1))
		ADDPROPERTY(toObject,'gnOldFDoW'                   ,SET("FDOW")           )
		ADDPROPERTY(toObject,'gcOldFullPath'               ,SET("FULLPATH")       )
		ADDPROPERTY(toObject,'gnOldFWeek'                  ,SET("FWEEK")          )
		ADDPROPERTY(toObject,'gcOldHeadings'               ,SET("HEADINGS")       )
		ADDPROPERTY(toObject,'gcOldHelp'                   ,SET("HELP")           )
		ADDPROPERTY(toObject,'gcOldHelp_FName'             ,SET("HELP",1)         )
		ADDPROPERTY(toObject,'gcOldKeyComp'                ,SET("KEYCOMP")        )
		ADDPROPERTY(toObject,'gnOldLanguageOptions'        ,_VFP.LANGUAGEOPTIONS  )
		ADDPROPERTY(toObject,'gcOldLibrary'                ,SET("LIBRARY")        )
		ADDPROPERTY(toObject,'gnOldMousePointer'           ,_SCREEN.MOUSEPOINTER  )
		ADDPROPERTY(toObject,'gcOldNotify'                 ,SET("NOTIFY")         )
		ADDPROPERTY(toObject,'gcOldNullDisplay'            ,SET("NULLDISPLAY")    )
		ADDPROPERTY(toObject,'gnOldOdoMeter'               ,SET("ODOMETER")       )
		ADDPROPERTY(toObject,'gcOldOLEObject'              ,SET("OLEOBJECT")      )
		ADDPROPERTY(toObject,'gcOldOptimize'               ,SET("OPTIMIZE")       )
		ADDPROPERTY(toObject,'gcOldPalette'                ,SET("PALETTE")        )
		ADDPROPERTY(toObject,'gcOldPath'                   ,SET("PATH")           )
		ADDPROPERTY(toObject,'gcOldPrinter'                ,SET("PRINTER")        )
		ADDPROPERTY(toObject,'gcOldPrinter_PortName'       ,SET("PRINTER",1)      )
		ADDPROPERTY(toObject,'gcOldPrinter_WinDefa'        ,SET("PRINTER",2)      )
		*ADDPROPERTY(toObject,'gcOldPrinter_FoxDefa'        ,SET("PRINTER",3)      )
		ADDPROPERTY(toObject,'gcOldProcedure'              ,SET("PROCEDURE")      )
		ADDPROPERTY(toObject,'gnOldRefresh'                ,SET("REFRESH")        )
		ADDPROPERTY(toObject,'gnOldRefresh_Buffer'         ,SET("REFRESH",1)      )
		ADDPROPERTY(toObject,'gcOldResource'               ,SET("RESOURCE")       )
		ADDPROPERTY(toObject,'gcOldResource_FName'         ,SET("RESOURCE",1)     )
		ADDPROPERTY(toObject,'gcOldSpace'                  ,SET("SPACE")          )
		ADDPROPERTY(toObject,'gcOldStatus'                 ,SET("STATUS")         )
		ADDPROPERTY(toObject,'gcOldStatusBar'              ,SET("STATUS BAR")     )
		ADDPROPERTY(toObject,'gnOldStrictDate'             ,SET("STRICTDATE")     )
		ADDPROPERTY(toObject,'gnOldTypeAhead'              ,SET("TYPEAHEAD")      )
		ADDPROPERTY(toObject,'gcOldUDFParms'               ,SET("UDFPARMS")       )
		
		ADDPROPERTY(toObject,'gcOldDir'                    ,FULLPATH(CURDIR())    )
		
		ADDPROPERTY(toObject,'gcOldOnShutDown'             ,ON ("SHUTDOWN")       )
		ADDPROPERTY(toObject,'gcOldOnError'                ,ON ("ERROR")          )
		ADDPROPERTY(toObject,'gcOldOnEscape'               ,ON ("ESCAPE")         )
		ADDPROPERTY(toObject,'gcOldOnPage'                 ,ON ("PAGE")           )
		
		ADDPROPERTY(toObject,'gcOldScreenCaption'          ,_SCREEN.CAPTION       )
		ADDPROPERTY(toObject,'gcOldScreenIcon'             ,_SCREEN.ICON          )
		
		WITH toObject
		 IF .gcOldPoint=',' THEN
		  .gcOldClock_Coord = ;
		   STRTRAN(SUBSTR(.gcOldClock_Coord,1,AT(',',.gcOldClock_Coord,2)-1),',','.')+','+;
		   STRTRAN(SUBSTR(.gcOldClock_Coord,AT(',',.gcOldClock_Coord,2)+1),',','.')
		 ELSE &&.gcOldPoint=','
		  .gcOldClock_Coord = STRTRAN(.gcOldClock_Coord,.gcOldPoint,'.')
		 ENDIF &&.gcOldPoint=','
		ENDWITH &&toObject
		
		#IFNDEF dnVersion7_Prog
		 ADDPROPERTY(toObject,'gnOldEngineBehavior'        ,SET("EngineBehavior") )
		 ADDPROPERTY(toObject,'gnOldTableValidate'         ,SET("TableValidate")  )
		 ADDPROPERTY(toObject,'gcOldNotifyCursor'          ,SET("Notify",1)       )
		 ADDPROPERTY(toObject,'glOldThemes'                ,_SCREEN.THEMES        )
		#ENDIF &&dnVersion7_Prog
		
		#IFNDEF dnVersion8_Prog THEN
		 ADDPROPERTY(toObject,'gnOldReportBehavior'        ,SET("REPORTBEHAVIOR") )
		 ADDPROPERTY(toObject,'gnOldReportOutput'          ,_REPORTOUTPUT )
		 ADDPROPERTY(toObject,'gnOldReportPreview'         ,_REPORTPREVIEW)
		 ADDPROPERTY(toObject,'gnOldReportBuilder'         ,_REPORTBUILDER)
		#ENDIF &&dnVersion8_Prog
		
		ADDPROPERTY(toObject,'goLabel'                     ,CREATEOBJECT('EMPTY') )
		ADDPROPERTY(toObject.goLabel,'Alt_F10'             ,ON('Key','Alt+F10')   )
		
		ADDPROPERTY(toObject,'gnSys_0602'                  ,VAL(SYS(0602))        )
		ADDPROPERTY(toObject,'gnSys_2450'                  ,VAL(SYS(2450))        )
		ADDPROPERTY(toObject,'gnSys_2700'                  ,VAL(SYS(2700))        )
		
		*not for this project
		*THIS.Store_ToolBars(toObject)
		
	ENDPROC

	PROCEDURE store_private		&& Speichert Einstellungen die für eine private DATASESSION gelten. Wird für jede Form mit privater Datasession durchgeführt.
		LPARAMETERS;
		 toObject
		
		ADDPROPERTY(toObject,'gcOldAnsi'                   ,SET("ANSI")          )
		ADDPROPERTY(toObject,'gcOldAutoSave'               ,SET("AUTOSAVE")      )
		ADDPROPERTY(toObject,'gnOldBlockSize'              ,SET("BLOCKSIZE")     )
		ADDPROPERTY(toObject,'gcOldCarry'                  ,SET("CARRY")         )
		ADDPROPERTY(toObject,'gcOldCentury'                ,SET("CENTURY")       )
		ADDPROPERTY(toObject,'gnOldCentury_nCentury'       ,SET("CENTURY",1)     )
		ADDPROPERTY(toObject,'gnOldCentury_nRollOver'      ,SET("CENTURY",2)     )
		ADDPROPERTY(toObject,'gcOldCollate'                ,SET("COLLATE")       )
		ADDPROPERTY(toObject,'gcOldConfirm'                ,SET("CONFIRM")       )
		ADDPROPERTY(toObject,'gcOldCurrency'               ,SET("CURRENCY")      )
		ADDPROPERTY(toObject,'gcOldCurrency_Symbol'        ,SET("CURRENCY",1)    )
		ADDPROPERTY(toObject,'gcOldDatabase'               ,DBC()                )
		ADDPROPERTY(toObject,'gcOldDate'                   ,SET("DATE")          )
		ADDPROPERTY(toObject,'gnOldDateOrder'              ,SET("DATE",1)        )
		ADDPROPERTY(toObject,'gnOldDecimals'               ,SET("DECIMALS")      )
		ADDPROPERTY(toObject,'gcOldDeleted'                ,SET("DELETED")       )
		ADDPROPERTY(toObject,'gcOldExact'                  ,SET("EXACT")         )
		ADDPROPERTY(toObject,'gcOldExclusive'              ,SET("EXCLUSIVE")     )
		ADDPROPERTY(toObject,'gcOldFixed'                  ,SET("FIXED")         )
		ADDPROPERTY(toObject,'gnOldHours'                  ,SET("HOURS")         )
		ADDPROPERTY(toObject,'gcOldLock'                   ,SET("LOCK")          )
		ADDPROPERTY(toObject,'gcOldMark'                   ,SET("MARK")          )
		ADDPROPERTY(toObject,'gnOldMemoWidth'              ,SET("MEMOWIDTH")     )
		ADDPROPERTY(toObject,'gcOldMultiLocks'             ,SET("MULTILOCKS")    )
		ADDPROPERTY(toObject,'gcOldNear'                   ,SET("NEAR")          )
		ADDPROPERTY(toObject,'gcOldNull'                   ,SET("NULL")          )
		ADDPROPERTY(toObject,'gcOldPoint'                  ,SET("POINT")         )
		ADDPROPERTY(toObject,'gnOldReprocess'              ,SET("REPROCESS")     )
		#IFNDEF dnVersion8_Prog THEN
		 ADDPROPERTY(toObject,'gnOldReprocessMode'         ,SET("REPROCESS",2)   )
		 ADDPROPERTY(toObject,'gnOldReprocess_S'           ,SET("REPROCESS",1)   )
		 ADDPROPERTY(toObject,'gnOldReprocessMode_S'       ,SET("REPROCESS",3)   )
		#ENDIF &&dnVersion8_Prog
		ADDPROPERTY(toObject,'gcOldSafety'                 ,SET("SAFETY")        )
		ADDPROPERTY(toObject,'gcOldSeconds'                ,SET("SECONDS")       )
		ADDPROPERTY(toObject,'gcOldSysFormats'             ,SET("SYSFORMATS")    )
		ADDPROPERTY(toObject,'gcOldTalk'                   ,SET("TALK")          )
		ADDPROPERTY(toObject,'gcOldTalk_Window'            ,SET("TALK",1)        )
		ADDPROPERTY(toObject,'gcOldUnique'                 ,SET("UNIQUE")        )
		
		#IFNDEF dnVersion7_Prog THEN
		 ADDPROPERTY(toObject,'gcOldAutoIncError'          ,SET("AUTOINCERROR")  )
		#ENDIF &&dnVersion7_Prog
		
		#IFNDEF dnVersion8_Prog THEN
		 ADDPROPERTY(toObject,'gcOldTablePrompt'           ,SET("TABLEPROMPT")   )
		 ADDPROPERTY(toObject,'gcOldVarCharMapping'        ,SET("VARCHARMAPPING"))
		#ENDIF &&dnVersion8_Prog
		
	ENDPROC

	PROCEDURE store_toolbars		&& Speichert die sichtbarkeit der Standard-Toolbars und verbirgt diese.
		LPARAMETERS;
		 toObject
		
		*-- Gibt alle Visual FoxPro-Symbolleisten frei, bei alleinlaufender exe werden diese gelöscht.
		LOCAL ;
		 lnLoop AS INTEGER
		
		ADDPROPERTY(toObject,'gaToolBars(15,5)')
		
		WITH toObject
		 .gaToolBars( 1,1) = dcTB_COLORPALETTE_LOC
		 .gaToolBars( 1,2) = dcTB_COLORPALETTE_LOC_UK
		 .gaToolBars( 1,3) = [D]
		* .gaToolBars( 1,3) = [{DNARROW}]
		 .gaToolBars( 2,1) = dcTB_DATADESIGNER_LOC
		 .gaToolBars( 2,2) = dcTB_DATADESIGNER_LOC_UK4
		 .gaToolBars( 2,3) = [D]
		* .gaToolBars( 2,3) = [{DNARROW}]
		 .gaToolBars( 3,1) = dcTB_DEBUGGER_LOC
		 .gaToolBars( 3,2) = dcTB_DEBUGGER_LOC_UK
		 .gaToolBars( 3,3) = [F]
		*.gaToolBars( 3,3) = [{END}]
		 .gaToolBars( 4,1) = dcTB_FORMCONTROLS_LOC
		 .gaToolBars( 4,2) = dcTB_FORMCONTROLS_LOC_UK
		 .gaToolBars( 4,3) = [F]
		* .gaToolBars( 4,3) = [{UPARROW}]
		 .gaToolBars( 5,1) = dcTB_FORMDESIGNER_LOC
		 .gaToolBars( 5,2) = dcTB_FORMDESIGNER_LOC_UK
		 .gaToolBars( 5,3) = [L]
		* .gaToolBars( 5,3) = [{UPARROW}]
		 .gaToolBars( 6,1) = dcTB_LAYOUT_LOC
		 .gaToolBars( 6,2) = dcTB_LAYOUT_LOC_UK
		 .gaToolBars( 6,3) = [P]
		* .gaToolBars( 6,3) = [{UPARROW}]
		 .gaToolBars( 7,1) = dcTB_PRINTPREVIEW_LOC
		 .gaToolBars( 7,2) = dcTB_PRINTPREVIEW_LOC_UK
		 .gaToolBars( 7,3) = [Q]
		* .gaToolBars( 7,3) = [{UPARROW}]
		 .gaToolBars( 8,1) = dcTB_QUERY_LOC
		 .gaToolBars( 8,2) = dcTB_QUERY_LOC_UK
		 .gaToolBars( 8,3) = [R]
		* .gaToolBars( 8,3) = [{UPARROW}]
		 .gaToolBars( 9,1) = dcTB_REPOCONTROLS_LOC
		 .gaToolBars( 9,2) = dcTB_REPOCONTROLS_LOC_UK
		 .gaToolBars( 9,3) = [R]
		* .gaToolBars( 9,3) = [{UPARROW}]
		 .gaToolBars(10,2) = dcTB_REPODESIGNER_LOC_UK
		 .gaToolBars(10,1) = dcTB_REPODESIGNER_LOC
		 .gaToolBars(10,3) = [S]
		* .gaToolBars(10,3) = [{UPARROW}]
		 .gaToolBars(11,1) = dcTB_STANDARD_LOC
		 .gaToolBars(11,2) = dcTB_STANDARD_LOC_UK
		 .gaToolBars(11,3) = [V]
		* .gaToolBars( 1,3) = [{UPARROW}]
		 .gaToolBars(12,1) = dcTB_VIEWDESIGNER_LOC
		 .gaToolBars(12,2) = dcTB_VIEWDESIGNER_LOC_UK
		 .gaToolBars(12,3) = []
		* .gaToolBars(12,3) = [{UPARROW}]
		
		 .gaToolBars(13,1) = dcWIN_COMMAND_LOC
		 .gaToolBars(13,2) = dcWIN_COMMAND_LOC
		 .gaToolBars(14,1) = dcWIN_Properties_LOC
		 .gaToolBars(14,2) = dcWIN_Properties_LOC
		 .gaToolBars(15,1) = dcWIN_Document_LOC
		 .gaToolBars(15,2) = dcWIN_Document_LOC
		
		 FOR lnLoop = 1 TO ALEN(.gaToolBars, 1)
		  IF WEXIST(.gaToolBars(lnLoop,2)) THEN
		   .gaToolBars(lnLoop,1) = .gaToolBars(lnLoop,2)
		  ENDIF &&WEXIST(.gaToolBars(lnLoop,2))
		
		  .gaToolBars(lnLoop,4) = WEXIST(.gaToolBars(lnLoop,1))
		  .gaToolBars(lnLoop,5) = WVISIBLE(.gaToolBars(lnLoop,1))
		
		  DO CASE
		   CASE !.gaToolBars(lnLoop,4)
		   CASE APPLICATION.STARTMODE#0
		    RELEASE WINDOW (.gaToolBars(lnLoop,1))
		    .gaToolBars(lnLoop,4) = False
		   CASE INLIST(.gaToolBars(lnLoop,1),dcTB_STANDARD_LOC_UK,dcTB_DEBUGGER_LOC_UK)
		   CASE INLIST(lnLoop,13,14,15)
		    HIDE WINDOW (.gaToolBars(lnLoop,1))
		   OTHERWISE
		    HIDE WINDOWS (.gaToolBars(lnLoop,2))
		    *bis das wiederherstellen funktioniert:
		 *  RELEASE WINDOWS (.gaToolBars(lnLoop,2))
		  ENDCASE
		 ENDFOR &&lnLoop
		ENDWITH &&toObject
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cusstorage AS custom 		&& The stuff that does the work.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\stuff.h"
	*<DefinedPropArrayMethod>
		*m: check_scx		&& Checks a given scx file for changes.
		*m: check_vcx		&& Checks a given vcx file for changes.
		*m: convert		&& Convert complete set, not partial.
		*m: filestoprocess		&& Test if files are changed since last run.
		*m: get_converter		&& Create FoxBin2PRG object.
		*m: get_dbc_tables		&& Return the tables of DBCs processed.
		*m: get_md5
		*m: oget_setting		&& Returns a settings object of a given path with config from FoxBin2PRG.
		*m: process_bin2txt		&& Process all files of a given array to text files.
		*m: process_bin2txt_dir		&& Process all directories of a given array to text. Storage not used.
		*m: process_txt2bin		&& Process all files of a given array to binary files.
		*m: process_txt2bin_dir		&& Process all directories of a given array to binary. Storage not used.
		*m: storage_check		&& Check for valid  storage settings, alter settings
		*m: storage_check_bin2prg		&& Check location of FoxBin2Prg.
		*m: storage_close		&& Close the storage file.
		*m: storage_get		&& Get settings information out of storage
		*m: storage_location		&& Get location for storage file.
		*m: storage_open		&& Opens the storage file.
		*m: storage_set		&& Set settings information to storage.
		*m: sync_file		&& Test change of checksum (crc32) for a given file (pair) against the storage table.
		*m: sync_objects		&& Compares a help cursor with the storage table. Compares objects of a vcx / scx.
	*</DefinedPropArrayMethod>

	*<PropValue>
		Name = "cusstorage"
	*</PropValue>
	
	PROCEDURE check_scx		&& Checks a given scx file for changes.
		LPARAMETERS;
		 tcFile,;
		 tcPath,;
		 tlText2Bin,;
		 tcStorage,;
		 toSett
		
		*!*	<pdm>
		*!*	<descr>Checks a given scx file for changes.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Full qualified file to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Path of the operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSett" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail>Object with folder settings of FoxBin2PRG.</detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="1" /> is changed.</retval>
		*!*	<remarks>
		*<p>This will test checksum first.</p>
		*<p>If checksum is changed check SCX for timestamp change.</p>
		*<p>A object is a record in the scx with <expr>PLATFORM=="WINDOWS" AND LEN(PARENT)=0</expr>.
		* basically dataenvironment and form.</p>
		*<p>FoxBin2PRG separates them, for whatever reason, so I keep track.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 10.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnStep      AS INTEGER,;
		 llDirty     AS BOOLEAN,;
		 llOk        AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llDirty = .F.
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE m.lnStep=1   &&test for changes on file (checksum)
		*llOk - nothing changed on file
		   llOk = !THIS.Sync_File('K',m.tcFile,m.tlText2Bin,m.tcStorage)
		*/  &&m.lnStep=1  &&test for changes on file (checksum)
		
		  CASE m.lnStep=2 AND toSett.n_UseClassPerFile=0    &&Do not split classlib into classlib.class.vc2
		*Sync_File was dirty,
		*this could be one out of two problems
		*-file is not to be deleted (8,9) - we are not dirty
		   SELECT;
		    Cur1.iDirty;
		    FROM (m.tcStorage) AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType=='K';
		    AND Cur1.iDirty IN (8,9)
		*-if not found we are dirty
		   llDirty = RECCOUNT('curHelp')=0
		
		   USE IN curHelp
		* and done
		   llOk = .T.
		*/  &&m.lnStep=2 AND toSett.n_UseClassPerFile=0   &&Do not split classlib into classlib.class.vc2
		
		  CASE m.lnStep=2
		*just loop
		
		  CASE m.lnStep=3  &&Test access
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS scx IN SELECT('scx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=3 &&Test  access
		
		  CASE m.lnStep=4    &&Test if VCX is usable
		*okä, now test this thing
		   SELECT;
		    Cur1.UniqueID,;
		    COUNT(*) AS nCount;
		    FROM scx AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0;
		    GROUP BY 1 HAVING nCount>1
		
		*/  &&m.lnStep=4   &&Test if SCX is usable
		
		  CASE m.lnStep=5 AND RECCOUNT()>0
		*UniqueID not so unique
		*rebuild, delete from Storage
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx') EXCLUSIVE
		
		     SELECT vcx
		     REPLACE;
		      UniqueID WITH SYS(2015);
		      FOR PLATFORM='WINDOWS'
		
		     USE (m.tcFile) ALIAS scx IN SELECT('scx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=5 &&Test if SCX is usable
		
		  CASE m.lnStep=5
		*just loop
		
		  CASE m.lnStep=6  &&test for changes on classes
		*(only if checksum is changed)
		
		*!*	Changed by SF 27.2.2023
		*!*	<pdm>
		*!*	<change date="{^2023-02-27,14:58:00}">Changed by SF<br />
		*!*	Problem with SCX just modified. Issue #4<br/>
		*!* Just use LOWERCASE
		*!*	</change>
		*!*	</pdm>
		
		*so now let's see if something is changed
		*get vcx data
		   SELECT;
		    CAST(LOWER(Cur1.ObjName) AS c(240))  AS cObjName,;
		    Cur1.UniqueID+BINTOC(Cur1.TIMESTAMP) AS cUniqueId;
		    FROM scx AS Cur1;
		    INTO CURSOR curSCX;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0
		
		*!*	/Changed by SF 27.2.2023
		
		   INDEX ON cObjName  TAG _cObj
		   INDEX ON cUniqueId TAG _cUni
		
		   llDirty = THIS.Sync_Objects('k',m.tcFile,m.tlText2Bin,'curSCX',m.tcStorage)
		
		*/   &&m.lnStep=2 &&test for changes on classes
		
		  OTHERWISE && end loop
		   EXIT
		 ENDCASE
		
		 IF m.llDirty OR m.llOk THEN 
		  EXIT
		 ELSE  &&m.llDirty
		  lnStep = m.lnStep+1
		 ENDIF &&m.llDirty OR m.llOk
		
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		USE IN SELECT('scx')
		USE IN SELECT('curSCX')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty
		
		
	ENDPROC

	PROCEDURE check_vcx		&& Checks a given vcx file for changes.
		LPARAMETERS;
		 tcFile,;
		 tcPath,;
		 tlText2Bin,;
		 tcStorage,;
		 toSett
		
		*!*	<pdm>
		*!*	<descr>Checks a given vcx file for changes.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Full qualified file to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Path of the operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSett" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail>Object with folder settings of FoxBin2PRG.</detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="1" /> is changed.</retval>
		*!*	<remarks>
		*<p>This will test checksum first.</p>
		*<p>If checksum is changed and multi class processing it will check single classes for change.</p>
		*<p>This will parse out any class in a given vcx.
		*It checks for uniquenes of the UniqueID field of the vcx.
		*If this is not unique it will first make it unique.</p>
		*<p>A class is a record in the vcx with <expr>PLATFORM=="WINDOWS" AND LEN(PARENT)=0</expr> .</p>
		*<p>It will store information about the classes, not the classlib.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 10.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnStep      AS INTEGER,;
		 llDirty     AS BOOLEAN,;
		 llOk        AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llDirty = .F.
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE m.lnStep=1   &&test for changes on file (checksum)
		*llOk - nothing changed on file (we do not need to lookup classes too)
		   llOk = !THIS.Sync_File('V',m.tcFile,m.tlText2Bin,m.tcStorage)
		*/  &&m.lnStep=1  &&test for changes on file (checksum)
		
		  CASE m.lnStep=2 AND toSett.n_UseClassPerFile=0    &&Do not split classlib into classlib[.baseclass].class.vc2
		*Sync_File was dirty, we are dirty and done
		*Sync_File was dirty,
		*this could be one out of two problems
		*-file is not to be deleted (8,9) - we are not dirty
		   SELECT;
		    Cur1.iDirty;
		    FROM (m.tcStorage) AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType=='V';
		    AND Cur1.iDirty IN (8,9)
		*-if not found we are dirty
		   llDirty = RECCOUNT('curHelp')=0
		
		   USE IN curHelp
		* and done
		   llOk = .T.
		*/  &&m.lnStep=2 AND toSett.n_UseClassPerFile=0  &&Do not split into classlib[.baseclass].class.vc2
		
		  CASE m.lnStep=2
		*just loop
		
		  CASE m.lnStep=3  &&Test access
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=3 &&Test  access
		
		  CASE m.lnStep=4    &&Test if VCX is usable
		*okä, now test this thing
		   SELECT;
		    Cur1.UniqueID,;
		    COUNT(*) AS nCount;
		    FROM vcx AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0;
		    GROUP BY 1 HAVING nCount>1
		
		*/  &&m.lnStep=4   &&Test if VCX is usable
		
		  CASE m.lnStep=5 AND RECCOUNT()>0
		*UniqueID not so unique
		*rebuild, delete from Storage
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx') EXCLUSIVE
		
		     SELECT vcx
		     REPLACE;
		      UniqueID WITH SYS(2015);
		      FOR PLATFORM='WINDOWS'
		
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=5 &&Test if VCX is usable
		
		  CASE m.lnStep=5
		*just loop
		
		  CASE m.lnStep=6  &&test for changes on classes
		*(only if checksum is changed)
		
		*!*	Changed by SF 27.2.2023
		*!*	<pdm>
		*!*	<change date="{^2023-02-27,14:58:00}">Changed by SF<br />
		*!*	Problem with SCX just modified. Issue #4<br/>
		*!* Just use LOWERCASE<br/>
		*!*	we do VCX in case of
		*!*	</change>
		*!*	</pdm>
		
		*so now let's see if something is changed
		*get vcx data
		   SELECT;
		    CAST(LOWER(Cur1.ObjName) AS c(240))  AS cObjName,;
		    Cur1.UniqueID+BINTOC(Cur1.TIMESTAMP) AS cUniqueId;
		    FROM vcx AS Cur1;
		    INTO CURSOR curVCX;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0
		*!*	/Changed by SF 27.2.2023
		
		   INDEX ON cObjName  TAG _cObj
		   INDEX ON cUniqueId TAG _cUni
		
		   llDirty = THIS.Sync_Objects('v',m.tcFile,m.tlText2Bin,'curVCX',m.tcStorage)
		
		*/   &&m.lnStep=6 &&test for changes on classes
		
		  OTHERWISE && end loop
		   EXIT
		 ENDCASE
		
		 IF m.llDirty OR m.llOk THEN
		  EXIT
		 ELSE  &&m.llDirty
		  lnStep = m.lnStep+1
		 ENDIF &&m.llDirty OR m.llOk
		
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		USE IN SELECT('vcx')
		USE IN SELECT('curVCX')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty
		
		
	ENDPROC

	PROCEDURE convert		&& Convert complete set, not partial.
		LPARAMETERS;
		 taFiles,;
		 tlProcess,;
		 toConverter,;
		 tnOffset,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<descr>Converts a preprocessed bunch of files with FoxBin2Prg.Execute</descr>
		*!*	<params name="taFiles" type="Array" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*!*	<p>A Three column array.</p>
		*!*	<dl>
		*!*	 <dt>Column one</dt><dd>File to process.</dd>
		*!*	 <dt>Column two</dt><dd>Second parameter of FoxBin2PRG's Execute</dd>
		*!*	 <dt>Column three</dt><dd>Include file of colum 1 in output to screen</dd>
		*!*	</dl>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlProcess" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Value for FoxBin2PRG's l_ProcessFiles.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<params name="tnOffset" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Offset for progress bar.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">Operation successfully ended.</retval>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 18.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,13:00:00}">Changed by: SF<br />
		*!*	Modified to deal with single classes of libraries.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-28,12:00:00}">Changed by: SF<br />
		*!*	Modified to deal ::(import|export)
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2021-03-02,10:46:00}">Changed by: SF<br />
		*!*	Added functionality to display selected files only, and state of (pre) processing
		*!*	</change>
		*!*	</pdm>
		
		LOCAL;
		 lcFile_Test AS STRING
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile      AS CHARACTER,;
		 lnFile      AS NUMBER,;
		 lnFiles     AS NUMBER,;
		 llOk        AS BOOLEAN
		
		lnFiles	= ALEN(m.taFiles,1)
		llOk	= True
		
		toConverter.l_AutoClearProcessedFiles = .T.
		
		FOR lnFile = 1 TO m.lnFiles
		 ACTIVATE SCREEN
		
		 lcFile		 = m.taFiles(m.lnFile,1)
		 lcFile_Test = m.lcFile
		 IF '::'$m.lcFile_Test THEN
		  lcFile_Test = FORCEEXT(STRTRAN(m.lcFile_Test,'::','.',1,1),'')
		 ENDIF &&'::'$m.lcFile_Test
		
		 DO CASE
		  CASE !FILE(m.lcFile_Test) AND !DIRECTORY(m.lcFile_Test)
		   ?JUSTFNAME(m.lcFile)+" - not found"
		   LOOP
		  CASE m.taFiles(m.lnFile,3)
		   ?JUSTFNAME(m.lcFile)
		 ENDCASE
		
		 toConverter.l_ProcessFiles = .T.
		 m.toConverter.UpdateProgressbar('',m.lnFile+m.tnOffset,m.lnFiles+m.tnOffset+1,0)
		 toConverter.l_ProcessFiles				  = m.tlProcess
		 toConverter.l_ClassPerFileCheck		  = .F.
		 toConverter.l_RedirectClassPerFileToMain = .T.
		 toFB2T_Setting = IIF(VARTYPE(toFB2T_Setting)='O' AND !ISNULL(toFB2T_Setting),toFB2T_Setting,_SCREEN.gcB2T_Config)
		
		*!*	obj.execute(cInputFile [,cType [,cTextName [,lGenText [,cDontShowErrors [,cDebug;
		*!*	 [,cDontShowProgress [,oModule [,oEx [,lRelanzarError [,cOriginalFileName;
		*!*	 [,cRecompile [,cNoTimestamps [,cBackupLevels [,cClearUniqueID [,cOptimizeByFilestamp [,cCFG_File]]]]]]]]]]]]]]])
		* IF m.toConverter.Execute(m.lcFile,m.taFiles(m.lnFile,2),"0","0","0","1","1",,,,,,,,,,)#0 THEN
		 IF m.toConverter.Execute(m.lcFile,m.taFiles(m.lnFile,2),"0","0","0",_SCREEN.gcB2T_Log,"1",,,,,,,,,,m.toFB2T_Setting)#0 THEN
		  EXIT
		 ENDIF &&toConverter.Execute(m.lcFile,taFiles(m.lnFile,2),"0","0","0","0","1", ,,,,,,,,,m.toFB2T_Setting)#0
		
		 toConverter.l_AutoClearProcessedFiles = .F.
		ENDFOR &&lnFile
		
		RETURN m.llOk
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS;
		 tnError,;
		 tcMethod,;
		 tnLine
		
		LOCAL ARRAY;
		 laError(1,7)
		
		AERROR(laError)
		MESSAGEBOX('Ooops, works not as expected.'+0h0d0a0d0a+;
		'Error:'+PADL(m.tnError,5)+', '+MESSAGE()+0h0d0a+;
		 'Code block: '+THIS.CLASS+'.'+m.tcMethod+0h0d0a+;
		 'Code line: '+PADL(m.tnLine,7),;
		 64,'Bin2Text v'+dcB2T_Verno)
		DEBUG
		SUSPEND
		RETRY
		CANCEL
		
		*!*	<pdm>
		*!*	<descr>Just a bit more then just let it crash.</descr>
		*!*	<params name="tnError" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcMethod" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tnLine" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
	ENDPROC

	PROCEDURE filestoprocess		&& Test if files are changed since last run.
		LPARAMETERS;
		 taFiles,;
		 tcPath,;
		 tlText2Bin,;
		 tlCheckAll,;
		 tcStorage,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Test if files are changed since last run.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*<p>The output of FoxBin2Prg <b>Get_Processed</b> method.</p>
		*<p>After return the Array will hold files to be processed.</p>
		*</detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source path of the Operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*<p>Checks if all files listed in <pdmpara num="5" /> are used in <pdmpara num="1" />.</p>
		*<p>If a file is not found, text file corresponding will be deleted.</p>
		*<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">Notes if the array need to be processed.</retval>
		*!*	<remarks>
		*<p>Parses <pdmpara num="1" /> for binaries that can be checked for changed. For now this will be scx and vcx files.</p>
		*<p>The actual state will be stored in a file <b>Bin2Txt.DBF</b> in <pdmpara num="2" /> path.</p>
		*<p>This file will hold information about any object of a vcx and information about scx.</p>
		*<p>The function will not handle any <b>source</b> file not found in the Array.</p>
		*<p>It is possible to delete splitted classes text file if the class is removed from an scx /vcx.</p>
		*<p>If <pdmpara num="4" /> is true, text files for binary files removed might be deleted too.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 5.6.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" />
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile    AS CHARACTER,;
		 lnLine    AS NUMBER,;
		 lnLines   AS NUMBER,;
		 lnInPut   AS NUMBER,;
		 lnDirty   AS NUMBER,;
		 llDirty   AS BOOLEAN,;
		 loSett    AS OBJECT
		
		STORE ALEN(taFiles,1) TO;
		 lnLines,;
		 lnInPut
		
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:31:00}">Changed by: SF<br />
		*!*	Handle deletion of obsolete text files for binaries.
		*!*	</change>
		*!*	</pdm>
		
		 IF m.tlCheckAll THEN
		*we clean up now, because of post-processing
		*we clean up deleted now, because of post-processing
		 DELETE Cur1;
		  FROM (m.tcStorage) AS Cur1;
		  WHERE Cur1.iDirty=-2
		
		*check obsolete files
		 UPDATE Cur1 SET;
		  iDirty   = -1,;
		  tLastUse = DATETIME();
		  FROM (m.tcStorage) AS Cur1;
		  WHERE !EMPTY(Cur1.cFile);
		  AND Cur1.cType IN ('V','v','R','M','d','D','P','B','K','k','f','m')
		ENDIF &&m.tlCheckAll
		*!*	/Changed by: SF 4.6.2015
		
		lnDirty = 0
		FOR lnLine = lnLines TO 1 STEP -1
		 lcFile  = taFiles(m.lnLine,1)
		 llDirty = .F.
		 DO CASE
		  CASE !TRIM(taFiles(m.lnLine,2))=="O" AND  m.tlText2Bin
		*ToBin, we process only output (binaries only)
		   lnInPut = m.lnInPut-1
		  CASE !TRIM(taFiles(m.lnLine,2))=="I" AND !m.tlText2Bin
		*ToText, we process only input
		   lnInPut = m.lnInPut-1
		  CASE !TRIM(taFiles(m.lnLine,3))=="P1"
		*File must be processed
		   lnInPut = m.lnInPut-1
		  CASE !TRIM(taFiles(m.lnLine,6))=="X0"
		*file must be main file, no split file
		   lnInPut = m.lnInPut-1
		  CASE UPPER(JUSTEXT(m.lcFile))=="VCX"
		   loSett  = THIS.OGet_Setting(JUSTPATH(m.lcFile),m.toConverter)
		   llDirty = THIS.Check_VCX(UPPER(m.lcFile),tcPath,m.tlText2Bin,m.tcStorage,m.loSett)
		  CASE UPPER(JUSTEXT(m.lcFile))=="FRX"
		   llDirty = THIS.Sync_File('R',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="MNX"
		   llDirty = THIS.Sync_File('M',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="DBF"
		   llDirty = THIS.Sync_File('D',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		*   llDirty = THIS.Sync_File('d',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="DBC"
		   llDirty = THIS.Sync_File('d',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		*   llDirty = THIS.Sync_File('D',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="PJX"
		   llDirty = THIS.Sync_File('P',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="LBX"
		   llDirty = THIS.Sync_File('B',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="SCX"
		   loSett  = THIS.OGet_Setting(JUSTPATH(m.lcFile),m.toConverter)
		   llDirty = THIS.Check_SCX(UPPER(m.lcFile),tcPath,m.tlText2Bin,m.tcStorage,m.loSett)
		
		  CASE UPPER(JUSTEXT(m.lcFile))=="MEM"
		   llDirty = THIS.Sync_File('m',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="FKY"
		   llDirty = THIS.Sync_File('f',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  OTHERWISE
		   llDirty = .T.
		 ENDCASE
		 IF m.llDirty THEN
		  lnDirty = m.lnDirty+1
		 ELSE  &&m.llDirty
		  ADEL(taFiles,MAX(m.lnLine,1))
		 ENDIF &&m.llDirty
		ENDFOR &&m.lnLine
		
		DIMENSION;
		 taFiles(MAX(m.lnDirty,1),ALEN(taFiles,2))
		
		IF m.lnDirty<1 THEN
		 taFiles = ''
		ENDIF &&m.lnDirty<1
		
		RETURN IIF(m.lnDirty=m.lnInPut,NIL,m.lnDirty>0)
		
	ENDPROC

	PROCEDURE get_converter		&& Create FoxBin2PRG object.
		LPARAMETERS;
		 tcStorage,;
		 toConverter,;
		 tlCloseTable
		
		*!*	<pdm>
		*!*	<descr>Create converter object and open storage table</descr>
		*!*	<params name="tcStorage" type="Character" byref="1" dir="Out" inb="0" outb="0">
		*!*	<short>Alias of storage table.</short>
		*!*	<detail><expr>.NULL.</expr> if not found or closed by <pdmpara num="3" />. </detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Character" byref="1" dir="Out" inb="0" outb="0">
		*!*	<short>Instance of FoxBin2PRG.</short>
		*!*	<detail><expr>.NULL.</expr> id not instantiated. </detail>
		*!*	</params>
		*!*	<params name="tlCloseTable" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Do not keep storage table open.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Error</retval>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnResult AS NUMBER,;
		 llOk     AS BOOLEAN
		
		llOk = True
		IF PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path) THEN
		 tcStorage = THIS.Storage_Open(_SCREEN.gcB2T_Path)
		
		ELSE  &&PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		 tcStorage = THIS.Storage_Check(False)
		
		ENDIF &&PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		
		IF ISNULL(m.tcStorage) THEN
		 llOk = False
		ENDIF &&ISNULL(m.tcStorage)
		
		IF m.llOk THEN
		 toConverter = NEWOBJECT("c_foxbin2prg",_SCREEN.gcB2T_FB2T)
		 IF !VARTYPE(m.toConverter)="O" OR ISNULL(m.toConverter) THEN
		  toConverter = NIL
		  llOk		  = False
		 ENDIF &&!TYPE(toConverter)="O" OR ISNULL(m.toConverter)
		ELSE  &&m.llOk
		 toConverter = NIL
		ENDIF &&m.llOk
		
		IF m.llOk THEN
		 lnResult = Compare_Verno(dcFB2P_Verno_Min,m.toConverter.c_FB2PRG_VERSION_REAL)
		
		 DO CASE
		
		  CASE m.lnResult=1
		*FoxBin2Prg
		*update added here ....
		   ?"Wrong version of FoxBin2Prg, min Version: "+dcFB2P_Verno_Min
		   toConverter = NIL
		   llOk		   = False
		
		  OTHERWISE
		* m.lnResult In 0, 12
		*version fit, do nothing
		
		 ENDCASE
		ENDIF &&m.llOk
		
		IF (!m.llOk OR m.tlCloseTable) AND !ISNULL(m.tcStorage) THEN
		 THIS.Storage_Close(m.tcStorage,True)
		 tcStorage = NIL
		ENDIF &&(!m.llOk OR tlCloseTable) AND !ISNULL(m.tcStorage)
		
		llOk = !m.llOk
		
		RETURN m.llOk
		
	ENDPROC

	PROCEDURE get_dbc_tables		&& Return the tables of DBCs processed.
		LPARAMETERS;
		 taSource,;
		 taSearched,;
		 taReturn,;
		 tnOffset,;
		 tcMode,;
		 tlText2Bin,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Resolve tables of databases.</descr>
		*!*	<params name="taSource" type="Array" byref="1" dir="In" inb="0" outb="0">
		*!*	<short>Source array.</short>
		*!*	<detail>Array what is parsed for Databases. The databases found in column 1 where searched for tables.</detail>
		*!*	</params>
		*!*	<params name="taSearched" type="Array" byref="1" dir="In" inb="0" outb="0">
		*!*	<short>Array with tables.</short>
		*!*	<detail>This array is checked for tables found in the databases.
		*!*	If an entry is found in column 1, the table will not be added to <pdmpara num="3" />.</detail>
		*!*	</params>
		*!*	<params name="taReturn" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<shortArray that will hold tables found.</short>
		*!*	<detail>Tables will be added to the array.<p/>
		*!*	Table structure is the one of parameter taFiles of <see pem="Convert" /></detail>
		*!*	</params>
		*!*	<params name="tnOffset" type="Numeric" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>The last valid record in <pdmpara num="3" /></short>
		*!*	<detail>tables will be appended after this row. The array will be resized to it's lenght. Will hold total row number at return.</detail>
		*!*	</params>
		*!*	<params name="tcMode" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>FoxBin2PRG's mode switch.</short>
		*!*	<detail>
		*!*	"PRG2BIN","BIN2PRG" for the use of FoxBin2Prg.
		*</detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="In" inb="0" outb="0">
		*!*	<short>Direction of operation,</short>
		*!*	<detail>To determin file extension.</detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="In" inb="0" outb="0">
		*!*	<short>FoxBin2Prg object.</short>
		*!*	<detail>To get settings.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">At least one table is added to <pdmpara num="3" /></retval>
		*!*	<remarks></remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 3.3.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		 
		EXTERNAL ARRAY;
		 taSource,;
		 taSearched,;
		 taReturn
		
		LOCAL;
		 lcFile       AS STRING,;
		 lcTable      AS STRING,;
		 lcDataBase   AS STRING,;
		 lcExt        AS STRING,;
		 lcExt1       AS STRING,;
		 lnDBCFound   AS NUMBER,;
		 lnFile       AS NUMBER,;
		 lnFiles      AS NUMBER,;
		 lnTable      AS NUMBER,;
		 lnTableFound AS NUMBER,;
		 lnTables     AS NUMBER,;
		 lnCols       AS NUMBER,;
		 llReturn     AS BOOLEAN,;
		 loSett       AS OBJECT
		
		LOCAL ARRAY;
		 laDatabases(1,4),;
		 laTables(1)
		
		lnFiles	= ALEN(m.taSource,1)
		lnCols	= ALEN(m.taReturn,2)
		
		laDatabases = ""
		= ADATABASES(laDatabases)
		
		FOR lnFile = 1 TO m.lnFiles
		 lcFile	= m.taSource(m.lnFile,1)
		 lcExt	= 'DBC'
		 loSett	= THIS.oGet_Setting(JUSTPATH(m.lcFile),m.toConverter)
		 lcExt1	= UPPER(m.loSett.c_DC2)
		
		 IF UPPER(JUSTEXT(m.lcFile))==m.lcExt OR UPPER(JUSTEXT(m.lcFile))==m.lcExt1 THEN
		* simply add the tables up to us in the array, if missing they will be removed in the next loops
		  lcFile	 = FORCEEXT(m.lcFile,'DBC')
		  lnDBCFound = ASCAN(m.laDatabases,m.lcFile,1,-1,2,15)
		  lcDataBase = DBC()
		
		  IF EMPTY(m.lnDBCFound) THEN
		   OPEN DATABASE (m.lcFile) SHARED NOUPDATE
		  ELSE  &&EMPTY(m.lnDBCFound)
		   SET DATABASE TO (m.lcFile)
		  ENDIF &&EMPTY(m.lnDBCFound)
		
		  lnTables = ADBOBJECTS(m.laTables,"TABLE")
		  llReturn = m.llReturn OR m.lnTables>0
		
		  FOR lnTable = 1 TO m.lnTables
		   lcTable		= FORCEEXT(FULLPATH(m.laTables(m.lnTable),m.lcFile),'DBF')
		   lnTableFound	= ASCAN(m.taSearched,m.lcTable,1,-1,2,15)
		   IF EMPTY(m.lnTableFound) THEN
		    tnOffset   = m.tnOffset+1
		    DIMENSION;
		     m.taReturn(m.tnOffset,m.lnCols)
		
		    IF m.tlText2Bin THEN
		     loSett	 = THIS.oGet_Setting(JUSTPATH(m.lcTable),m.toConverter)
		     lcTable = FORCEEXT(m.lcTable,m.loSett.c_DB2)
		    ENDIF &&m.tlText2Bin
		
		    taReturn(m.tnOffset,1) = m.lcTable
		    taReturn(m.tnOffset,2) = m.tcMode
		    IF m.lnCols>2 THEN
		     taReturn(m.tnOffset,3)	= m.lcTable
		     taReturn(m.tnOffset,4)	= 0											&&no Hook
		    ENDIF &&m.lnCols>2
		   ENDIF &&EMPTY(m.lnTableFound)
		
		  ENDFOR &&lnTable
		
		  IF EMPTY(m.lnDBCFound) THEN
		   CLOSE DATABASES
		  ENDIF &&EMPTY(m.lnDBCFound)
		  SET DATABASE TO (m.lcDataBase)
		* add tables of the DBC
		
		 ENDIF &&UPPER(JUSTEXT(m.lcFile))==m.lcExt OR UPPER(JUSTEXT(m.lcFile))==m.lcExt1
		ENDFOR &&lnFile
		
		RETURN m.llReturn
		
	ENDPROC

	PROCEDURE get_md5
		#IF .F. THEN
		 #include "C:\Program Files (x86)\Microsoft Visual FoxPro 9\ffc\wincrypt.h"
		
		* This routine takes a string as input
		* and returns an MD5 hash value as a string.
		*
		* The calculation in implemented using the MS Crypto API and the RSA provider.
		 LPARAMETERS;
		  tcData
		
		 LOCAL;
		  lnStatus,;
		  lnErr,;
		  lhProv,;
		  lhHashObject,;
		  lnDataSize,;
		  lcHashValue,;
		  lnHashSize
		
		 lhProv = 0
		 lhHashObject = 0
		 lnDataSize = LEN(tcData)
		 lcHashValue = REPLICATE(CHR(0), 16)
		 lnHashSize = LEN(lcHashValue)
		
		
		 TRY
		
		   DECLARE INTEGER GetLastError ;
		    IN win32api AS GetLastError
		
		   DECLARE INTEGER CryptAcquireContextA ;
		    IN WIN32API AS CryptAcquireContext ;
		    INTEGER @lhProvHandle, ;
		    STRING  cContainer, ;
		    STRING  cProvider, ;
		    INTEGER nProvType, ;
		    INTEGER nFlags
		
		* load a crypto provider
		   lnStatus = CryptAcquireContext(@lhProv, 0, 0, dnPROV_RSA_FULL, dnCRYPT_VERIFYCONTEXT)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		   DECLARE INTEGER CryptCreateHash ;
		    IN WIN32API AS CryptCreateHash ;
		    INTEGER hProviderHandle, ;
		    INTEGER nALG_ID, ;
		    INTEGER hKeyhandle, ;
		    INTEGER nFlags, ;
		    INTEGER @hCryptHashHandle
		
		* create a hash object that uses MD5 algorithm
		   lnStatus = CryptCreateHash(lhProv, dnCALG_MD5, 0, 0, @lhHashObject)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptHashData ;
		    IN WIN32API AS CryptHashData ;
		    INTEGER hHashHandle, ;
		    STRING  @cData, ;
		    INTEGER nDataLen, ;
		    INTEGER nFlags
		
		* add the input data to the hash object
		   lnStatus = CryptHashData(lhHashObject, tcData, lnDataSize, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptGetHashParam ;
		    IN WIN32API AS CryptGetHashParam ;
		    INTEGER hHashHandle, ;
		    INTEGER nParam, ;
		    STRING  @cHashValue, ;
		    INTEGER @nHashSize, ;
		    INTEGER nFlags
		
		* retrieve the hash value, if caller did not provide enough storage (16 bytes for MD5)
		* this will fail with dnERROR_MORE_DATA and lnHashSize will contain needed storage size
		   lnStatus = CryptGetHashParam(lhHashObject, dnHP_HASHVAL, @lcHashValue, @lnHashSize, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptDestroyHash ;
		    IN WIN32API AS CryptDestroyHash;
		    INTEGER hKeyHandle
		
		* free the hash object
		   lnStatus = CryptDestroyHash(lhHashObject)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptReleaseContext ;
		    IN WIN32API AS CryptReleaseContext ;
		    INTEGER hProvHandle, ;
		    INTEGER nReserved
		
		* release the crypto provider
		   lnStatus = CryptReleaseContext(lhProv, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		  CATCH TO lnErr
		
		* clean up the hash object and release provider
		   IF lhHashObject != 0
		    CryptDestroyHash(lhHashObject)
		   ENDIF
		
		
		   IF lhProv != 0
		    CryptReleaseContext(lhProv, 0)
		   ENDIF
		
		   ERROR("HashMD5 Failed")
		
		 ENDTRY
		
		 RETURN lcHashValue
		#ENDIF &&.F.
		
	ENDPROC

	PROCEDURE oget_setting		&& Returns a settings object of a given path with config from FoxBin2PRG.
		LPARAMETERS;
		 tcPath,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Returns FoxBin2Prg's setting.</descr>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source path of the operation</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<retval type="Object">Settings object of FoxBin2Prg.</retval>
		*!*	<remarks>Returns FoxBin2Prg's setting for path <pdmpara num="1" />.</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 13.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcTemp    AS CHARACTER,;
		 loSett    AS OBJECT
		
		
		IF !PEMSTATUS(THIS,'goSetts',5) THEN
		 THIS.ADDPROPERTY('goSetts',NEWOBJECT("COLLECTION"))
		ENDIF &&!PEMSTATUS(THIS,'goSetts',5)
		
		lcTemp = SYS(2007,UPPER(tcPath),0,2)
		IF THIS.goSetts.GETKEY(m.lcTemp)#0 THEN
		 loSett = THIS.goSetts.ITEM(m.lcTemp)
		ELSE  &&THIS.goSetts.GETKEY(m.lcTemp)#0
		 loSett = toConverter.Get_DirSettings(tcPath,_SCREEN.gcB2T_Log,_SCREEN.gcB2T_Config)
		 THIS.goSetts.ADD(m.loSett,m.lcTemp)
		ENDIF &&THIS.goSetts.GETKEY(m.lcTemp)#0
		
		RETURN m.loSett
		
	ENDPROC

	PROCEDURE process_bin2txt		&& Process all files of a given array to text files.
		LPARAMETERS;
		 taFiles,;
		 tcMode,;
		 tlCheckAll,;
		 tlIncludeAll,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<descr>Process all files of a given Array.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*!*	<p>List of files to process.</p>
		*!*	<p>Allways binaries, even if as target not existing yet!.</p>
		*!*	<p>The method determines correct extensions for text files itself.</p>
		*!*	<p>The array can be one or two dimensional</p>
		*!*	<dl>
		*!*	 <dt>Column one</dt><dd>Binary file with path.</dd>
		*!*	 <dt>Column two</dt>
		*!*	  <dd>
		*!*	   Optional. Defines a ProjectHook.<br />
		*!*	   <expr>.NULL.</expr> if not determined, Empty, if no ProjectHook is to be processed.<br />
		*!*	   Only valid for PJX files in column one.
		*!*	  </dd>
		*!*	 <dt>Column three</dt>
		*!*	 <dd>
		*!*	  Additional files to process, non structural index-files for DBF.
		*!*	  List of files, delimited by <expr>CHR(0)</expr>, starting with <expr>CHR(0)</expr>.<br/>
		*!*	  Ignored if empty.
		*!*	 </dd>
		*!*	</dl>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*!*	<p>Checks if all files listed in <pdmpara num="1" /> are used.</p>
		*!*	<p>If a file is not found, text file corresponding will be deleted.</p>
		*!*	<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlIncludeAll" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Convert all files.</short>
		*!*	<detail>
		*!*	<p>Controls if all files are transformed.</p>
		*!*	<p>Only the files changed might be transformed.
		*!*	This can override stored setting.</p>
		*!*	<p>If True, the file will not be synched with the storage table.</p>
		*!*	<p>If parameter is not passed, this default to the setting stored.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.<br />
		*Will be passed to <see pem="Convert" /></detail>
		*!*	</params>
		
		*!*	<retval type="Boolean">Returns succcess of operation.</retval>
		*!*	<remarks>
		*!*	<b>This is the main method. What makes it different from a plain call to FoxBin2Prg is:</b>
		*!*	<ul>
		*!*	 <li>Accepts a mixed array of files. (including whole PJX) </li>
		*!*	 <li>Can limit the Bin2Text operation to dirty files only.</li>
		*!*	 <li>Can delete obsolete class files in ClassPerFile operations.</li>
		*!*	 <li>Can delete obsolete files for removed binaries if <pdmpara num="3" />.</li>
		*!*	</ul>
		*!*	<p>If text to binary, it just passes the files to FoxBin2Prg</p>
		*!*	<p>Creating text files, depending on a setting, it first let check FoxBin2Prg what to do.
		*!*	 IOW what files are included in the process.</p>
		*!*	<p>Then it calls for <see pem="FilesToProcess" /> to see if files are changed.
		*!*	 Only files marked as dirty will be processed.</p>
		*!*	<p>A postprocess will delete / remove obsolete text files.</p>
		*!*	</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="3" />
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,13:00:00}">Changed by: SF<br />
		*!*	Modified to deal with single classes of libraries.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,14:00:00}">Changed by: SF<br />
		*!*	<pdmpara num="1" /> may now hold text files for Text To Bin operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,16:00:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" /> to force single file operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-28,12:00:00}">Changed by: SF<br />
		*!*	Modified to deal ::(import|export)
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile        AS CHARACTER,;
		 lcMode        AS CHARACTER,;
		 lcPath        AS CHARACTER,;
		 lcSourceExt   AS CHARACTER,;
		 lcStorage     AS CHARACTER,;
		 lcTarget      AS CHARACTER,;
		 lcClass       AS CHARACTER,;
		 lnFile        AS NUMBER,;
		 lnFilesFound  AS NUMBER,;
		 lnTable       AS NUMBER,;
		 lnOffsets     AS NUMBER,;
		 lnConvert     AS NUMBER,;
		 lnTableFound  AS NUMBER,;
		 llFound       AS BOOLEAN,;
		 llMaxiLoop    AS BOOLEAN,;
		 llSingleClass AS BOOLEAN,;
		 llProcess     AS BOOLEAN,;
		 llExpandDBC   AS BOOLEAN,;
		 llPJXOpen     AS BOOLEAN,;
		 llPJXUsed     AS BOOLEAN,;
		 lvTime        AS VARIANT,;
		 loProject     AS PROJECT,;
		 loException   AS EXCEPTION,;
		 loSetting     AS EMPTY,;
		 loSett        AS OBJECT,;
		 loExtraFiles  AS OBJECT,;
		 loConverter   AS "c_foxbin2prg" OF "E:\x\Helper\ThirdParty\VFPX\FoxBin2PRG\FOXBIN2PRG.PRG"
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 m.lnFiles,;
		 m.lnOffsets
		
		lcMode = "BIN2PRG"
		
		loExtraFiles = NEWOBJECT('collection')
		THIS.Storage_Get("S",m.loExtraFiles,m.lcStorage)
		
		* Check Include DBF of DBC [1 On; else OFF]
		IF !EMPTY(m.loExtraFiles.GETKEY("gcB2T_DBC")) THEN
		 loSetting = m.loExtraFiles.ITEM("gcB2T_DBC")
		 llExpandDBC = m.loSetting.gcFile=="1"
		ENDIF &&!EMPTY(loExtraFiles.GetKey("gcB2T_DBC"))
		* /Check Include DBF of DBC [1 On; else OFF]
		
		*!*	Changed  by: SF 28.2.2021
		*!*	<pdm>
		*!*	<change date="{^2021-02-28,21:02:00}">Changed  by: SF<br />
		*!*	Add List of files stored with settings.
		*!*	</change>
		*!*	</pdm>
		
		IF ATC('-IncludeList',m.tcMode)>0 THEN
		 tcMode        = STRTRAN(m.tcMode,'-IncludeList','',1,-1,1)
		
		 m.loExtraFiles.REMOVE(-1)
		 THIS.Storage_Get("A",m.loExtraFiles,m.lcStorage)
		
		 FOR EACH loSetting IN m.loExtraFiles FOXOBJECT
		  IF EMPTY(ASCAN(m.taFiles,m.loSetting.gcFile,1,-1,2,15)) THEN
		*additional file not found. Add
		   lnFiles   = m.lnFiles+1
		   lnOffsets = m.lnOffsets+1
		   DIMENSION;
		    m.taFiles(m.lnFiles,ALEN(m.taFiles,2))
		
		   taFiles(m.lnFiles,1)	= m.loSetting.gcFile
		   taFiles(m.lnFiles,2)	= m.lcMode
		  ENDIF &&EMPTY(ASCAN(m.taFiles,m.lcFile,1,-1,2,15))
		
		 ENDFOR &&loSetting
		
		ENDIF &&ATC('-IncludeList',m.tcMode)>0
		
		*!*	/Changed  by: SF 28.2.2021
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,4),;
		 laToConvert(1,4),;
		 laDBC_Tables(1,4),;
		 laDBCs(1,2)
		
		laDBCs = .NULL.
		
		lnFilesFound = 0
		lnTableFound = 0
		
		* Process Databases that are within the array
		* Databases in PJX will be parsed out later
		FOR lnFile = 1 TO m.lnFiles
		 laFiles(m.lnFile,1) = m.taFiles(m.lnFile,1)
		ENDFOR &&lnFile
		
		THIS.Get_DBC_Tables(@laFiles,@laFiles,@laDBC_Tables,@lnTableFound,m.lcMode,.F.,m.loConverter)
		
		DIMENSION;
		 m.laFiles(m.lnFiles,4)
		
		laFiles     = NIL
		* /Process Databases that are within the array
		
		*process sourcefiles
		lnFile = 0
		DO WHILE m.lnFile<m.lnFiles
		 lnFile		  = m.lnFile+1
		 lnFilesFound = m.lnFilesFound+1
		*wie machen wir das, wenn wir noch keine pjx haben?!!!
		
		*extract class for processing
		 lcClass = ""
		 IF '::'$m.taFiles(m.lnFile,1) THEN
		  taFiles(m.lnFile,1) = STRTRAN(m.taFiles(m.lnFile,1),'::','.',1,1)
		  lcClass			  = "::"+JUSTEXT(m.taFiles(m.lnFile,1))
		  taFiles(m.lnFile,1) = FORCEEXT( m.taFiles(m.lnFile,1),'')
		  llSingleClass		  = True
		 ENDIF &&'::'$taFiles(m.lnFile,1)
		
		 loSett		 = THIS.oGet_Setting(JUSTPATH(m.taFiles(m.lnFile,1)),m.loConverter)
		 lcSourceExt = UPPER(JUSTEXT(m.taFiles(m.lnFile,1)))
		
		*check if just a binary file name is send, as expected
		 DO CASE
		  CASE UPPER(m.lcSourceExt)=="VCX"
		  CASE UPPER(m.lcSourceExt)=="FRX"
		  CASE UPPER(m.lcSourceExt)=="MNX"
		  CASE UPPER(m.lcSourceExt)=="DBF"
		  CASE UPPER(m.lcSourceExt)=="DBC"
		  CASE UPPER(m.lcSourceExt)=="PJX"
		  CASE UPPER(m.lcSourceExt)=="LBX"
		  CASE UPPER(m.lcSourceExt)=="SCX"
		  CASE UPPER(m.lcSourceExt)=="SCX"
		*Additional extensions
		  CASE UPPER(m.lcSourceExt)=="FKY"
		  CASE UPPER(m.lcSourceExt)=="MEM"
		  OTHERWISE
		*Error, no known extension
		   lcSourceExt = ""
		 ENDCASE
		
		 IF EMPTY(m.lcSourceExt) THEN
		*undefined extension, just ignore
		  ADEL(m.laFiles,m.lnFilesFound)
		  lnFilesFound = m.lnFilesFound-1
		  lnOffsets	   = m.lnOffsets-1
		  IF m.lnFilesFound=0 THEN
		   EXIT
		
		  ELSE  &&m.lnFilesFound=0
		   DIMENSION;
		    m.laFiles(m.lnOffsets,4)
		   LOOP
		  ENDIF &&m.lnFilesFound=0
		
		 ELSE  &&EMPTY(m.lcSourceExt)
		  laFiles(m.lnFilesFound,1) = FORCEEXT(m.taFiles(m.lnFile,1),m.lcSourceExt)+;
		   m.lcClass															&&Source File of transformation; Text or Text
		 ENDIF &&EMPTY(m.lcSourceExt)
		
		 laFiles(m.lnFilesFound,2) = m.tcMode 									&&a project file bin or text
		 laFiles(m.lnFilesFound,3) = m.taFiles(m.lnFile,1)						&&VFP Bin File
		 DO CASE
		  CASE !UPPER(JUSTEXT(m.taFiles(m.lnFile,1)))='PJX'
		*nothing to do
		   laFiles(m.lnFilesFound,2) = m.lcMode									&&not a project file
		   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		*odd order?, next three pairs:
		*!*	  CASE ALEN(m.taFiles,2)<2
		*!*	*nothing defined yet, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but maybe after conversion
		*!*	  CASE ALEN(m.taFiles,2)<2 AND !m.tlText2Bin
		*!*	*nothing defined, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		  CASE ALEN(m.taFiles,2)<2
		*nothing defined, parse later
		   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		*!*	  CASE ISNULL(m.taFiles(m.lnFile,2))
		*!*	*nothing defined yet, parse again after processing (if pjx changed)
		*!*	   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE ISNULL(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*nothing defined yet, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		  CASE ISNULL(m.taFiles(m.lnFile,2))
		*nothing defined yet, parse later
		   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		*!*	  CASE EMPTY(m.taFiles(m.lnFile,2))
		*!*	*nothing hook defined yet, but may change again after processing (if pjx changed)
		*!*	   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE EMPTY(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*no Hook, do nothing
		*!*	   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		  CASE EMPTY(m.taFiles(m.lnFile,2))
		*no Hook, do nothing
		   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		
		  OTHERWISE
		*Hook, to text
		   lnOffsets = m.lnOffsets+1
		   DIMENSION;
		    m.laFiles(m.lnOffsets,4)
		
		   laFiles(m.lnOffsets,1) = m.taFiles(m.lnFile,2)						&&Source File of transformation; Bin
		   laFiles(m.lnOffsets,2) = m.lcMode									&&not a project file
		   laFiles(m.lnOffsets,3) = m.taFiles(m.lnFile,2)						&&VFP Bin File
		   laFiles(m.lnOffsets,4) = 0											&&no Hook
		
		   laFiles(m.lnFilesFound,4) = 0										&&no Hook
		 ENDCASE
		ENDDO &&m.lnFile<m.lnFiles
		
		*!*	Change by: SF 15.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-15,06:56:00}">Change by: SF<br />
		*!*	Preprocessing <expr>PROJECTHOOKLIBRARY</expr> only for Bin 2 Text
		*!*	</change>
		*!*	</pdm>
		
		*process transformation, only for Bin 2 Text (Text 2 Bin will be read after recreating)
		FOR lnFile = 1 TO m.lnFilesFound
		 lcFile = m.laFiles(m.lnFile,3)
		
		 IF FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX' THEN
		  llPJXOpen = .F.
		
		  TRY
		*Was zu testen ist
		    _VFP.PROJECTS.ITEM(m.lcFile)
		    llPJXOpen = .T.
		
		   CATCH TO loException WHEN m.loException.ERRORNO=1429 OR m.loException.ERRORNO=1428
		* Abzufangender Fehler
		    llPJXOpen = .F.
		   CATCH TO loException
		* andere Fehler, Standardhandler rufen
		    THROW
		   FINALLY
		    llPJXUsed = .F.
		  ENDTRY
		
		* parse out DBC
		  IF m.llExpandDBC THEN
		   IF !m.llPJXOpen AND !m.llPJXUsed THEN
		    MODIFY PROJECT (m.lcFile) NOWAIT NOSHOW NOPROJECTHOOK
		    llPJXUsed = .T.
		   ENDIF &&!m.llPJXOpen AND !m.llPJXUsed
		   TRY
		*Was zu testen ist
		     loProject = _VFP.PROJECTS(JUSTFNAME(m.lcFile))
		
		    CATCH TO loException WHEN m.loException.ERRORNO=1429 OR m.loException.ERRORNO=1428
		* Abzufangender Fehler -> project open cancled
		     llPJXUsed = .F.
		    CATCH TO loException
		* andere Fehler, Standardhandler rufen
		     THROW
		    FINALLY
		
		   ENDTRY
		
		   IF !m.llPJXUsed THEN
		    LOOP
		   ENDIF &&!m.llPJXUsed
		
		   lnTable = 0
		
		   FOR EACH m.lcTarget IN m.loProject.FILES FOXOBJECT
		    IF m.lcTarget.TYPE=='d' THEN
		
		     lcTarget = ALLTRIM(m.lcTarget.NAME)
		
		     lnTable = m.lnTable+1
		     DIMENSION;
		      m.laDBCs(m.lnTable,2)
		
		     laDBCs(m.lnTable,1) = m.lcTarget			&&Source File of transformation; Bin
		     laDBCs(m.lnTable,2) = m.lcMode				&&not a project file
		    ENDIF &&m.lcTarget.TYPE=='d'
		   ENDFOR &&m.lcTarget
		
		   IF m.lnTable>0 THEN
		    THIS.Get_DBC_Tables(@laDBCs,@laFiles,@laDBC_Tables,@lnTableFound,m.lcMode,.F.,m.loConverter)
		   ENDIF &&lnTable>0
		
		   lnTable = 0
		   DIMENSION;
		    m.laDBCs(1,2)
		
		   laDBCs = .NULL.
		  ENDIF &&m.llExpandDBC
		* /parse out DBC
		
		  IF m.laFiles(m.lnFile,4)=1 THEN
		
		   IF !m.llPJXOpen AND !m.llPJXUsed THEN
		    MODIFY PROJECT (m.lcFile) NOWAIT NOSHOW NOPROJECTHOOK
		    llPJXUsed = .T.
		   ENDIF &&!m.llPJXOpen AND !m.llPJXUsed
		
		   TRY
		*Was zu testen ist
		     loProject = _VFP.PROJECTS(JUSTFNAME(m.lcFile))
		
		    CATCH TO loException WHEN m.loException.ERRORNO=1429 OR m.loException.ERRORNO=1428
		* Abzufangender Fehler -> project open cancled
		     llPJXUsed = .F.
		    CATCH TO loException
		* andere Fehler, Standardhandler rufen
		     THROW
		    FINALLY
		
		   ENDTRY
		
		   IF !m.llPJXUsed THEN
		    LOOP
		   ENDIF &&!m.llPJXUsed
		
		   lcFile = ALLTRIM(m.loProject.PROJECTHOOKLIBRARY)
		
		   IF !EMPTY(m.lcFile) THEN
		    lnOffsets = m.lnOffsets+1
		    DIMENSION;
		     m.laFiles(m.lnOffsets,4)
		
		    laFiles(m.lnOffsets,1)	= m.lcFile								&&Source File of transformation; Bin
		    laFiles(m.lnOffsets,2)	= m.lcMode								&&not a project file
		    laFiles(m.lnOffsets,3)	= m.lcFile								&&VFP Bin File
		    laFiles(m.lnOffsets,4)	= 0										&&No Hook :)
		   ENDIF &&!EMPTY(m.lcFile)
		  ENDIF &&laFiles(m.lnFile,4)=1
		
		  IF m.llPJXUsed THEN
		   loProject.CLOSE
		   loProject = .NULL.
		   llPJXUsed = .F.
		  ENDIF &&m.llPJXUsed
		
		 ENDIF &&FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX'
		ENDFOR &&m.lnFile
		
		*!*	/Change by: SF 15.6.2015
		
		* only bin to text for now and switch not all set
		IF PCOUNT()<5 THEN
		 tlIncludeAll = NIL
		ENDIF &&PCOUNT()<5
		
		llMaxiLoop = !ISNULL(m.lcStorage) AND NVL(!m.tlIncludeAll,TYPE('_SCREEN.gcB2T_Opt')="C" AND _SCREEN.gcB2T_Opt=="1")
		llFound	   = .T.
		
		lcPath = JUSTPATH(_SCREEN.gcB2T_Path)
		
		m.loConverter.LoadProgressbarForm()
		ACTIVATE SCREEN
		
		IF m.lnFilesFound>0 THEN
		* we have something to parse
		* number of files to parse: m.lnOffsets ( this is m.lnFilesFound + Hooks) + m.lnTableFound
		 DIMENSION;
		  laToConvert(m.lnOffsets+m.lnTableFound,3),;
		  laFiles(m.lnOffsets+m.lnTableFound,4)
		
		* files in parameters section
		* must be shown, because they are processed or pre-processed
		 FOR lnConvert = 1 TO m.lnFilesFound
		  laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		* Hooks
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = m.lnFilesFound+1 TO m.lnOffsets
		  laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = !m.llMaxiLoop
		 ENDFOR &&lnConvert
		
		* Table of Databases (laDBC_Tables) figured out above
		* - add to laFiles for later processing
		* - add to laToConvert for processing here
		
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = 1 TO m.lnTableFound
		  laFiles(m.lnOffsets+m.lnConvert,1) = m.laDBC_Tables(m.lnConvert,1)
		  laFiles(m.lnOffsets+m.lnConvert,2) = m.laDBC_Tables(m.lnConvert,2)
		  laFiles(m.lnOffsets+m.lnConvert,3) = m.laDBC_Tables(m.lnConvert,3)
		  laFiles(m.lnOffsets+m.lnConvert,4) = m.laDBC_Tables(m.lnConvert,4)
		
		  laToConvert(m.lnOffsets+m.lnConvert,1) = m.laDBC_Tables(m.lnConvert,1)
		  laToConvert(m.lnOffsets+m.lnConvert,2) = m.laDBC_Tables(m.lnConvert,2)
		  laToConvert(m.lnOffsets+m.lnConvert,3) = !m.llMaxiLoop
		 ENDFOR &&lnConvert
		
		 IF m.llMaxiLoop THEN
		  ?'Pre - processing:'
		 ELSE  &&m.llMaxiLoop
		  ?'Processing:'
		 ENDIF &&m.llMaxiLoop
		 llFound = THIS.Convert(@laToConvert,!m.llMaxiLoop,m.loConverter,0,m.toFB2T_Setting)
		ELSE  &&m.lnFilesFound>0
		 llFound = False
		ENDIF &&m.lnFilesFound>0
		
		*ReRun only file(s) changed
		*Ignore Storage if tlIncludeAll
		IF m.llFound THEN
		 IF NVL(!m.tlIncludeAll,True) THEN
		  LOCAL ARRAY;
		   laFiles2(1,2)
		
		  laFiles2 = ''
		  IF m.loConverter.Get_Processed(@laFiles2)#0 THEN
		*Call FilesToProcess in every case, if run after Text2Bin it will set Storage to
		*actual values
		
		*Note! This will change the array!
		*just process all if
		* !maxiloop and !isnull(storage) -> just process files
		* maxiloop (only if  !ISNULL(storage!!)) and processfiles -> run partial
		*maxiloop and isnull(storage)
		   IF !m.llMaxiLoop AND !ISNULL(m.lcStorage) THEN
		*Complete convert is done, just store result
		    THIS.FilesToProcess(@laFiles2,m.lcPath,.F.,m.tlCheckAll,m.lcStorage,m.loConverter)
		*but if we create binaries we may have still undone stuff like new hooks or DBFs of DBCs
		
		   ELSE  &&!m.llMaxiLoop AND !ISNULL(m.lcStorage)
		    llProcess = THIS.FilesToProcess(@laFiles2,m.lcPath,.F.,m.tlCheckAll,m.lcStorage,m.loConverter)
		    DO CASE
		     CASE ISNULL(m.llProcess)
		*need to process all files -> just let FoxBin2PRG do, faster.
		      DIMENSION;
		       m.laToConvert(ALEN(m.laFiles,1),3)
		
		* must be show, because they are processed
		      FOR lnConvert = 1 TO ALEN(m.laFiles,1)
		       laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		       laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		     CASE m.llProcess
		*If not processed in first loop, process now, file by file.
		      loConverter.l_ProcessFiles			= .T.
		      loConverter.l_AutoClearProcessedFiles	= .T.
		
		      lnFiles  = ALEN(m.laFiles2,1)
		*just set "not a project"
		      FOR lnFile = 1 TO m.lnFiles
		       laFiles2(m.lnFile,2) = m.lcMode
		      ENDFOR &&lnFile
		
		      DIMENSION;
		       m.laToConvert(ALEN(m.laFiles2,1),3)
		
		      FOR lnConvert = 1 TO ALEN(m.laFiles2,1)
		       laToConvert(m.lnConvert,1) = m.laFiles2(m.lnConvert,1)					&& File
		       laToConvert(m.lnConvert,2) = m.laFiles2(m.lnConvert,2)					&& Mode
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnOffsets,m.toFB2T_Setting)
		    ENDCASE
		
		   ENDIF &&!m.llMaxiLoop AND !ISNULL(m.lcStorage)
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:40:00}">Changed by: SF<br />
		*!*	Code to delte / backup text files no more needed.
		*!*	</change>
		*!*	</pdm>
		
		   IF _SCREEN.gcB2T_Delete=="1" THEN
		*Delete obsolete classes from classlibs
		    SELECT (m.lcStorage)
		*sfx todo SQL
		    SCAN FOR iDirty=-1
		
		     loSett		 = THIS.oGet_Setting(JUSTPATH(cFile),m.loConverter)
		     lcSourceExt = UPPER(JUSTEXT(cFile))
		
		     DO CASE
		      CASE UPPER(m.lcSourceExt)=="VCX"
		       lcSourceExt = m.loSett.c_VC2
		      CASE UPPER(m.lcSourceExt)=="FRX"
		       lcSourceExt = m.loSett.c_FR2
		      CASE UPPER(m.lcSourceExt)=="MNX"
		       lcSourceExt = m.loSett.c_MN2
		      CASE UPPER(m.lcSourceExt)=="DBF"
		       lcSourceExt = m.loSett.c_DB2
		      CASE UPPER(m.lcSourceExt)=="DBC"
		       lcSourceExt = m.loSett.c_DC2
		      CASE UPPER(m.lcSourceExt)=="PJX"
		       lcSourceExt = m.loSett.c_PJ2
		      CASE UPPER(m.lcSourceExt)=="LBX"
		       lcSourceExt = m.loSett.c_LB2
		      CASE UPPER(m.lcSourceExt)=="SCX"
		*Fehler: c_CC2 statt c_SC2
		       lcSourceExt = m.loSett.c_SC2
		*Additional extensions
		      CASE UPPER(m.lcSourceExt)=="FKY"
		       lcSourceExt = m.loSett.c_FK2
		      CASE UPPER(m.lcSourceExt)=="MEM"
		       lcSourceExt = m.loSett.c_ME2
		      OTHERWISE
		       LOOP
		     ENDCASE
		
		     lcFile = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		      EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		     DO CASE
		      CASE !FILE(m.lcFile)
		*nothing found, nothing to do
		      CASE m.loSett.n_ExtraBackupLevels>0
		*Backup (only one level deep)
		       lcSourceExt = m.lcSourceExt+'.Del.Bak'
		       lcTarget = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		        EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		       IF FILE(m.lcTarget) THEN
		        DELETE FILE &lcTarget
		       ENDIF &&FILE(m.lcTarget)
		       RENAME &lcFile TO &lcTarget
		
		      OTHERWISE
		*Delete
		       DELETE FILE &lcFile
		     ENDCASE
		*sfx todo SQL
		     REPLACE;
		      iDirty WITH -2
		    ENDSCAN &&iDirty=-1
		   ENDIF &&_SCREEN.gcB2T_Delete=="1"
		*!*	/Changed by: SF 4.6.2015
		
		  ENDIF &&m.loConverter.Get_Processed(@laFiles2)#0
		 ELSE  &&NVL(!m.tlIncludeAll,True)
		
		 ENDIF &&NVL(!m.tlIncludeAll,True)
		ENDIF &&m.llFound
		
		m.loConverter.UnloadProgressbarForm()
		loConverter =  NIL
		
		THIS.Storage_Close(m.lcStorage,m.llFound)
		
		ACTIVATE SCREEN
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&!m.llFound
		 ?""
		ENDIF &&!m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE process_bin2txt_dir		&& Process all directories of a given array to text. Storage not used.
		LPARAMETERS;
		 taFiles,;
		 tlText2Bin,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="taFiles" type="Array" byref="1" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.<br />
		*Will be passed to <see pem="Convert" /></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		
		LOCAL;
		 lcStorage   AS STRING,;
		 llFound     AS BOOLEAN,;
		 lnFile      AS NUMBER,;
		 lnOffsets   AS NUMBER,;
		 loConverter AS OBJECT,;
		 lvTime      AS VARIANT
		
		EXTERNAL ARRAY;
		 taFiles
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 lnFiles
		
		STORE ALEN(m.taFiles,2) TO;
		 lnCols
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,4)
		
		lnOffsets = 0
		
		FOR lnFile = 1 TO m.lnFiles
		 DO CASE
		  CASE m.taFiles(m.lnFile,1)='.'
		  CASE m.taFiles(m.lnFile,1)='..'
		  CASE !DIRECTORY(m.taFiles(m.lnFile,1))
		  OTHERWISE
		
		   lnOffsets              = m.lnOffsets+1
		   laFiles(m.lnOffsets,1) = m.taFiles(m.lnFile,1)
		   laFiles(m.lnOffsets,2) = "BIN2PRG"
		   laFiles(m.lnOffsets,3) = .T.
		
		 ENDCASE
		ENDFOR &&lnfile
		
		IF m.lnOffsets>0 THEN
		 LOCAL ARRAY;
		  laFiles(m.lnOffsets,3)
		
		 m.loConverter.LoadProgressbarForm()
		 ACTIVATE SCREEN
		
		 ?'Processing:'
		 llFound = THIS.Convert(@laFiles,.T.,m.loConverter,0,m.toFB2T_Setting)
		
		 m.loConverter.UnloadProgressbarForm()
		ENDIF &&m.lnOffsets>0
		
		loConverter =  NIL
		
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&m.llFound
		 ?""
		ENDIF &&m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE process_txt2bin		&& Process all files of a given array to binary files.
		LPARAMETERS;
		 taFiles,;
		 tcMode,;
		 tlCheckAll,;
		 tlIncludeAll,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<descr>Process all files of a given Array.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*!*	<p>List of files to process.</p>
		*!*	<p>Allways binaries, even if as target not existing yet!.</p>
		*!*	<p>The method determines correct extensions for text files itself.</p>
		*!*	<p>The array can be one or two dimensional</p>
		*!*	<dl>
		*!*	 <dt>Column one</dt><dd>Binary file with path.</dd>
		*!*	 <dt>Column two</dt>
		*!*	  <dd>
		*!*	   Optional. Defines a ProjectHook.<br />
		*!*	   <expr>.NULL.</expr> if not determined, Empty, if no ProjectHook is to be processed.<br />
		*!*	   Only valid for PJX files in column one.
		*!*	  </dd>
		*!*	 <dt>Column three</dt>
		*!*	 <dd>
		*!*	  Empty, not used
		*!*	 </dd>
		*!*	</dl>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*!*	<p>Checks if all files listed in <pdmpara num="1" /> are used.</p>
		*!*	<p>If a file is not found, text file corresponding will be deleted.</p>
		*!*	<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlIncludeAll" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Convert all files.</short>
		*!*	<detail>
		*!*	<p>Controls if all files are transformed.</p>
		*!*	<p>If True, the file will not be synched with the storage table.</p>
		*!*	<p>If parameter is not passed, this default to the setting stored.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.<br />
		*!*	Will be passed to <see pem="Convert" /></detail>
		*!*	</params>
		
		*!*	<retval type="Boolean">Returns succcess of operation.</retval>
		*!*	<remarks>
		*!*	<b>This is the main method. What makes it different from a plain call to FoxBin2Prg is:</b>
		*!*	<ul>
		*!*	 <li>Accepts a mixed array of files. (including whole PJX) </li>
		*!*	 <li>Can limit the Bin2Text operation to dirty files only.</li>
		*!*	 <li>Can delete obsolete class files in ClassPerFile operations.</li>
		*!*	 <li>Can delete obsolete files for removed binaries if <pdmpara num="3" />.</li>
		*!*	</ul>
		*!*	<p>If text to binary, it just passes the files to FoxBin2Prg</p>
		*!*	<p>Creating text files, depending on a setting, it first let check FoxBin2Prg what to do.
		*!*	 IOW what files are included in the process.</p>
		*!*	<p>Then it calls for <see pem="FilesToProcess" /> to see if files are changed.
		*!*	 Only files marked as dirty will be processed.</p>
		*!*	<p>A postprocess will delete / remove obsolete text files.</p>
		*!*	</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="3" />
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,13:00:00}">Changed by: SF<br />
		*!*	Modified to deal with single classes of libraries.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,14:00:00}">Changed by: SF<br />
		*!*	<pdmpara num="1" /> may now hold text files for Text To Bin operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,16:00:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" /> to force single file operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-28,12:00:00}">Changed by: SF<br />
		*!*	Modified to deal ::(import|export)
		*!*	</change>
		*!*	</pdm>
		
		LOCAL lnFiles
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile        AS CHARACTER,;
		 lcMode        AS CHARACTER,;
		 lcPath        AS CHARACTER,;
		 lcSourceExt   AS CHARACTER,;
		 lcStorage     AS CHARACTER,;
		 lcTarget      AS CHARACTER,;
		 lcClass       AS CHARACTER,;
		 lnFile        AS NUMBER,;
		 lnFilesFound  AS NUMBER,;
		 lnTable       AS NUMBER,;
		 lnOffset      AS NUMBER,;
		 lnOffsets     AS NUMBER,;
		 lnConvert     AS NUMBER,;
		 lnTableFound  AS NUMBER,;
		 llFound       AS BOOLEAN,;
		 llSingleClass AS BOOLEAN,;
		 llProcess     AS BOOLEAN,;
		 llExpandDBC   AS BOOLEAN,;
		 llPJXUsed     AS BOOLEAN,;
		 lvTime        AS VARIANT,;
		 loSetting     AS EMPTY,;
		 loSett        AS OBJECT,;
		 loExtraFiles  AS OBJECT,;
		 loConverter   AS "c_foxbin2prg" OF "E:\x\Helper\ThirdParty\VFPX\FoxBin2PRG\FOXBIN2PRG.PRG"
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 m.lnFiles,;
		 m.lnOffsets
		
		lcMode = "PRG2BIN"
		
		loExtraFiles = NEWOBJECT('collection')
		THIS.Storage_Get("S",m.loExtraFiles,m.lcStorage)
		
		* Check Include DBF of DBC [1 On; else OFF]
		IF !EMPTY(loExtraFiles.GETKEY("gcB2T_DBC")) THEN
		 loSetting   = loExtraFiles.ITEM("gcB2T_DBC")
		 llExpandDBC = m.loSetting.gcFile=="1"
		ENDIF &&!EMPTY(loExtraFiles.GetKey("gcB2T_DBC"))
		* /Check Include DBF of DBC [1 On; else OFF]
		
		*!*	Changed  by: SF 28.2.2021
		*!*	<pdm>
		*!*	<change date="{^2021-02-28,21:02:00}">Changed  by: SF<br />
		*!*	Add List of files stored with settings.
		*!*	</change>
		*!*	</pdm>
		
		IF ATC('-IncludeList',m.tcMode)>0 THEN
		 tcMode        = STRTRAN(m.tcMode,'-IncludeList','',1,-1,1)
		
		 loExtraFiles.REMOVE(-1)
		 THIS.Storage_Get("A",m.loExtraFiles,m.lcStorage)
		
		 FOR EACH m.loSetting IN m.loExtraFiles FOXOBJECT
		  IF EMPTY(ASCAN(m.taFiles,m.loSetting.gcFile,1,-1,2,15)) THEN
		*additional file not found. Add
		   lnFiles   = m.lnFiles+1
		   lnOffsets = m.lnOffsets+1
		   DIMENSION;
		    taFiles(m.lnFiles,ALEN(m.taFiles,2))
		
		   taFiles(m.lnFiles,1) = m.loSetting.gcFile
		   taFiles(m.lnFiles,2) = m.lcMode
		  ENDIF &&EMPTY(ASCAN(m.taFiles,m.lcFile,1,-1,2,15))
		
		 ENDFOR &&loSetting
		
		ENDIF &&ATC('-IncludeList',m.tcMode)>0
		
		*!*	/Changed  by: SF 28.2.2021
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,4),;
		 laToConvert(1,4),;
		 laDBC_Tables(1,4),;
		 laDBCs(1,2)
		
		laDBCs = .NULL.
		
		lnFilesFound = 0
		lnTableFound = 0
		
		laFiles     = NIL
		
		*process sourcefiles
		lnFile = 0
		DO WHILE m.lnFile<m.lnFiles
		 lnFile       = m.lnFile+1
		 lnFilesFound = m.lnFilesFound+1
		*wie machen wir das, wenn wir noch keine pjx haben?!!!
		
		*extract class for processing
		 lcClass = ""
		 IF '::'$taFiles(m.lnFile,1) THEN
		  taFiles(m.lnFile,1) = STRTRAN(taFiles(m.lnFile,1),'::','.',1,1)
		  lcClass             = "::"+JUSTEXT(taFiles(m.lnFile,1))
		  taFiles(m.lnFile,1) = FORCEEXT( taFiles(m.lnFile,1),'')
		  llSingleClass       = True
		 ENDIF &&'::'$taFiles(m.lnFile,1)
		
		 loSett      = THIS.oGet_Setting(JUSTPATH(taFiles(m.lnFile,1)),m.loConverter)
		 lcSourceExt = UPPER(JUSTEXT(taFiles(m.lnFile,1)))
		
		*if binary file is send, gather text file extension
		 DO CASE
		  CASE m.llSingleClass
		   lcSourceExt = "VCX"
		  CASE UPPER(m.lcSourceExt)=="VCX"
		   lcSourceExt = m.loSett.c_VC2
		  CASE UPPER(m.lcSourceExt)=="FRX"
		   lcSourceExt = m.loSett.c_FR2
		  CASE UPPER(m.lcSourceExt)=="MNX"
		   lcSourceExt = m.loSett.c_MN2
		  CASE UPPER(m.lcSourceExt)=="DBF"
		   lcSourceExt = m.loSett.c_DB2
		  CASE UPPER(m.lcSourceExt)=="DBC"
		   lcSourceExt = m.loSett.c_DC2
		  CASE UPPER(m.lcSourceExt)=="PJX"
		   lcSourceExt = m.loSett.c_PJ2
		  CASE UPPER(m.lcSourceExt)=="LBX"
		   lcSourceExt = m.loSett.c_LB2
		  CASE UPPER(m.lcSourceExt)=="SCX"
		   lcSourceExt = m.loSett.c_SC2
		*Additional extensions
		  CASE UPPER(m.lcSourceExt)=="FKY"
		   lcSourceExt = m.loSett.c_FK2
		  CASE UPPER(m.lcSourceExt)=="MEM"
		   lcSourceExt = m.loSett.c_ME2
		
		*check if just a text file name is send,
		*for the logic of the programm, we need the binary, so we swap
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_VC2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"VCX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_FR2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"FRX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_MN2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"MNX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_DB2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"DBF")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_DC2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"DBC")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_PJ2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"PJX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_LB2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"LBX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_SC2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"SCX")
		*Additional extensions
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_FK2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"FKY")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_ME2
		   taFiles(m.lnFile,1) = FORCEEXT(taFiles(m.lnFile,1),"MEM")
		  OTHERWISE
		*Error, no known extension
		   lcSourceExt = ""
		 ENDCASE
		
		 IF EMPTY(m.lcSourceExt) THEN
		*undefined extension, just ignore
		  ADEL(m.laFiles,m.lnFilesFound)
		  lnFilesFound = m.lnFilesFound-1
		  lnOffsets    = m.lnOffsets-1
		  IF m.lnFilesFound=0 THEN
		   EXIT
		
		  ELSE  &&m.lnFilesFound=0
		   DIMENSION;
		    laFiles(m.lnOffsets,4)
		   LOOP
		  ENDIF &&m.lnFilesFound=0
		
		 ELSE  &&EMPTY(m.lcSourceExt)
		  laFiles(m.lnFilesFound,1) = FORCEEXT(taFiles(m.lnFile,1),m.lcSourceExt)+;
		   m.lcClass															&&Source File of transformation; Text or Text
		 ENDIF &&EMPTY(m.lcSourceExt)
		
		 laFiles(m.lnFilesFound,2) = m.tcMode 									&&a project file bin or text
		 laFiles(m.lnFilesFound,3) = taFiles(m.lnFile,1)						&&VFP Bin File
		 DO CASE
		  CASE !UPPER(JUSTEXT(taFiles(m.lnFile,1)))='PJX'
		*nothing to do
		   laFiles(m.lnFilesFound,2) = m.lcMode									&&not a project file
		   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		*odd order?, next three pairs:
		  CASE ALEN(m.taFiles,2)<2
		*nothing defined yet, parse later
		   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but maybe after conversion
		*!*	  CASE ALEN(m.taFiles,2)<2 AND !m.tlText2Bin
		*!*	*nothing defined, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		  CASE ISNULL(taFiles(m.lnFile,2))
		*nothing defined yet, parse again after processing (if pjx changed)
		   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE ISNULL(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*nothing defined yet, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		  CASE EMPTY(taFiles(m.lnFile,2))
		*nothing hook defined yet, but may change again after processing (if pjx changed)
		   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE EMPTY(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*no Hook, do nothing
		*!*	   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		
		  OTHERWISE
		   laFiles(m.lnFilesFound,4) = 2											&&we have a hook, but check after conversion again
		
		 ENDCASE
		ENDDO &&m.lnFile<m.lnFiles
		
		* only bin to text for now and switch not all set
		IF PCOUNT()<5 THEN
		 tlIncludeAll = NIL
		ENDIF &&PCOUNT()<5
		
		llFound	   = .T.
		
		lcPath = JUSTPATH(_SCREEN.gcB2T_Path)
		
		loConverter.LoadProgressbarForm()
		ACTIVATE SCREEN
		
		IF m.lnFilesFound>0 THEN
		* we have something to parse
		* number of files to parse: m.lnOffsets ( this is m.lnFilesFound + Hooks) + m.lnTableFound
		 DIMENSION;
		  laToConvert(m.lnOffsets+m.lnTableFound,3),;
		  laFiles(m.lnOffsets+m.lnTableFound,4)
		
		* files in parameters section
		* must be shown, because they are processed or pre-processed
		 FOR lnConvert = 1 TO m.lnFilesFound
		  laToConvert(m.lnConvert,1) = laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		* Hooks
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = m.lnFilesFound+1 TO m.lnOffsets
		  laToConvert(m.lnConvert,1) = laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		
		* Table of Databases (laDBC_Tables) figured out above
		* - add to laFiles for later processing
		* - add to laToConvert for processing here
		
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = 1 TO m.lnTableFound
		  laFiles(m.lnOffsets+m.lnConvert,1) = laDBC_Tables(m.lnConvert,1)
		  laFiles(m.lnOffsets+m.lnConvert,2) = laDBC_Tables(m.lnConvert,2)
		  laFiles(m.lnOffsets+m.lnConvert,3) = laDBC_Tables(m.lnConvert,4)
		
		  laToConvert(m.lnOffsets+m.lnConvert,1) = laDBC_Tables(m.lnConvert,1)
		  laToConvert(m.lnOffsets+m.lnConvert,2) = laDBC_Tables(m.lnConvert,2)
		  laToConvert(m.lnOffsets+m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		
		 ?'Processing:'
		 llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,0,m.toFB2T_Setting)
		ELSE  &&m.lnFilesFound>0
		 llFound = False
		ENDIF &&m.lnFilesFound>0
		
		*ReRun only file(s) changed
		*Ignore Storage if tlIncludeAll
		IF m.llFound THEN
		 IF NVL(!m.tlIncludeAll,True) THEN
		  LOCAL ARRAY;
		   laFiles2(1,2)
		
		  laFiles2 = ''
		  IF loConverter.Get_Processed(@laFiles2)#0 THEN
		*Call FilesToProcess in every case, if run after Text2Bin it will set Storage to
		*actual values
		
		*Note! This will change the array!
		*just process all if
		* !maxiloop and !isnull(storage) -> just process files
		* maxiloop (only if  !ISNULL(storage!!)) and processfiles -> run partial
		*maxiloop and isnull(storage)
		   IF !ISNULL(m.lcStorage) THEN
		*Complete convert is done, just store result
		    THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,m.tlCheckAll,m.lcStorage,m.loConverter)
		*but if we create binaries we may have still undone stuff like new hooks or DBFs of DBCs
		
		    DIMENSION;
		     laFiles2(1,4)
		
		    lnOffset = 0
		    lnTable  = 0
		
		* parse out extra DBC
		    IF m.llExpandDBC THEN
		     FOR lnFile = 1 TO m.lnFilesFound
		
		      lcFile = laFiles(m.lnFile,3)
		
		      IF FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='DBC' THEN
		       lnTable = m.lnTable+1
		       DIMENSION;
		        laDBCs(m.lnTable,2)
		
		       loSett      = THIS.oGet_Setting(JUSTPATH(m.lcFile),m.loConverter)
		       lcSourceExt = m.loSett.c_DC2
		
		       laDBCs(m.lnTable,1) = FORCEEXT(m.lcFile,m.lcSourceExt)			&&Source File of transformation; Bin
		       laDBCs(m.lnTable,2) = m.lcMode									&&not a project file
		
		      ENDIF &&FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='DBC'
		     ENDFOR &&lnFile
		
		     IF m.lnTable>0 THEN
		      THIS.Get_DBC_Tables(@laDBCs,@laFiles2,@laFiles2,@lnOffset,m.lcMode,.T.,m.loConverter)
		     ENDIF &&lnTable>0
		
		     lnTable = 0
		     DIMENSION;
		      laDBCs(1,2)
		
		     laDBCs = .NULL.
		    ENDIF &&m.llExpandDBC
		
		    FOR lnFile = 1 TO m.lnFilesFound
		
		     lcFile = laFiles(m.lnFile,3)
		
		*search for project hooks
		     IF FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX' THEN
		
		* parse out DBC of PJX
		      IF m.llExpandDBC THEN
		       USE (m.lcFile) ALIAS curPJX IN SELECT('curPJX')
		       llPJXUsed = .T.
		
		       SELECT;
		        Cur1.NAME AS cFile;
		        FROM curPJX AS Cur1;
		        INTO CURSOR curW;
		        WHERE TYPE=='d'
		
		       lnTable = 0
		
		       SCAN
		        lcTarget = ADDBS(JUSTPATH(m.lcFile))+ALLTRIM(cFile)
		
		        lnTable = m.lnTable+1
		        DIMENSION;
		         laDBCs(m.lnTable,2)
		
		        loSett      = THIS.oGet_Setting(JUSTPATH(m.lcTarget),m.loConverter)
		        lcSourceExt = m.loSett.c_DC2
		
		        laDBCs(m.lnTable,1) = FORCEEXT(m.lcTarget,m.lcSourceExt)			&&Source File of transformation; Bin
		        laDBCs(m.lnTable,2) = m.lcMode										&&not a project file
		       ENDSCAN &&All
		
		       IF m.lnTable>0 THEN
		        THIS.Get_DBC_Tables(@laDBCs,@laFiles2,@laFiles2,@lnOffset,m.lcMode,.T.,m.loConverter)
		       ENDIF &&lnTable>0
		
		       lnTable = 0
		       DIMENSION;
		        laDBCs(1,2)
		
		       laDBCs = .NULL.
		      ENDIF &&m.llExpandDBC
		* /parse out DBC
		
		*Project Hook
		      IF laFiles(m.lnFile,4)>1 THEN
		       IF !m.llPJXUsed THEN
		        USE (m.lcFile) ALIAS curPJX IN SELECT('curPJX')
		        llPJXUsed = .T.
		       ENDIF &&!m.llPJXUsed
		
		       SELECT;
		        Cur1.NAME AS cFile;
		        FROM curPJX AS Cur1;
		        INTO CURSOR curW;
		        WHERE TYPE=='W'
		
		       IF RECCOUNT()=0 OR EMPTY(cFile) THEN
		        lcFile    = ''
		       ELSE  &&RECCOUNT()=0
		        lcFile    = ADDBS(JUSTPATH(m.lcFile))+ALLTRIM(cFile)
		       ENDIF &&RECCOUNT()=0
		
		       IF !EMPTY(m.lcFile) THEN
		        lnOffset = m.lnOffset+1
		        DIMENSION;
		         laFiles2(m.lnOffset,4)
		
		        loSett      = THIS.oGet_Setting(JUSTPATH(m.lcFile),m.loConverter)
		        lcSourceExt = m.loSett.c_VC2
		
		        laFiles2(m.lnOffset,1) = FORCEEXT(m.lcFile,m.lcSourceExt)			&& Source File of transformation; Bin
		        laFiles2(m.lnOffset,2) = m.lcMode									&& not a project file
		        laFiles2(m.lnOffset,3) = 0											&& has no hook
		       ENDIF &&!EMPTY(m.lcFile)
		      ENDIF &&laFiles(m.lnFile,4)>1
		
		      IF m.llPJXUsed THEN
		       USE IN curPJX
		       USE IN curW
		       llPJXUsed = .F.
		      ENDIF &&m.llPJXUsed
		     ENDIF &&FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX'
		
		*/search for project hooks
		    ENDFOR &&lnFile
		
		*!*	Changed by: SF 11.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-11,20:50:00}">Changed by: SF<br />
		*!* <expr>NOPROJECTHOOK</expr> will open the hook, but not use. So it fails with libray not existing
		*!*	</change>
		*!*	</pdm>
		
		*!*	/Changed by: SF 11.6.2015
		
		    IF m.lnOffset>0 THEN
		     ACTIVATE SCREEN
		
		     DIMENSION;
		      laToConvert(m.lnOffset,3)
		
		* files in parameters section
		* must be show, because they are processed
		     FOR lnConvert = 1 TO m.lnOffset
		      laToConvert(m.lnConvert,1) = laFiles2(m.lnConvert,1)
		      laToConvert(m.lnConvert,2) = laFiles2(m.lnConvert,2)
		      laToConvert(m.lnConvert,3) = .T.
		     ENDFOR &&lnConvert
		
		     ?"Post processing Project-Hooks and Databases DBF's:"
		     llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		
		     DIMENSION;
		      laFiles2(1,1)
		*just rework hooks and DBF's in storage table
		     IF loConverter.Get_Processed(@laFiles2)#0 THEN
		      THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,.F.,m.lcStorage,m.loConverter)
		     ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		    ENDIF &&m.lnOffset>0
		
		   ELSE  &&!ISNULL(m.lcStorage)
		    llProcess = THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,m.tlCheckAll,m.lcStorage,m.loConverter)
		    DO CASE
		     CASE ISNULL(m.llProcess)
		*need to process all files -> just let FoxBin2PRG do, faster.
		      DIMENSION;
		       laToConvert(ALEN(m.laFiles,1),3)
		
		* must be show, because they are processed
		      FOR lnConvert = 1 TO ALEN(m.laFiles,1)
		       laToConvert(m.lnConvert,1) = laFiles(m.lnConvert,1)
		       laToConvert(m.lnConvert,2) = laFiles(m.lnConvert,2)
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		     CASE m.llProcess
		*If not processed in first loop, process now, file by file.
		      loConverter.l_ProcessFiles            = .T.
		      loConverter.l_AutoClearProcessedFiles = .T.
		
		      lnFiles  = ALEN(m.laFiles2,1)
		*just set "not a project"
		      FOR lnFile = 1 TO m.lnFiles
		       laFiles2(m.lnFile,2) = m.lcMode
		      ENDFOR &&lnFile
		      DIMENSION;
		       laToConvert(ALEN(m.laFiles2,1),3)
		
		      FOR lnConvert = 1 TO ALEN(m.laFiles2,1)
		       laToConvert(m.lnConvert,1) = laFiles2(m.lnConvert,1)
		       laToConvert(m.lnConvert,2) = laFiles2(m.lnConvert,2)
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnOffsets,m.toFB2T_Setting)
		    ENDCASE
		
		   ENDIF &&!ISNULL(m.lcStorage)
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:40:00}">Changed by: SF<br />
		*!*	Code to delte / backup text files no more needed.
		*!*	</change>
		*!*	</pdm>
		
		   IF _SCREEN.gcB2T_Delete=="1" THEN
		*Delete obsolete classes from classlibs
		    SELECT (m.lcStorage)
		*sfx todo SQL
		    SCAN FOR iDirty=-1
		
		     loSett      = THIS.oGet_Setting(JUSTPATH(cFile),m.loConverter)
		     lcSourceExt = UPPER(JUSTEXT(cFile))
		
		     DO CASE
		      CASE UPPER(m.lcSourceExt)=="VCX"
		       lcSourceExt = m.loSett.c_VC2
		      CASE UPPER(m.lcSourceExt)=="FRX"
		       lcSourceExt = m.loSett.c_FR2
		      CASE UPPER(m.lcSourceExt)=="MNX"
		       lcSourceExt = m.loSett.c_MN2
		      CASE UPPER(m.lcSourceExt)=="DBF"
		       lcSourceExt = m.loSett.c_DB2
		      CASE UPPER(m.lcSourceExt)=="DBC"
		       lcSourceExt = m.loSett.c_DC2
		      CASE UPPER(m.lcSourceExt)=="PJX"
		       lcSourceExt = m.loSett.c_PJ2
		      CASE UPPER(m.lcSourceExt)=="LBX"
		       lcSourceExt = m.loSett.c_LB2
		      CASE UPPER(m.lcSourceExt)=="SCX"
		*Fehler: c_CC2 statt c_SC2
		       lcSourceExt = m.loSett.c_SC2
		*Additional extensions
		      CASE UPPER(m.lcSourceExt)=="FKY"
		       lcSourceExt = m.loSett.c_FK2
		      CASE UPPER(m.lcSourceExt)=="MEM"
		       lcSourceExt = m.loSett.c_ME2
		      OTHERWISE
		       LOOP
		     ENDCASE
		
		     lcFile = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		      EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		     DO CASE
		      CASE !FILE(m.lcFile)
		*nothing found, nothing to do
		      CASE m.loSett.n_ExtraBackupLevels>0
		*Backup (only one level deep)
		       lcSourceExt = m.lcSourceExt+'.Del.Bak'
		       lcTarget = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		        EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		       IF FILE(m.lcTarget) THEN
		        DELETE FILE &lcTarget
		       ENDIF &&FILE(m.lcTarget)
		       RENAME &lcFile TO &lcTarget
		
		      OTHERWISE
		*Delete
		       DELETE FILE &lcFile
		     ENDCASE
		*sfx todo SQL
		     REPLACE;
		      iDirty WITH -2
		    ENDSCAN &&iDirty=-1
		   ENDIF &&_SCREEN.gcB2T_Delete=="1"
		*!*	/Changed by: SF 4.6.2015
		
		  ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		 ELSE  &&NVL(!m.tlIncludeAll,True)
		
		*!*	Changed by: SF 11.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-11,20:50:00}">Changed by: SF<br />
		*!* <expr>NOPROJECTHOOK</expr> will open the hook, but not use. So it fails with libray not existing
		*!*	</change>
		*!*	</pdm>
		
		  DIMENSION;
		   laFiles2(1,4)
		
		  lnOffset = 0
		
		*search for DBF's of DBC's
		  IF m.llExpandDBC THEN
		   THIS.Get_DBC_Tables(@laFiles,@taFiles,@laFiles2,@lnOffset,m.lcMode,.T.,m.loConverter)
		  ENDIF &&m.llExpandDBC
		*/search for DBF's of DBC's
		
		  IF m.lnOffset>0 THEN
		   ACTIVATE SCREEN
		   DIMENSION;
		    laToConvert(m.lnOffset,3)
		
		* files in parameters section
		* must be show, because they are processed
		   FOR lnConvert = 1 TO m.lnOffset
		    laToConvert(m.lnConvert,1) = laFiles2(m.lnConvert,1)
		    laToConvert(m.lnConvert,2) = laFiles2(m.lnConvert,2)
		    laToConvert(m.lnConvert,3) = .T.
		   ENDFOR &&lnConvert
		
		   ?"Post processing Databases DBF's"
		   llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		
		   DIMENSION;
		    laFiles2(1,1)
		*just rework hooks and DBF's in storage table
		   IF loConverter.Get_Processed(@laFiles2)#0 THEN
		    THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,.F.,m.lcStorage,m.loConverter)
		   ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		  ENDIF &&m.lnOffset>0
		
		*!*	/Changed by: SF 11.6.2015
		
		 ENDIF &&NVL(!m.tlIncludeAll,True)
		ENDIF &&m.llFound
		
		loConverter.UnloadProgressbarForm()
		loConverter =  NIL
		
		THIS.Storage_Close(m.lcStorage,m.llFound)
		
		ACTIVATE SCREEN
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&!m.llFound
		 ?""
		ENDIF &&!m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE process_txt2bin_dir		&& Process all directories of a given array to binary. Storage not used.
		LPARAMETERS;
		 taFiles,;
		 tlText2Bin,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="taFiles" type="Array" byref="1" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.<br />
		*Will be passed to <see pem="Convert" /></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		
		LOCAL;
		 lcStorage   AS STRING,;
		 llFound     AS BOOLEAN,;
		 lnFile      AS NUMBER,;
		 lnOffsets   AS NUMBER,;
		 loConverter AS OBJECT,;
		 lvTime      AS VARIANT
		
		EXTERNAL ARRAY;
		 taFiles
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 lnFiles
		
		STORE ALEN(m.taFiles,2) TO;
		 lnCols
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,3)
		
		lnOffsets = 0
		
		FOR lnFile = 1 TO m.lnFiles
		 DO CASE
		  CASE m.taFiles(m.lnFile,1)='.'
		  CASE m.taFiles(m.lnFile,1)='..'
		  CASE !DIRECTORY(m.taFiles(m.lnFile,1))
		  OTHERWISE
		
		   lnOffsets              = m.lnOffsets+1
		   laFiles(m.lnOffsets,1) = m.taFiles(m.lnFile,1)
		   laFiles(m.lnOffsets,2) = "PRG2BIN"
		   laFiles(m.lnOffsets,3) = .T.
		
		 ENDCASE
		ENDFOR &&lnfile
		
		IF m.lnOffsets>0 THEN
		 LOCAL ARRAY;
		  laFiles(m.lnOffsets,3)
		
		 m.loConverter.LoadProgressbarForm()
		 ACTIVATE SCREEN
		
		 ?'Processing:'
		 llFound = THIS.Convert(@laFiles,.T.,m.loConverter,0,m.toFB2T_Setting)
		
		 m.loConverter.UnloadProgressbarForm()
		ENDIF &&m.lnOffsets>0
		
		loConverter =  NIL
		
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&m.llFound
		 ?""
		ENDIF &&m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE storage_check		&& Check for valid  storage settings, alter settings
		LPARAMETERS;
		 tlInterActive,;
		 tcHomePath
		
		*!*	<pdm>
		*!*	<descr>Check program settings.</descr>
		*!*	<params name="tlInterActive" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Interactive settings.</short>
		*!*	<detail>display the parent form to change the settings.</detail>
		*!*	</params>
		*!*	<params name="tcHomePath" type="Character" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Home path of he actual VFP IDE.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">
		*Alias of the storage table. <expr>.NULL.</expr> if error or <pdmpara num="1" />.
		*</retval>
		*!*	<remarks>
		*<p>Opens the storage file and read settings. Test if settings are existing, not if valid.</p>
		*<p>If set <pdmpara num="1" /> the form will be opened to change and store settings.</p>
		*<p>The storage file will kept open if not <pdmpara num="1" />, the alias will be returned if open.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile     AS CHARACTER,;
		 lcStorage  AS CHARACTER,;
		 llWrite    AS BOOLEAN,;
		 llError    AS BOOLEAN,;
		 loSetting  AS EMPTY,;
		 loSettings AS COLLECTION
		
		IF PCOUNT()>1 AND VARTYPE(tcHomePath)='C' THEN
		*Storage_Location works different with parameter set
		 lcFile    = THIS.Storage_Location(m.tcHomePath)
		ELSE  &&PCOUNT()>1 AND VARTYPE(tcHomePath)='C'
		 lcFile    = THIS.Storage_Location()
		ENDIF &&PCOUNT()>1 AND VARTYPE(tcHomePath)='C'
		
		IF ISNULL(m.lcFile) THEN
		 llError = True
		ELSE  &&ISNULL(m.lcFile)
		
		 lcStorage = THIS.Storage_Open(m.lcFile)
		
		 IF ISNULL(m.lcStorage) THEN
		  llError = True
		 ELSE  &&ISNULL(m.lcStorage)
		
		  loSettings = NEWOBJECT('collection')
		  THIS.Storage_Get("S",m.loSettings,m.lcStorage)
		
		*Storage Path
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Path",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',TRIM(m.lcFile))
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Path")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Path",5)
		
		*get FoxBin2Prg.prg
		  llWrite = THIS.Storage_Check_Bin2Prg(@loSettings,@llError) OR m.llWrite
		
		*GUI Path
		  IF !PEMSTATUS(_SCREEN,"gcB2T_GUI",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"gitk.exe")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_GUI")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_GUI",5)
		
		*auto commit [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Commit",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Commit")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Commit",5)
		
		*on git: Include pjx in run [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_GitPjx",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_GitPjx")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_GitPjx",5)
		
		*Include DBF of DBC [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_DBC",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_DBC")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_DBC",5)
		
		*optimize process [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Opt",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Opt")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Opt",5)
		
		*Delete files of classes removed [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Delete",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Delete")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Delete",5)
		
		*Use bash for git operations [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_UseBash",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_UseBash")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_UseBash",5)
		
		*Default config file for FoxBin2Prg
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Config",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Config")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_UseBash",5)
		
		*Default config file for FoxBin2Prg
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Log",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Log")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_UseBash",5)
		
		  IF !m.llError AND m.tlInterActive THEN
		*Interactive
		   _SCREEN.ADDPROPERTY("glSet",False)
		
		*run interactive form
		   THIS.PARENT.Storage_Get(m.loSettings)
		   THIS.PARENT.SHOW(1)
		   THIS.PARENT.Storage_Put(m.loSettings)
		
		   llWrite = loSettings.ITEM("glSet")
		   loSettings.REMOVE("glSet")
		
		  ENDIF  &&!m.llError AND !ISNULL(m.lcStorage) AND m.tlInterActive
		 ENDIF &&ISNULL(m.lcStorage)
		ENDIF  &&ISNULL(m.lcFile)
		
		IF m.llError THEN
		 lcStorage = NIL
		 THIS.Storage_Close(m.lcStorage,.T.)
		ELSE  &&m.llError
		 IF m.llWrite THEN
		  IF !USED(m.lcStorage) THEN
		   lcStorage = THIS.Storage_Open(m.lcFile)   
		  ENDIF &&!USED(m.lcStorage) 
		  THIS.Storage_Set("S",m.loSettings,m.lcStorage)
		
		 ENDIF &&m.llWrite
		 IF m.tlInterActive THEN
		  THIS.Storage_Close(m.lcStorage,.T.)
		  lcStorage = NIL
		 ENDIF &&m.tlInterActive
		ENDIF &&m.llError
		
		RETURN m.lcStorage
		
	ENDPROC

	PROCEDURE storage_check_bin2prg		&& Check location of FoxBin2Prg.
		LPARAMETERS;
		 toSettings AS COLLECTION,;
		 tlError
		
		*!*	<pdm>
		*!*	<descr>Check if FoxBin2PRG is found, locate.</descr>
		*!*	<params name="toSettings" type="COLLECTION" byref="1" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail>Object with settings.</detail>
		*!*	</params>
		*!*	<params name="tlError" type="Boolean" byref="1" dir="" inb="0" outb="0">
		*!*	<short>Error</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<remarks>Tries to load FoxBin2Prg from Thor by default.</remarks>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 18.5.2023 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile       AS STRING,;
		 lcFoxBin2PRG AS STRING,;
		 lnLoop       AS INTEGER,;
		 llSearch     AS BOOLEAN,;
		 loSetting    AS EMPTY
		
		*Try .. EndTry bei IntelliScript
		*!*	LOCAL;
		*!*	 llError     AS BOOLEAN,;
		*!*	 loException AS EXCEPTION
		
		*!*	TRY
		*!*	*Was zu testen ist
		*!*	  lcFoxBin2PRG = NVL(EXECSCRIPT(_SCREEN.cThorDispatcher, 'Thor_Proc_GetFoxBin2PrgFolder'),'')
		*!*	 CATCH
		*!*	* Abzufangender Fehler
		*!*	  lcFoxBin2PRG = ""
		*!*	ENDTRY
		
		llSearch = False
		DO CASE
		*!*	Changed by: SF 18.10.2024
		*!*	<pdm>
		*!*	<change date="{^2024-10-18,20:30:00}">Changed by: SF<br />
		*!*	On not existing Bin2Text table, system failed to create itself #7 (auerswald)
		*!*	Property not declared
		*!*	</change>
		*!*	</pdm>
		 CASE  !PEMSTATUS(_SCREEN,"gcB2T_FB2T",5)
		*FoxNin2Prg nicht in den Eigenschaften
		  llSearch = True
		
		  loSetting = CREATEOBJECT('EMPTY')
		  ADDPROPERTY(m.loSetting,'gcFile',m.lcFile)
		  ADDPROPERTY(m.loSetting,'gcUniqueId',"gcB2T_FB2T")
		  toSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		  lcFile   = ""
		*!*	/Changed by: SF 18.10.2024
		
		 CASE EMPTY(_SCREEN.gcB2T_FB2T)
		*FoxBin2Prg nicht defined
		  llSearch = True
		
		*!*	 CASE!EMPTY(m.lcFoxBin2PRG) AND !UPPER(_SCREEN.gcB2T_FB2T)==UPPER(m.lcFoxBin2PRG+'FoxBin2Prg.prg') AND FILE(m.lcFoxBin2PRG+'FoxBin2Prg.prg')
		*!*	*force Thor install
		*!*	  llSearch = False
		*!*	  _SCREEN.gcB2T_FB2T = m.lcFoxBin2PRG+'FoxBin2Prg.prg'
		  lcFile = _SCREEN.gcB2T_FB2T
		
		 CASE !FILE(_SCREEN.gcB2T_FB2T)
		*Feile not found
		  llSearch = True
		  MESSAGEBOX('FoxBin2PRG not found in'+0h0D0A+;
		   '"'+_SCREEN.gcB2T_FB2T+'".'+0h0D0A0D0A+;
		   'Bin2Text not running.',0,'Bin2Text v'+dcB2T_Verno)
		
		 OTHERWISE
		*all ok
		  llSearch = False
		
		ENDCASE
		
		IF m.llSearch THEN
		*new install
		 lcFile = ''
		*!*	Changed by: SF 22.10.2024
		*!*	<pdm>
		*!*	<change date="{^2024-10-22,15:44:00}">Changed by: SF<br />
		*!*	Better integration with Thor, use FoxBin2Prg of Thor if installed.
		*!*	</change>
		*!*	</pdm>
		
		 IF PEMSTATUS(_SCREEN,"cThorDispatcher",5) AND VARTYPE(_SCREEN.cThorDispatcher)='C' AND !EMPTY(_SCREEN.cThorDispatcher) THEN
		  lcFile = EXECSCRIPT(_SCREEN.cThorDispatcher,'Thor_Proc_GetFoxBin2PrgFolder')	&&+'FoxBin2Prg.exe'
		 ENDIF &&PEMSTATUS(_Screen,"cThorDispatcher",5) AND VARTYPE(_Screen.cThorDispatcher)='C' AND !EMPTY(_Screen. ...
		 IF EMPTY(m.lcFile) THEN
		  lcFile = ""
		 ELSE  &&EMPTY(m.lcFile)
		  llSearch = .F.
		 ENDIF &&EMPTY(m.lcFile)
		
		 IF m.llSearch THEN
		  IF FILE("FoxBin2PRG.prg") THEN
		*in search path
		   lcFile = FULLPATH("FoxBin2PRG.prg")
		  ELSE  &&FILE("FoxBin2PRG.prg")
		*search start
		   lnLoop = 1
		   lcFile = SYS(16,m.lnLoop)
		
		   DO WHILE LEN(m.lcFile)>0
		
		    IF UPPER(JUSTEXT(m.lcFile)) = "APP" THEN
		     IF m.lcFile="PROCEDURE " THEN
		      lcFile = ADDBS(JUSTPATH(STREXTRACT(m.lcFile,' ',' ',2,2)))
		     ELSE  &&m.lcFile="PROCEDURE "
		      lcFile = JUSTPATH(m.lcFile)
		     ENDIF &&m.lcFile="PROCEDURE "
		     EXIT
		    ENDIF &&UPPER(JUSTEXT(m.lcFile)) = "APP"
		
		    IF UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="BIN2PRG";
		      OR UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="INTER_ACTIVE" THEN
		     lcFile = ADDBS(JUSTPATH(STREXTRACT(m.lcFile,' ',' ',2,2)))
		     EXIT
		    ENDIF &&UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="BIN2PRG" OR UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="INTER_ACTIVE"
		    lnLoop = m.lnLoop+1
		    lcFile = SYS(16,m.lnLoop)
		   ENDDO &&LEN(m.lcFile)>0
		
		  ENDIF &&FILE("FoxBin2PRG.prg")
		 ENDIF &&m.llSearch
		
		*!*	/Changed by: SF 22.10.2024
		
		*Try .. EndTry bei IntelliScript
		 LOCAL;
		  loException AS EXCEPTION
		
		 lcFile = FORCEPATH("FoxBin2PRG.prg",m.lcFile)
		 TRY
		*Was zu testen ist
		   lcFile = LOCFILE(m.lcFile,'prg')
		  CATCH TO m.loException
		   tlError = True
		  FINALLY
		*
		 ENDTRY
		
		 IF !FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG" THEN
		  tlError = True
		  lcFile  = ''
		  MESSAGEBOX('FoxBin2PRG not found,'+0h0D0A0D0A+;
		   'Bin2Text not running.',0,'Bin2Text v'+dcB2T_Verno)
		 ENDIF &&!FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG"
		
		ENDIF &&m.llSearch
		
		IF m.llSearch OR !EMPTY(m.lcFile) THEN
		 IF toSettings.GETKEY("gcB2T_FB2T")>0 THEN
		*File defined but not found
		  toSettings.REMOVE("gcB2T_FB2T")
		 ENDIF &&toSettings.GetKey("gcB2T_FB2T")>0
		
		 loSetting = CREATEOBJECT('EMPTY')
		 ADDPROPERTY(m.loSetting,'gcFile',TRIM(m.lcFile))
		 ADDPROPERTY(m.loSetting,'gcUniqueId',"gcB2T_FB2T")
		 toSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		ENDIF &&m.llSearch OR !EMPTY(m.lcFile)
		*/get FoxBin2Prg.prg
		
	ENDPROC

	PROCEDURE storage_close		&& Close the storage file.
		LPARAMETERS;
		 tcStorage,;
		 tlReset
		
		*!*	<pdm>
		*!*	<descr>Close / reset storage table.</descr>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias to close.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlReset" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Reset dirty flag.</short>
		*!*	<detail>
		*The dirty flag of the Master record will be reset.
		*If not reset next call of <see pem="Storage_Open" /> will delete all records not of type master or setting.
		*</detail>
		*!*	</params>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		
		IF USED(NVL(m.tcStorage,'')) THEN
		 IF m.tlReset THEN
		*reset heart beat
		  UPDATE Cur1 SET;
		   iDirty    = 0,;
		   tLastUse  = DATETIME();
		   FROM (m.tcStorage) AS Cur1;
		   WHERE Cur1.cType=="X"
		 ENDIF &&m.tlReset
		
		 USE IN (m.tcStorage)
		ENDIF &&USED(m.tcStorage)
		
	ENDPROC

	PROCEDURE storage_get		&& Get settings information out of storage
		LPARAMETERS;
		 tcType,;
		 toSettings AS COLLECTION,;
		 tcStorage,;
		 tcWhere
		
		*!*	<pdm>
		*!*	<descr>Get settings from storage file.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to get settings value.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSettings" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object to write.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias of the storage table.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcWhere" type="Character" byref="0" dir="" inb="1" outb="1">
		*!*	<short>Expression for WHERE.</short>
		*!*	<detail>Used to filter records, in special the DBF for additional index per DBF (cType I).</detail>
		*!*	</params>
		*!*	<retval type="Boolean">At least one setting found.</retval>
		*!*	<remarks>
		*<p>Every record in <pdmpara num="3" /> marked with <pdmpara num="1" /> will be read
		*and stored into <pdmpara num="2" />.</p>
		*<p><pdmpara num="2" /> will be cleared before read.</p>
		*<p>For every item in <pdmpara num="2" /> a property of <expr>_SCREEN</expr> will be created.
		*Form: <expr>_SCREEN.ADDPROPERTY(TRIM(cUniqueID),TRIM(cFile))</expr></p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 llOk      AS BOOLEAN,;
		 loSetting AS EMPTY
		
		IF EMPTY(m.tcWhere) THEN
		 tcWhere = ''
		ELSE  &&EMPTY(m.tcWhere)
		 tcWhere = 'AND '+m.tcWhere
		ENDIF &&EMPTY(m.tcWhere) 
		
		SELECT;
		 Cur1.cFile,;
		 Cur1.cUniqueId;
		 FROM (m.tcStorage) AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cType==m.tcType;
		 &tcWhere
		
		llOk = RECCOUNT()>0
		toSettings.REMOVE(-1)
		SCAN
		 loSetting = CREATEOBJECT('EMPTY')
		 ADDPROPERTY(loSetting,'gcFile',TRIM(cFile))
		 ADDPROPERTY(loSetting,'gcUniqueId',TRIM(cUniqueId))
		
		 toSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		 _SCREEN.ADDPROPERTY(m.loSetting.gcUniqueId,m.loSetting.gcFile)
		ENDSCAN
		
		USE IN SELECT('curHelp')
		
		RETURN m.llOk
		
	ENDPROC

	PROCEDURE storage_location		&& Get location for storage file.
		LPARAMETERS;
		 tcHomePath
		
		*!*	<pdm>
		*!*	<descr>Gets location for storage file</descr>
		*!*	<params name="tcHomePath" type="Character" byref="0" dir="" inb="1" outb="1">
		*!*	<short>Home path of he actual VFP IDE.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">
		*<p>Storage file if set by <pdmpara num="1" />, else if found, if not found best guess off directory.</p>
		*<p><expr>.NULL.</expr> if failed.</p>
		*</retval>
		*!*	<comment>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile AS CHARACTER
		
		DO CASE
		 CASE PCOUNT()>0 AND !VARTYPE(tcHomePath)="C"
		  lcFile = NIL
		 CASE PCOUNT()>0 AND !DIRECTORY(m.tcHomePath)
		  lcFile = NIL
		 CASE PCOUNT()>0 AND Is_git(m.tcHomePath)
		  lcFile = FORCEPATH('Bin2Txt.DBF',GetGitBaseDir(m.tcHomePath))
		 CASE PCOUNT()>0
		  lcFile = FORCEPATH('Bin2Txt.DBF',m.tcHomePath)
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		* we say we have a settings file
		  lcFile = _SCREEN.gcB2T_Path
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C';
		   AND FILE(FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path))
		* we say we have a settings file
		  lcFile = FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path)
		
		*o.k.
		*nothing
		*so start guesswork
		
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND DIRECTORY(_SCREEN.gcB2T_Path)
		* we say we have a settings locawe define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path)
		 CASE FILE(FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR())))
		* we say we have a settings file
		  lcFile = FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR()))
		 CASE _VFP.PROJECTS.COUNT>0
		* we say we have a settings loca, we define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',JUSTPATH(_VFP.ACTIVEPROJECT.NAME))
		 OTHERWISE
		*no more guesses, we define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR()))
		ENDCASE
		
		IF !ISNULL(m.lcFile) AND Is_git(JUSTPATH(m.lcFile)) THEN
		*the storage table should not be under git control, in case create / modify .gitignore
		 LOCAL;
		  lcX AS CHARACTER,;
		  lcY AS CHARACTER,;
		  lcZ AS CHARACTER
		
		 lcX = FORCEPATH('.gitignore',JUSTPATH(m.lcFile))
		 lcY = LOWER(FORCEEXT(JUSTFNAME(m.lcFile),"*"))
		 IF FILE(lcX) THEN
		  lcZ = FILETOSTR(lcX)
		  IF !lcY$lcZ THEN
		   IF 0h0D0A$lcZ THEN
		    lcZ = lcZ+0h0D0A+lcY
		   ELSE  &&0h0D0A$lcZ
		    lcZ = lcZ+0h0A+lcY
		   ENDIF &&0h0D0A$lcZ
		   STRTOFILE(lcZ,lcX)
		  ENDIF &&!lcx$lcy
		 ELSE &&FILE(lcIgnore)
		  STRTOFILE(lcY,lcX)
		 ENDIF &&FILE(lcX)
		ENDIF &&!ISNULL(m.lcFile) AND Is_git(JUSTPATH(m.lcFile))
		
		RETURN m.lcFile
		
	ENDPROC

	PROCEDURE storage_open		&& Opens the storage file.
		LPARAMETERS;
		 tcFile
		
		*!*	<pdm>
		*!*	<descr>Opens / create storage table.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>File to open or create.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">Alias of the storage table. <expr>.NULL.</expr> if error.</retval>
		*!*	<remarks>
		*</remarks>
		*<remarks>
		*<p>Table structure of the storage table</p>
		* <table border="1" cellspacing="0">
		*  <thead>
		*   <tr>
		*    <td>Field</td><td>type</td><td>usage</td>
		*   </tr>
		*  </thead>
		*  <tbody>
		*  <tr>
		*  <td>cType</td>
		*  <td>c(1)</td>
		*  <td>
		*   <p>A flag to mark the type of the record. Derived from SCCText / PJX</p>
		*   <p>Not supported types of PJX:
		*   H = Header, L = Library (DLL/FLL), P = Program, Q = Query, T = Text, X = other File, Z = Application</p>
		*   <p>Type W (Project Hook) of PJX is mapped to V/v.</p>
		*   <table border="1" cellspacing="0">
		*    <thead>
		*      <tr><td>Value</td><td>usage</td></tr>
		*    </thead>
		*    <tr><td>B</td><td>Label / </td></tr>
		*    <tr><td>D</td><td>Table / DBF</td></tr>
		*    <tr><td>d</td><td>Database / DBC</td></tr>
		*    <tr><td>K</td><td>Form / SCX</td></tr>
		*    <tr><td>k</td><td>Object of a Form</td></tr>
		*    <tr><td>M</td><td>Menu / MNX</td></tr>
		*    <tr><td>P</td><td>Project / PJX</td></tr>
		*    <tr><td>R</td><td>Report / FRX</td></tr>
		*    <tr><td>V</td><td>Classlibrary / VCX</td></tr>
		*    <tr><td>v</td><td>Class of a Classlibrary</td></tr>
		*    <tr><td></td><td><u>Other:</u></td></tr>
		*    <tr><td>f</td><td>Macro / FKY</td></tr>
		*    <tr><td>m</td><td>Variable file / MEM</td></tr>
		*    <tr><td></td><td><u>Internal:</u></td></tr>
		*    <tr><td>A</td><td>Additional file to process in <i>git commit All</i></td></tr>
		*    <tr><td>S</td><td>Setting</td></tr>
		*    <tr><td><b>X</b></td><td><b>Heart beat check</b></td></tr>
		*    </table>
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>cFile</td>
		*   <td>c(240)</td>
		*   <td>File to process. Allways the binary file, except for settings.</td>
		*  </tr>
		*  <tr>
		*   <td>cObjName</td>
		*   <td>c(240)</td>
		*   <td>For v and k records, the ObjName field of the vcx / scx.<br/>For A records, descriptive name.</td>
		*  </tr>
		*  <tr>
		*   <td>cUniqueID</td>
		*   <td>c(16)</td>
		*   <td>Something to identify the change status, timestamp field CRC etc.<br/>
		*    For settings record: date described.<br/>
		*    For Additional files record: UniqueID to identify record.<br/>
		*    For Heart beat Record: Version number of the table.
		*    Will be compared with internal number for structural changes.
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>iDirty</td>
		*   <td>I</td>
		*   <td>
		*   	<p>Marks an item as dirty from last run.</p>
		*    <table border="1" cellspacing="0">
		*     <tr><td colspan="2">Source; cType IN (B,D,d,f,K,k,M,m,R,V,v)</td></tr>
		*     <tr>
		*       <td>8</td>
		*       <td>
		*        Not deleted on last cleanup (full run with delete obsolete files)
		*        w/o any other action.
		*      </td>
		*     </tr>
		*     <tr><td>4</td><td>New</td></tr>
		*     <tr><td>2</td><td>Changed</td></tr>
		*     <tr><td>1</td><td>Direction to binary. Additional to other positives</td></tr>
		*     <tr><td>0</td><td>0k</td></tr>
		*     <tr><td>-1</td><td>to delete</td></tr>
		*     <tr><td>-2</td><td>deleted</td></tr>
		*     <tr><td>-3</td><td>dirty by heart beat</td></tr>
		*     <tr><td>-4</td><td>dirty by watch dog (time)</td></tr>
		*     <tr><td colspan="2">Heart beat</td></tr>
		*     <tr><td>0</td><td>ok</td></tr>
		*     <tr><td><b>1</b></td><td><b>Error. Do not compare, process all.</b></td></tr>
		*    </table>
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>tLastUse</td>
		*   <td>T</td>
		*   <td>Internal timestamp, used for garbage collection.</td>
		*  </tr>
		*  </tbody>
		* </table>
		* <p>Checks version number on opening table.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 02.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 llError     AS BOOLEAN,;
		 loException AS EXCEPTION,;
		 lnResult    AS NUMBER
		
		llError = .F.
		
		IF !FILE(m.tcFile) THEN
		 TRY
		   CREATE TABLE (m.tcFile)(;
		    cType     c(1),;
		    cFile     c(240),;
		    cObjName  c(240),;
		    cUniqueId c(16) NOCPTRANS,;
		    iDirty    I,;
		    tLastUse  T)
		   INDEX ON cType		TAG _cType
		*Like SCCTEXT.prg
		*(d = DBC, D = DBF, K = Form, B = Label, M = Menu, R = Report, V = Classlibrary)
		*additional:
		*v = Class
		*k = Form timestamp
		*X = Heart beat check
		*S = Setting
		*A = Additional files
		   INDEX ON cFile		TAG _cFile
		   INDEX ON cObjName	TAG _cObj
		   INDEX ON cUniqueId	TAG _cUni
		   INDEX ON iDirty		TAG _iDirty
		   INDEX ON tLastUse	TAG _tLast
		
		   USE
		  CATCH TO m.loException
		* andere Fehler, Standardhandler rufen
		* ToDo
		   llError = .T.
		  FINALLY
		 ENDTRY
		
		 IF m.llError THEN
		*we can't handle
		*process all
		  USE IN SELECT('Storage')
		  RETURN NIL
		 ENDIF &&m.llError
		ENDIF &&!FILE(m.tcFile)
		
		TRY
		*Was zu testen ist
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage') EXCLUSIVE
		
		  SELECT Storage
		  PACK
		 CATCH TO m.loException
		* andere Fehler, Standardhandler rufen
		* ToDo
		*dann eben kein pack, egal
		  llError = .T.
		 FINALLY
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage')
		
		ENDTRY
		
		IF m.llError THEN
		*we can't handle
		*process all
		 USE IN SELECT('Storage')
		 RETURN NIL
		ENDIF &&m.llError
		
		*check heart beat for existence (and set as error to fix problems)
		SELECT;
		 Cur1.iDirty,;
		 Cur1.cUniqueId;
		 FROM Storage AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cType=="X"
		
		IF RECCOUNT()=0 THEN
		 INSERT INTO (m.tcFile);
		  (cFile,cObjName ,cType,cUniqueId,iDirty);
		  VALUES;
		  ("Check heart beat","internal","X",dcB2T_Verno  , 2)
		
		 SELECT;
		  Cur1.iDirty,;
		  Cur1.cUniqueId;
		  FROM Storage AS Cur1;
		  INTO CURSOR curHelp;
		  WHERE Cur1.cType=="X"
		ENDIF &&RECCOUNT()=0
		
		lnResult = Compare_Verno(cUniqueId,dcB2T_Verno)
		
		DO CASE
		 CASE EMPTY(cUniqueId)
		* we assume we are on the step to 1.x
		  USE IN SELECT('Storage')
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage') EXCLUSIVE
		
		*check for misplaced Key DBF / DBC
		  SELECT Storage
		  LOCATE;
		   FOR (cType=='D';
		   AND ATC('DBC',JUSTEXT(cFile))>0);
		   OR (cType=='d';
		   AND ATC('DBF',JUSTEXT(cFile))>0)
		
		  IF FOUND() THEN
		*Version before 1.0.0
		   REPLACE;
		    ALL;
		    cType WITH ICASE(cType=='D','d',cType=='d','D',cType)
		
		   UPDATE Storage SET;
		    cUniqueId = dcB2T_Verno;
		    WHERE cType=="X"
		
		  ENDIF &&FOUND()
		
		  USE IN SELECT('Storage')
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage')
		
		 CASE m.lnResult=1
		*table is of new version
		  ?"Bin2Text"
		  ?"Storage table is not fitting to this version. Expected: "+dcB2T_Verno+", new version found: "+cUniqueId
		  ?'Table: '+DBF('Storage')
		  USE IN curHelp
		  USE IN SELECT('Storage')
		  RETURN NIL
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))==SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2))
		*known pair, go ahead (only minor change w/o dbf change)
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))='1.0' AND SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2))='1.1'
		* change storage of additional path "inkomensurabel" to relative
		  UPDATE Storage SET;
		   cFile = SYS(2014,cFile,DBF('Storage'));
		   WHERE cType=="A"
		
		*change  VerNo
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))='1.1' AND INLIST(SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2)),'1.2','1.3')
		* objectname for SCX and VCX lower, somehow freshly aLtered SCX and not cleared expose mixed case
		* just remove SCX / VCX and rerun
		*!*	Changed by SF 27.2.2023
		*!*	<pdm>
		*!*	<change date="{^2023-02-27,14:58:00}">Changed by SF<br />
		*!*	Problem with SCX just modified. Issue #4<br/>
		*!* Just remove all SCX VCX storage for simplicity
		*!*	</change>
		*!*	</pdm>
		*!*	/Changed by SF 27.2.2023
		  DELETE FROM Storage ;
		   WHERE INLIST(cType,"v","k","V","K")
		
		*change  VerNo
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))='1.0' AND INLIST(SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2)),'1.2','1.3')
		* just in case we update from 1.0 to 1.2
		* change storage of additional path "inkomensurabel" to relative
		  UPDATE Storage SET;
		   cFile = SYS(2014,cFile,DBF('Storage'));
		   WHERE cType=="A"
		
		* objectname for SCX and VCX lower, somehow freshly aLtered SCX and not cleared expose mixed case
		* just remove SCX / VCX and rerun
		  DELETE FROM Storage ;
		   WHERE INLIST(cType,"v","k","V","K")
		
		*change  VerNo
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))='1.2' AND INLIST(SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2)),'1.3')
		*just new version
		
		*change  VerNo
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2
		*table is of old version
		*update added here ....
		  ?"Bin2Text"
		  ?"Storage table is not fitting to this version. Expected: "+dcB2T_Verno+", old version found: "+cUniqueId
		  ?'Table: '+DBF('Storage')
		  USE IN curHelp
		  USE IN SELECT('Storage')
		  RETURN NIL
		
		 OTHERWISE
		* CASE m.lnResult=0
		*version fit, do nothing
		
		ENDCASE
		
		*garbage collection
		SELECT;
		 Cur1.iDirty;
		 FROM Storage AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.iDirty#0;
		 AND Cur1.cType=="X"
		
		IF RECCOUNT()=0 THEN
		*mark old files for reprocess
		 UPDATE Cur1 SET;
		  iDirty    = -4;
		  FROM Storage AS Cur1;
		  WHERE Cur1.tLastUse<=GOMONTH(DATETIME(),-3);
		  AND !(Cur1.cType=="X";
		  OR Cur1.cType=="S";
		  OR Cur1.cType=="A")
		
		ELSE  &&RECCOUNT()=0
		*heart misses a beat, all dirty
		 UPDATE Cur1 SET;
		  iDirty    = -3;
		  FROM Storage AS Cur1;
		  WHERE Cur1.tLastUse<=GOMONTH(DATETIME(),-3);
		  AND !(Cur1.cType=="X";
		  OR Cur1.cType=="S";
		  OR Cur1.cType=="A")
		
		ENDIF &&RECCOUNT()=0
		
		USE IN curHelp
		
		*Set heart beat
		UPDATE Cur1 SET;
		 iDirty    = 1,;
		 tLastUse  = DATETIME();
		 FROM Storage AS Cur1;
		 WHERE Cur1.cType=="X"
		
		RETURN 'Storage'
		
	ENDPROC

	PROCEDURE storage_set		&& Set settings information to storage.
		LPARAMETERS;
		 tcType,;
		 toSettings AS COLLECTION,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Puts settings into storage file.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to assign settings value.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSettings" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object to read.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias of the storage table.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<remarks>
		*<p>Every item of the collection <pdmpara num="2" /> will create a record in <pdmpara num="3" />
		*with key and value.</p>
		*<p>Note that lenght of key is limited to 14 signs, see <see pem="Storage_Open" />.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcKey     AS CHARACTER,;
		 lcValue   AS CHARACTER,;
		 loSetting AS EMPTY
		
		FOR EACH loSetting IN toSettings FOXOBJECT  
		
		 lcKey    = m.loSetting.gcUniqueId
		 lcValue  = m.loSetting.gcFile
		
		 _SCREEN.ADDPROPERTY(m.lcKey,m.lcValue)
		
		 UPDATE cur1 SET;
		  cFile    = m.lcValue,;
		  iDirty   = 0,;
		  tLastUse = DATETIME();
		  FROM (m.tcStorage) AS cur1;
		  WHERE cur1.cUniqueId==m.lcKey;
		  AND cur1.cType==m.tcType
		
		 IF _TALLY=0 THEN
		  INSERT INTO (m.tcStorage);
		   (cType, cFile, cUniqueId, iDirty, tLastUse);
		   VALUES;
		   (m.tcType, m.lcValue, m.lcKey, 0, DATETIME())
		 ENDIF &&_TALLY=0
		ENDFOR &&loSetting 
		
	ENDPROC

	PROCEDURE sync_file		&& Test change of checksum (crc32) for a given file (pair) against the storage table.
		LPARAMETERS;
		 tcType,;
		 tcFile,;
		 tlText2Bin,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to sync the file.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>File to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="2" /> is changed.</retval>
		*!*	<remarks>
		*<p>The method calculates the checksum for the file and it's. memo file.</p>
		*<p>This will be compared with <pdmpara num="4" /> to determine if the file is changed and need to be reprocessed.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	Changed by SF 21.10.2024
		*!*	<pdm>
		*!*	<change date="{^2024-10-21,17:56:00}">Changed by SF<br />
		*!*	Randomly the cursor curHelp is not longer the active one. This results in errors. Using Alias.Field syntax to fix
		*!*	issue #9
		*!*	</change>
		*!*	</pdm>
		*!*	/Changed by SF 21.10.2024
		 
		LOCAL;
		 lcFile2    AS STRING,;
		 lcCell     AS STRING,;
		 lcTags     AS STRING,;
		 lcDataBase AS STRING,;
		 lnStep     AS NUMBER,;
		 llDirty    AS BOOLEAN,;
		 llRecall   AS BOOLEAN,;
		 llWithCDX  AS BOOLEAN
		
		LOCAL;
		 llError     AS BOOLEAN,;
		 loException AS EXCEPTION
		
		LOCAL ARRAY;
		 laFiles(1,5)
		
		* we only check the taginfo of the cdx, the data of the index itself will not be stored anyway.
		* no handling of additional CDX or IDX
		* I'm  not shure with the memo, my guess is, it will alter the table too but I'm to lazy to check :)
		lcTags =  ""
		DO CASE
		 CASE m.tcType="V"
		  lcFile2 = FORCEEXT(m.tcFile,'vct')
		 CASE m.tcType="R"
		  lcFile2 = FORCEEXT(m.tcFile,'frt')
		 CASE m.tcType="M"
		  lcFile2 = FORCEEXT(m.tcFile,'mnt')
		 CASE m.tcType="P"
		  lcFile2 = FORCEEXT(m.tcFile,'pjt')
		 CASE m.tcType="K"
		  lcFile2 = FORCEEXT(m.tcFile,'sct')
		 CASE m.tcType="D"
		  lcFile2 = FORCEEXT(m.tcFile,'fpt')
		*figure out tags, we just store the taginfo
		  LOCAL ARRAY;
		   laTags(1,6)
		  laTags = ''
		
		  SELECT 0
		  USE (m.tcFile) ALIAS cur_Tags
		  lcDataBase = CURSORGETPROP("Database")
		
		  ATAGINFO(laTags)
		
		  USE IN SELECT('cur_Tags')
		  IF !EMPTY(m.lcDataBase) AND EMPTY(DBC()) THEN
		   SET DATABASE TO (m.lcDataBase)
		   CLOSE DATABASES
		  ENDIF &&!EMPTY(m.lcDataBase) AND EMPTY(DBC())
		
		  FOR EACH lcCell IN m.laTags
		   lcTags = lcTags+lcCell
		  ENDFOR &&lcTemp
		
		  RELEASE;
		   laTags
		
		 CASE m.tcType="d"
		  lcFile2 = FORCEEXT(m.tcFile,'dct')
		*figure out tags, we just store the taginfo
		  LOCAL ARRAY;
		   laTags(1,6)
		  laTags = ''
		
		  SELECT 0
		  USE (m.tcFile) ALIAS cur_Tags
		
		  ATAGINFO(laTags)
		
		  USE IN SELECT('cur_Tags')
		  FOR EACH lcCell IN m.laTags
		   lcTags = lcTags+lcCell
		  ENDFOR &&lcTemp
		
		  RELEASE;
		   laTags
		
		 CASE m.tcType="B"
		  lcFile2 = FORCEEXT(m.tcFile,'lbt')
		 CASE m.tcType="f"
		  lcFile2 = FORCEEXT(m.tcFile,'fky')
		 CASE m.tcType="m"
		  lcFile2 = FORCEEXT(m.tcFile,'mem')
		ENDCASE
		
		*set anything "ok" that was processed by last run
		lnDirty = IIF(m.tlText2Bin,1,0)
		UPDATE Cur1 SET;
		 iDirty   = m.lnDirty,;
		 tLastUse = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		 AND Cur1.cType==m.tcType;
		 AND Cur1.iDirty>=0
		
		*!*	Changed by: SF 5.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,13:09:00}">Changed by: SF<br />
		*!*	do not delete a file mark for delation (because it is not obsolete)
		*!*	</change>
		*!*	</pdm>
		
		*set files marked as "to delete" by "all cleanup" as "not to delete"
		*because file possibly exists (no existing will be parsed out below)
		lnDirty = IIF(m.tlText2Bin,9,8)
		UPDATE Cur1 SET;
		 iDirty    = m.lnDirty,;
		 tLastUse  = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		 AND Cur1.cType==m.tcType;
		 AND Cur1.iDirty=-1
		
		*!*	/Changed by: SF 5.6.2015
		
		*only to process per class, iff UseClassPerFile
		llRecall = INLIST(m.tcType,'V','K') AND _TALLY>0
		
		*create data
		SELECT;
		 Cur1.cUniqueId,;
		 Cur1.iDirty;
		 FROM (m.tcStorage) AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cFile==m.tcFile;
		 AND Cur1.cType==m.tcType
		
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE m.lnStep=1 AND RECCOUNT("curHelp")=0   &&unknown, create
		   llDirty = True
		
		   lnDirty = IIF(m.tlText2Bin,5,4)
		   INSERT INTO (m.tcStorage);
		    (cType, cFile, cUniqueId, iDirty, tLastUse);
		    VALUES;
		    (m.tcType, m.tcFile, m.lcFile2, m.lnDirty, DATETIME())
		*/  &&m.lnStep=1 AND RECCOUNT("curHelp")=0  &&unknown, create
		
		  CASE m.lnStep=1    &&just loop
		*/  &&m.lnStep=1   &&just loop
		
		  CASE m.lnStep=2 AND INLIST(curHelp.iDirty,-3,-4)	  &&file is marked as dirty, process dirty
		   llDirty = True
		
		   lnDirty = IIF(m.tlText2Bin,3,2)
		   UPDATE Cur1 SET;
		    cUniqueId = m.lcFile2,;
		    iDirty    = m.lnDirty,;
		    tLastUse  = DATETIME();
		    FROM (m.tcStorage) AS Cur1;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType==m.tcType
		*/ &&m.lnStep=2 AND INLIST(curHelp.iDirty,-3,-4)  &&file is marked as dirty, process dirty
		
		  CASE m.lnStep=2    &&just loop
		*/  &&m.lnStep=2   &&just loop
		
		  CASE m.lnStep=3	 	&&get file checksum
		*!*	Changed by: SF 20.5.2015
		*!*	<pdm>
		*!*	<change date="{^2015-05-20,06:44:00}">Changed by SF<br />
		*!*	Checksum changed to CRC32
		*!*	</change>
		*!*	</pdm>
		
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:00:00}">Changed by: SF<br />
		*!*	Ignore the first 4 bytes of a table. (means: bytes 1-3)<br />
		*!*	VFP seems to alter <i>Last update</i> on compile. If the rest of the table is not changed, we can ignore this.
		*!*	</change>
		*!*	</pdm>
		
		*!*	Changed by: SF 07.12.2021
		*!*	<pdm>
		*!*	<change date="{^2021-12-07,18:00:00}">Changed by: SF<br />
		*!*	https://github.com/lscheffler/bin2text/iss,ues/2<br />
		*!*	File opperation fails on too large files (unpacked something?)<br />
		*!*	Just catch the error, the file must then be processed all the time
		*!*	</change>
		*!*	</pdm>
		
		   TRY
		*Was zu testen ist
		*String might be to long
		
		     IF FILE(m.lcFile2) THEN
		*check max string lenght, pack for sources (not for table/database)
		      IF INLIST(m.tcType,"V","R","P","K","B","f") THEN
		       ADIR(laFiles,m.tcFile)
		       lnFileSize = laFiles(1,2)
		       ADIR(laFiles,m.lcFile2)
		       IF 16777184<m.lnFileSize+laFiles(1,2) THEN
		        SELECT 0
		        USE (m.tcFile) ALIAS cur_Tags EXCLUSIVE
		        PACK
		       ENDIF &&16777184<m.lnFileSize+laFiles(1,2)
		      ENDIF &&INLIST(m.tcType,"V","R","P","K","B","f")
		
		*if (still) to large, the catch does the work
		      lcFile2 = SYS(2007,SUBSTR(FILETOSTR(m.tcFile),5)+FILETOSTR(m.lcFile2)+m.lcTags,0,1)
		
		     ELSE  &&FILE(m.lcFile2)
		      lcFile2 = SYS(2007,SUBSTR(FILETOSTR(m.tcFile),5)+m.lcTags,0,1)
		     ENDIF &&FILE(m.lcFile2)
		
		    CATCH TO loException WHEN loException.ERRORNO=1903
		* Abzufangender Fehler
		*String is too long to fit (Error 1903)
		     lcFile2 = ""
		    CATCH TO loException WHEN INLIST(loException.ERRORNO,1,3,15,1600,1705)
		* Abzufangender Fehler
		* Problem with USE
		     lcFile2 = ""
		
		    CATCH TO loException
		* andere Fehler, Standardhandler rufen
		     RAISEEVENT(THIS,'ERROR',loException.ERRORNO,loException.PROCEDURE,loException.LINENO)
		     llError = doApp.glQuitting
		    FINALLY
		*
		     USE IN SELECT('cur_Tags')
		
		   ENDTRY
		
		*!*	IF FILE(m.lcFile2) THEN
		*!*	 m.lcFile2 = SYS(2007,FILETOSTR(m.tcFile)+FILETOSTR(m.lcFile2),0,1)
		*!*	ELSE  &&FILE(m.lcFile2)
		*!*	 lcFile2 = SYS(2007,FILETOSTR(m.tcFile),0,1)
		*!*	ENDIF &&FILE(m.lcFile2)
		
		*!*	/Changed by: SF 4.6.2015
		*!*	/Changed by SF 20.5.2015
		
		*/	&&m.lnStep=3 	&&get file checksum
		
		  CASE m.lnStep=4 AND !TRIM(curHelp.cUniqueId)==m.lcFile2   	 	&&changed, process dirty
		*just do something for long files
		   lcFile2 = EVL(m.lcFile2,"File to long.")
		   llDirty = True
		
		   lnDirty = IIF(m.tlText2Bin,3,2)
		   UPDATE Cur1 SET;
		    cUniqueId = m.lcFile2,;
		    iDirty    = m.lnDirty,;
		    tLastUse  = DATETIME();
		    FROM (m.tcStorage) AS Cur1;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType==m.tcType
		*/  &&m.lnStep=4 AND !TRIM(curHelp.cUniqueId)==m.lcFile2  	 	&&changed, process dirty
		
		  OTHERWISE
		*ok
		   llDirty = False
		   EXIT
		 ENDCASE
		
		 IF m.llDirty THEN
		  EXIT
		 ELSE  &&m.llDirty
		  lnStep = m.lnStep+1
		 ENDIF &&m.llDirty
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty OR m.llRecall
		
	ENDPROC

	PROCEDURE sync_objects		&& Compares a help cursor with the storage table. Compares objects of a vcx / scx.
		LPARAMETERS;
		 tcType,;
		 tcFile,;
		 tlText2Bin,;
		 tcSource,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Compares a help cursor with the storage table.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to sync the file.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Filename</short>
		*!*	<detail>File that is handled by <self list"1" /> and decribed in <pdmpara num="4" />.</detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcSource" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source cursor.</short>
		*!*	<detail>Cursor with relevant information about the <pdmpara num="2" />.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Classes of <pdmpara num="2" /> are changed.</retval>
		*!*	<remarks>
		*<p>To scx / vcx files</p>
		*<p>This will compare the actual timestamps and uniqueeid. If anything is changed the item will be marked.</p>
		*<p>Any mark will set the file is dirty and the function returns <expr>.T.</expr>.</p>
		*<p>The iDirty (see <see pem="Storage_Open"/>) column will be set to(positive odds are a result of <pdmpara num="3" /> is true):</p>
		*<dl>
		*<dt>8/9</dt><dd>File marked by global cleanup is not to delete.</dd>
		*<dt>4/5</dt><dd>new</dd>
		*<dt>2/3</dt><dd>changed</dd>
		*<dt>0/1</dt><dd>no change</dd>
		*<dt>-1</dt><dd>ClassPerFile is to be deleted.</dd>
		*</dl>
		*<p>Type of operation as set by SCCTEXT.prg with additional flag. See <see pem="Storage_Open"/>.</p>
		*<p>
		*<dl>
		* <dt>B</dt><dd>Label (lbx)</dd>
		* <dt>D</dt><dd>Free Table (dbf)</dd>
		* <dt>d</dt><dd>Database (dbc)</dd>
		* <dt>f</dt><dd>Macro file (fky)</dd>
		* <dt>K</dt><dd>Form (scx)</dd>
		* <dt>k</dt><dd>Object of Form</dd>
		* <dt>M</dt><dd>Menu (mnx)</dd>
		* <dt>m</dt><dd>Variable file (mem)</dd>
		* <dt>P</dt><dd>Project (pjx)</dd>
		* <dt>R</dt><dd>Report (frx)</dd>
		* <dt>V</dt><dd>Classlibrary (vcx)</dd>
		* <dt>v</dt><dd>Class of Classlibrary</dd>
		* <dt><b>X</b></dt><dd><b>Heart beat check</b></dd>
		*</dl>
		* This method basically deals with classes of vcx files and objects of scx files.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 02.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		IF PCOUNT()=0 THEN
		 CREATE CURSOR muh (i1 i)
		 RETURN
		ENDIF &&PCOUNT()=0
		
		LOCAL;
		 lnDirty AS INTEGER,;
		 llDirty AS BOOLEAN
		
		llDirty = .F.
		
		*so now let's see if something is changed
		#IF .F. THEN
		*beautify off
		 TEXT
		#ENDIF &&.F.
		
		*set anything "ok" that was processed by last run
		lnDirty = IIF(m.tlText2Bin,1,0)
		UPDATE Cur1 SET;
		 iDirty   = m.lnDirty,;
		 tLastUse = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		  AND Cur1.cType==m.tcType;
		  AND Cur1.iDirty>=0
		  
		*!*	Changed by: SF 5.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,13:09:00}">Changed by: SF<br />
		*!*	Do not delete a file marked for delation (because it is not automatic obsolete)
		*!*	</change>
		*!*	</pdm>
		
		*set files marked as "to delete" by "all cleanup" as "not to delete"
		*because file exists
		lnDirty = IIF(m.tlText2Bin,9,8)
		UPDATE Cur1 SET;
		 iDirty    = m.lnDirty,;
		 tLastUse  = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		  AND Cur1.cType==m.tcType;
		  AND Cur1.iDirty=-1
		*!*	/Changed by: SF 5.6.2015
		
		 SELECT;
		  .T. AS lNew,;
		  Cur1.cObjName,;
		  Cur1.cUniqueId;
		  FROM (tcSource) AS Cur1;
		  INTO CURSOR curHelp;
		  WHERE Cur1.cUniqueID-Cur1.cObjName NOT IN (;
		    SELECT;
		     Cur1_1.cUniqueId-Cur1_1.cObjName;
		     FROM (m.tcStorage) AS Cur1_1;
		     WHERE Cur1_1.cFile==m.tcFile;
		      AND Cur1_1.cType==m.tcType;
		   );
		UNION;
		 SELECT;
		  .F. AS lNew,;
		  Cur2.cObjName,;
		  Cur2.cUniqueId;
		  FROM (m.tcStorage) AS Cur2;
		  WHERE Cur2.cFile==m.tcFile;
		   AND Cur2.cType==m.tcType;
		   AND Cur2.cUniqueId-Cur2.cObjName NOT IN(;
		    SELECT;
		     Cur2_1.cUniqueID-Cur2_1.cObjName;
		     FROM (tcSource) AS Cur2_1;
		   )
		
		llDirty = RECCOUNT()>0  &&something is changed some way
		
		*Those will have files that will no longer be valid
		*Records will be deleted in the next run, due to post processing -> delete obsolete vc2 files!
		*Objects with both lNew AND !lNew have replaced UniqueId!
		UPDATE Cur1 SET;
		 iDirty   = -1,;
		 tLastUse = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 INNER JOIN curHelp AS Cur2;
		  ON Cur1.cObjName==Cur2.cObjName;
		   AND Cur1.cFile==m.tcFile;
		   AND Cur1.cType==m.tcType;
		   AND !Cur2.lNew;
		  WHERE Cur2.cObjName NOT IN(;
		    SELECT;
		     Cur2_1.cObjName;
		     FROM curHelp AS Cur2_1;
		     WHERE Cur2_1.lNew;
		   )
		
		*Records changed - lNew AND !lNew needs to be checked
		 lnDirty = IIF(m.tlText2Bin,3,2)
		 UPDATE Cur1 SET;
		  cUniqueId =Cur2.cUniqueId,;
		  iDirty    = m.lnDirty,;
		  tLastUse  = DATETIME();
		  FROM (m.tcStorage) AS Cur1;
		  INNER JOIN curHelp AS Cur2;
		   ON Cur1.cObjName==Cur2.cObjName;
		    AND Cur1.cFile==m.tcFile;
		    AND Cur1.cType==m.tcType;
		    AND Cur2.lNew;
		  INNER JOIN curHelp AS Cur3;
		   ON Cur1.cObjName==Cur3.cObjName;
		    AND !Cur3.lNew;
		
		*Records marked as dirty for heart beat failure OR  garbage needs to be checked / reprocessed
		 UPDATE Cur1 SET;
		  iDirty    = m.lnDirty,;
		  tLastUse  = DATETIME();
		  FROM (m.tcStorage) AS Cur1;
		  WHERE Cur1.iDirty IN (-3,-4);
		   AND Cur1.cFile==m.tcFile;
		   AND Cur1.cType==m.tcType
		
		llDirty = m.llDirty OR _TALLY>0
		
		*new files
		 lnDirty = IIF(m.tlText2Bin,5,4)
		 INSERT INTO (m.tcStorage);
		  SELECT;
		   m.tcType AS cType,;
		   CAST(m.tcFile AS c(240)) AS cFile,;
		   Cur2.cObjName,;
		   Cur2.cUniqueId,;
		   CAST(m.lnDirty AS I) AS iDirty,;
		   DATETIME() AS tLastUse;
		   FROM curHelp AS Cur2;
		   WHERE Cur2.lNew;
		    AND Cur2.cObjName NOT IN(;
		     SELECT;
		      Cur3.cObjName;
		      FROM curHelp AS Cur3;
		      WHERE !Cur3.lNew;
		    )
		
		#IF .F. THEN
		*beautify on
		 ENDTEXT
		#ENDIF &&.F.
		
		USE IN SELECT('curHelp')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty
		
	ENDPROC

ENDDEFINE

DEFINE CLASS de_interface AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="capBinText" UniqueID="" Timestamp="" />

	*<PropValue>
		DataSource = .NULL.
		DataSourceType = "NATIVE"
		Height = 34
		Name = "de_interface"
		Width = 144
	*</PropValue>

	ADD OBJECT 'capBinText' AS cursoradapter WITH ;
		Alias = "curbin2text", ;
		BufferModeOverride = 5, ;
		CursorSchema = cType c(1), cFile c(240), cObjName c(240),cUniqueID c(16) NOCPTRANS, tLastUse T, ;
		Flags = 0, ;
		Height = 22, ;
		KeyFieldList = cUniqueID, ;
		Left = 36, ;
		Name = "capBinText", ;
		SelectCmd = SELECT Cur1.cType, Cur1.cFile, Cur1.cObjName, Cur1.cUniqueID, Cur1.tLastUse FROM xTable AS Cur1 WHERE Cur1.cType=='A', ;
		Tables = xTable, ;
		Top = 2, ;
		UpdatableFieldList = cType, cFile, cObjName, cUniqueID, tLastUse, ;
		UpdateNameList = cType xTable.cType, cFile xTable.cFile, cObjName xTable.cObjName, cUniqueID xTable.cUniqueID, tLastUse xTable.tLastUse, ;
		UseCursorSchema = .T., ;
		Width = 23
		*< END OBJECT: BaseClass="cursoradapter" />
	
	PROCEDURE capBinText.AutoOpen
		*** Setup code: DO NOT REMOVE
		if not pemstatus(This, '__VFPSetup', 5)
			This.AddProperty('__VFPSetup', 1)
			This.Init()
		endif
		*** End of Setup code: DO NOT REMOVE
		
	ENDPROC

	PROCEDURE capBinText.Init
		*** Setup code: DO NOT REMOVE
		LOCAL llReturn
		DO CASE
		 CASE NOT PEMSTATUS(THIS, '__VFPSetup', 5)
		  THIS.ADDPROPERTY('__VFPSetup', 0)
		 CASE THIS.__VFPSetup = 1
		  THIS.__VFPSetup = 2
		 CASE THIS.__VFPSetup = 2
		  THIS.__VFPSetup = 0
		  RETURN
		ENDCASE
		SET MULTILOCKS ON
		llReturn = DODEFAULT()
		*** End of Setup code: DO NOT REMOVE
		
		*** Setup code: DO NOT REMOVE
		IF THIS.__VFPSetup = 1
		 THIS.__VFPSetup = 2
		ENDIF
		
		
		#IF .F. THEN
		
		 loa.SELECTCMD          = "SELECT Cur1.cType, Cur1.cFile, Cur1.cObjName, Cur1.cUniqueID, Cur1.tLastUse FROM xTable AS Cur1 WHERE Cur1.cType=='A'"
		 loa.CURSORSCHEMA       = "cType c(1), cFile c(240), cObjName c(240),cUniqueID c(16) NOCPTRANS, tLastUse T"
		 loa.TABLES             = "xTable"
		 loa.KEYFIELDLIST       = "cUniqueID"
		 loa.UPDATABLEFIELDLIST = "cType, cFile, cObjName, cUniqueID, tLastUse"
		 loa.UPDATENAMELIST     = "cType xTable.cType, cFile xTable.cFile, cObjName xTable.cObjName, cUniqueID xTable.cUniqueID, tLastUse xTable.tLastUse"
		
		#ENDIF &&.f.
		
		
		IF !PEMSTATUS(_SCREEN,'gcB2T_Path',5) OR EMPTY(_SCREEN.gcB2T_Path) OR !FILE(_SCREEN.gcB2T_Path) THEN
		 RETURN
		ENDIF &&!PEMSTATUS(_SCREEN,'gcB2T_Path',5) OR EMPTY(_SCREEN.gcB2T_Path) OR !FILE(_SCREEN.gcB2T_Path)
		
		THIS.DATASOURCETYPE = "NATIVE"
		LOCAL;
		 lcTable  AS CHARACTER,;
		 lcTemp   AS CHARACTER
		
		*Type des Adapters. Wird zum Löschen und Neuanlegen genutzt.
		*AllowDelete und AllowInsert auf entsprechende Werte setzten
		*im init:
		*THIS.gnBase_Type = THISFORM.gnBase_Type im ini
		lcTable          = THIS.PARENT.PARENT.cusB2T.Storage_Open(_SCREEN.gcB2T_Path)
		***<SelectCmd>
		TEXT TO m.lcTemp NOSHOW TEXTMERGE PRETEXT 7
		SELECT
		 Cur1.cType,
		 Cur1.cFile,
		 Cur1.cObjName,
		 Cur1.cUniqueID,
		 Cur1.tLastUse
		 FROM <<m.lcTable>> AS Cur1
		 WHERE Cur1.cType=='A'
		ENDTEXT
		lcTemp         = STRTRAN(m.lcTemp, 0h0D0A, " ")
		lcTemp         = STRTRAN(m.lcTemp, 0h09, "")
		THIS.SELECTCMD = m.lcTemp
		***</SelectCmd>
		
		***<CursorSchema>
		TEXT TO m.lcTemp NOSHOW PRETEXT 7
		  cType     c(1),
		  cFile     c(240),
		  cObjName  c(240),
		  cUniqueID c(16) NOCPTRANS,
		  tLastUse  T
		ENDTEXT
		lcTemp            = STRTRAN(m.lcTemp, 0h0D0A, "")
		THIS.CURSORSCHEMA = m.lcTemp
		***</CursorSchema>
		
		***<Tables>
		TEXT TO m.lcTemp NOSHOW TEXTMERGE PRETEXT 7
		<<lcTable>>
		ENDTEXT
		lcTemp      = STRTRAN(m.lcTemp, 0h0D0A, "")
		THIS.TABLES = m.lcTemp
		***</Tables>
		
		***<KeyFieldList>
		TEXT TO m.lcTemp NOSHOW PRETEXT 7
		cUniqueID
		ENDTEXT
		lcTemp            = STRTRAN(m.lcTemp, 0h0D0A, "")
		THIS.KEYFIELDLIST = m.lcTemp
		***</KeyFieldList>
		
		***<UpdatableFieldList>
		* IOBJ_IX,
		* PROJE_T_IX,
		TEXT TO m.lcTemp NOSHOW PRETEXT 7
		cType,
		cFile,
		cObjName,
		cUniqueID,
		tLastUse
		ENDTEXT
		lcTemp                  = STRTRAN(m.lcTemp, 0h0D0A, "")
		THIS.UPDATABLEFIELDLIST = m.lcTemp
		***</UpdatableFieldList>
		
		***<UpdateNameList>
		TEXT TO m.lcTemp NOSHOW TEXTMERGE PRETEXT 7
		cType     <<lcTable>>.cType,
		cFile     <<lcTable>>.cFile,
		cObjName  <<lcTable>>.cObjName,
		cUniqueID <<lcTable>>.cUniqueID,
		tLastUse  <<lcTable>>.tLastUse
		ENDTEXT
		lcTemp              = STRTRAN(m.lcTemp, 0h0D0A, "")
		THIS.UPDATENAMELIST = m.lcTemp
		***</UpdateNameList>
		
		THIS.CURSORFILL
		RETURN m.llReturn
		*** End of Setup code: DO NOT REMOVE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frminterface AS form 		&& Just to create an interface as well as a private DATASESSION.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cusEnv" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cusB2T" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMain" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtMain" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblAutoCommit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAutoCommit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdMain" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblGit_PJX" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkGit_PJX" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblGit_act" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblGUI" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtGUI" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGUI" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblUseBash" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseBash" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblGit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNew" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPick" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblGit_All" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDBC" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDBC" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblConfig" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtConfig" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdConfig" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdConfig_Del" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lbLog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkLog" UniqueID="" Timestamp="" />

	#INCLUDE "..\stuff.h"
	*<DefinedPropArrayMethod>
		*m: del_file		&& Delete File from Table
		*m: new_file		&& Add file to table.
		*m: pick_file		&& Pick a file
		*m: revert_file		&& Revert changes to table.
		*m: save_file		&& Save Records to table
		*m: storage_get		&& Get the storage settings and put the values of the surface objects.
		*m: storage_put		&& Get the values from the the surface objects and put to storage settings.
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoCenter = .T.
		Caption = "Bin <> Text"
		Closable = .F.
		DataSession = 2
		DoCreate = .T.
		Height = 600
		MaxButton = .F.
		MinButton = .F.
		MinHeight = 600
		MinWidth = 600
		Name = "frminterface"
		ShowTips = .T.
		Visible = .F.
		Width = 600
	*</PropValue>

	ADD OBJECT 'chkAll' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Height = 17, ;
		Left = 119, ;
		Name = "chkAll", ;
		TabIndex = 15, ;
		ToolTipText = "Convert all files or only changed files. Only for Bin to Text.", ;
		Top = 130, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkAutoCommit' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 4, ;
		Caption = "", ;
		Height = 17, ;
		Left = 119, ;
		Name = "chkAutoCommit", ;
		TabIndex = 28, ;
		ToolTipText = 'Commit with message "Timestamp" without message edit. ', ;
		Top = 490, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkDBC' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Height = 17, ;
		Left = 119, ;
		Name = "chkDBC", ;
		TabIndex = 11, ;
		ToolTipText = "Convert tables of Datatbases.", ;
		Top = 102, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkDel' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Height = 17, ;
		Left = 258, ;
		Name = "chkDel", ;
		TabIndex = 17, ;
		ToolTipText = "For FilePerClass. Delete text files for removed classes. Only  Bin to Text. Not implemented yet.", ;
		Top = 130, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkGit_PJX' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 4, ;
		Caption = "", ;
		Height = 17, ;
		Left = 119, ;
		Name = "chkGit_PJX", ;
		TabIndex = 33, ;
		ToolTipText = "Include pjx and project hook into auto git commit run.", ;
		Top = 538, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkLog' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Height = 17, ;
		Left = 578, ;
		Name = "chkLog", ;
		TabIndex = 13, ;
		ToolTipText = ("Create a log of FoxBin2Prg and Bin2Text actions."+0h0D0A+"May be altered by FoxBin2Prg config file."), ;
		Top = 102, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkUseBash' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 4, ;
		Caption = "", ;
		Height = 17, ;
		Left = 258, ;
		Name = "chkUseBash", ;
		TabIndex = 30, ;
		ToolTipText = "Run bash as shell for git commands.", ;
		Top = 490, ;
		Width = 16
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Anchor = 12, ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Height = 27, ;
		Left = 510, ;
		Name = "cmdCancel", ;
		TabIndex = 35, ;
		ToolTipText = "Cancel", ;
		Top = 563, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdConfig' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = ". . .", ;
		Default = .F., ;
		FontBold = .T., ;
		Height = 27, ;
		Left = 567, ;
		Name = "cmdConfig", ;
		TabIndex = 9, ;
		ToolTipText = "Pick config file.", ;
		Top = 65, ;
		Width = 27
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdConfig_Del' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = "X", ;
		Default = .F., ;
		FontBold = .T., ;
		FontSize = 11, ;
		Height = 27, ;
		Left = 532, ;
		Name = "cmdConfig_Del", ;
		TabIndex = 8, ;
		ToolTipText = "Clear config file.", ;
		Top = 65, ;
		Width = 27
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDel' AS commandbutton WITH ;
		Caption = "Delete", ;
		Height = 27, ;
		Left = 94, ;
		Name = "cmdDel", ;
		TabIndex = 20, ;
		Top = 184, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdGUI' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = ". . .", ;
		Default = .F., ;
		FontBold = .T., ;
		Height = 27, ;
		Left = 567, ;
		Name = "cmdGUI", ;
		TabIndex = 26, ;
		ToolTipText = "Pick git GUI programm.", ;
		Top = 458, ;
		Width = 27
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdMain' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = ". . .", ;
		Default = .F., ;
		FontBold = .T., ;
		Height = 27, ;
		Left = 567, ;
		Name = "cmdMain", ;
		TabIndex = 5, ;
		ToolTipText = "Pick FoxBin2Prg main programm.", ;
		Top = 35, ;
		Width = 27
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdNew' AS commandbutton WITH ;
		Caption = "New", ;
		Height = 27, ;
		Left = 5, ;
		Name = "cmdNew", ;
		TabIndex = 19, ;
		Top = 184, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS commandbutton WITH ;
		Anchor = 12, ;
		Caption = "OK", ;
		Default = .T., ;
		Height = 27, ;
		Left = 420, ;
		Name = "cmdOK", ;
		TabIndex = 34, ;
		ToolTipText = "Ok", ;
		Top = 563, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPick' AS commandbutton WITH ;
		Caption = ". . .", ;
		FontBold = .T., ;
		Height = 27, ;
		Left = 183, ;
		Name = "cmdPick", ;
		TabIndex = 21, ;
		Top = 184, ;
		Width = 27
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cusB2T' AS cusstorage WITH ;
		Left = 489, ;
		Name = "cusB2T", ;
		Top = 138
		*< END OBJECT: ClassLib="bin_2_text.vcx" BaseClass="custom" />

	ADD OBJECT 'cusEnv' AS cusenvironment WITH ;
		Left = 382, ;
		Name = "cusEnv", ;
		Top = 138
		*< END OBJECT: ClassLib="bin_2_text.vcx" BaseClass="custom" />

	ADD OBJECT 'grdList' AS grid WITH ;
		Anchor = 15, ;
		Height = 214, ;
		Left = 5, ;
		Name = "grdList", ;
		TabIndex = 22, ;
		Top = 218, ;
		Width = 584
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'lblAll' AS label WITH ;
		Alignment = 1, ;
		Caption = "Convert all files", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblAll", ;
		TabIndex = 14, ;
		ToolTipText = "Convert all files or only changed files. Only for Bin to Text.", ;
		Top = 130, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblAutoCommit' AS label WITH ;
		Alignment = 1, ;
		Anchor = 4, ;
		Caption = "Auto commit", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblAutoCommit", ;
		TabIndex = 27, ;
		ToolTipText = 'Commit with message "Timestamp" without message edit. ', ;
		Top = 490, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblConfig' AS label WITH ;
		Alignment = 1, ;
		Caption = "Default Config", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblConfig", ;
		TabIndex = 6, ;
		Top = 70, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblDBC' AS label WITH ;
		Alignment = 1, ;
		Caption = "DBF of DBC", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblDBC", ;
		TabIndex = 10, ;
		ToolTipText = "Scan DBCs for DBF's and process the DBF's too.", ;
		Top = 102, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblDel' AS label WITH ;
		Alignment = 1, ;
		Caption = "Delete obsolet files", ;
		Height = 17, ;
		Left = 145, ;
		Name = "lblDel", ;
		TabIndex = 16, ;
		ToolTipText = "For FilePerClass. Delete text files for removed classes. Only  Bin to Text. Not implemented yet.", ;
		Top = 130, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblGit' AS label WITH ;
		Alignment = 2, ;
		Anchor = 4, ;
		AutoSize = .T., ;
		Caption = "  git  ", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 286, ;
		Name = "lblGit", ;
		TabIndex = 23, ;
		Top = 440, ;
		Width = 28
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblGit_act' AS label WITH ;
		Alignment = 2, ;
		Anchor = 4, ;
		AutoSize = .T., ;
		Caption = "  git \<commit active (project)  ", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 219, ;
		Name = "lblGit_act", ;
		TabIndex = 31, ;
		Top = 519, ;
		Width = 162
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblGit_All' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .T., ;
		Caption = "process all projects", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 229, ;
		Name = "lblGit_All", ;
		TabIndex = 18, ;
		Top = 160, ;
		Width = 115
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblGit_PJX' AS label WITH ;
		Alignment = 1, ;
		Anchor = 4, ;
		Caption = "Include pjx", ;
		Height = 17, ;
		Left = 14, ;
		Name = "lblGit_PJX", ;
		TabIndex = 32, ;
		ToolTipText = "Include pjx and project hook into auto git commit run.", ;
		Top = 538, ;
		Width = 100
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblGUI' AS label WITH ;
		Alignment = 1, ;
		Caption = "GUI program", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblGUI", ;
		TabIndex = 24, ;
		Top = 463, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMain' AS label WITH ;
		Alignment = 1, ;
		Caption = "Main program", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblMain", ;
		TabIndex = 3, ;
		Top = 40, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lbLog' AS label WITH ;
		Alignment = 1, ;
		Caption = "Create log", ;
		Height = 17, ;
		Left = 465, ;
		Name = "lbLog", ;
		TabIndex = 12, ;
		ToolTipText = ("Create a log of FoxBin2Prg and Bin2Text actions."+0h0D0A+"May be altered by FoxBin2Prg config file."), ;
		Top = 102, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblPath' AS label WITH ;
		Alignment = 1, ;
		Caption = "Storage", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblPath", ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblUseBash' AS label WITH ;
		Alignment = 1, ;
		Anchor = 4, ;
		Caption = "Bash", ;
		Height = 17, ;
		Left = 145, ;
		Name = "lblUseBash", ;
		TabIndex = 29, ;
		ToolTipText = "Run bash as shell for git commands.", ;
		Top = 490, ;
		Width = 108
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Anchor = 4, ;
		BorderWidth = 2, ;
		Height = 3, ;
		Left = 5, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 447, ;
		Width = 590
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Anchor = 4, ;
		Height = 3, ;
		Left = 5, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 525, ;
		Width = 590
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape3' AS shape WITH ;
		Height = 3, ;
		Left = 5, ;
		Name = "Shape3", ;
		SpecialEffect = 0, ;
		Top = 166, ;
		Width = 590
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'txtConfig' AS textbox WITH ;
		Anchor = 10, ;
		Height = 23, ;
		Left = 118, ;
		Name = "txtConfig", ;
		ReadOnly = .T., ;
		TabIndex = 7, ;
		ToolTipText = "Optional default config file for FoxBin2Prg.", ;
		Top = 67, ;
		Width = 407
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtGUI' AS textbox WITH ;
		Anchor = 10, ;
		Height = 23, ;
		Left = 118, ;
		Name = "txtGUI", ;
		ReadOnly = .T., ;
		TabIndex = 25, ;
		ToolTipText = "Path to git GUI interface.", ;
		Top = 460, ;
		Width = 441
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtMain' AS textbox WITH ;
		Anchor = 10, ;
		Height = 23, ;
		Left = 118, ;
		Name = "txtMain", ;
		ReadOnly = .T., ;
		TabIndex = 4, ;
		ToolTipText = "Path to FoxBin2PRG.prg main program.", ;
		Top = 37, ;
		Width = 441
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtPath' AS textbox WITH ;
		Anchor = 10, ;
		Height = 23, ;
		Left = 118, ;
		Name = "txtPath", ;
		ReadOnly = .T., ;
		TabIndex = 2, ;
		ToolTipText = "Path to storage table.", ;
		Top = 7, ;
		Width = 476
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE del_file		&& Delete File from Table
		IF USED('curBin2Text') THEN
		 IF RECCOUNT('curBin2Text')>0 THEN
		  DELETE IN curBin2Text
		 ENDIF &&RECCOUNT('curBin2Text')>0
		ENDIF &&USED('curBin2Text')
		
		THIS.grdList.REFRESH()
	ENDPROC

	PROCEDURE Init
		THIS.ADDOBJECT('deEnvironment','de_Interface')
		
	ENDPROC

	PROCEDURE new_file		&& Add file to table.
		LPARAMETERS;
		 tlPickFile
		
		IF USED('curBin2Text') THEN
		 INSERT INTO curBin2Text;
		  (cType,cUniqueID,tLastUse);
		  VALUES;
		  ('A',SYS(2015),DATETIME())
		
		 IF m.tlPickFile THEN
		  THIS.Pick_File()
		 ENDIF &&m.tlPickFile
		ENDIF &&USED('curBin2Text')
		
	ENDPROC

	PROCEDURE pick_file		&& Pick a file
		IF USED('curBin2Text') THEN
		 LOCAL;
		  lOldcPath AS OBJECT,;
		  lcPath    AS STRING
		
		 IF EOF('curBin2Text') THEN
		  THISFORM.New_File(.F.)
		 ENDIF &&EOF('curBin2Text')
		
		 lOldcPath = FULLPATH(CURDIR())
		 lcPath    = FULLPATH(JUSTPATH(curBin2Text.cFile),_SCREEN.gcB2T_Path)
		
		 IF DIRECTORY(m.lcPath) THEN
		  CD (m.lcPath)
		 ENDIF &&DIRECTORY(lcPath)
		
		 IF UPPER(JUSTEXT(curBin2Text.cFile))=='DBF' THEN
		  lcPath = 'DBF, Table;DBC'
		 ELSE  &&UPPER(JUSTEXT(curBin2Text.cFile))=='DBF'
		  lcPath = 'DBC;DBF, Table'
		 ENDIF &&UPPER(JUSTEXT(curBin2Text.cFile))=='DBF'
		
		 lcPath = GETFILE(m.lcPath)
		
		 IF !EMPTY(m.lcPath) AND FILE(m.lcPath) THEN
		  SELECT curBin2Text
		  REPLACE;
		   cFile WITH SYS(2014,m.lcPath,_SCREEN.gcB2T_Path)
		 ENDIF &&!EMPTY(lcPath) AND FILE(lcPath)
		
		 CD (m.lOldcPath)
		ENDIF &&USED('curBin2Text')
		
		THIS.grdList.REFRESH()
		
	ENDPROC

	PROCEDURE revert_file		&& Revert changes to table.
		IF USED('curBin2Text') THEN
		 TABLEREVERT(.T.,'curBin2Text')
		ENDIF &&USED('curBin2Text')
		
	ENDPROC

	PROCEDURE save_file		&& Save Records to table
		IF USED('curBin2Text') THEN
		 LOCAL;
		  lnRec AS NUMBER
		
		 SELECT curBin2Text
		 LOCATE
		
		 lnRec = GETNEXTMODIFIED(0)
		 DO WHILE !EMPTY(m.lnRec)
		  GO (m.lnRec)
		  REPLACE;
		   tLastUse WITH DATETIME()
		  lnRec = GETNEXTMODIFIED(m.lnRec)
		 ENDDO &&!EMPTY(lnRec)
		
		 TABLEUPDATE(.T.,.T.,'curBin2Text')
		ENDIF &&USED('curBin2Text')
		
	ENDPROC

	PROCEDURE Show
		LPARAMETERS;
		 tnStyle
		
		LOCAL;
		 lcBranch    AS STRING,;
		 lnAnchor1   AS NUMBER,;
		 lnAnchor2   AS NUMBER,;
		 lnAnchor3   AS NUMBER,;
		 loConverter AS OBJECT
		
		lcBranch    = GetBranch()
		IF THIS.cusB2T.Get_Converter(,@loConverter,.T.) THEN
		 THIS.CAPTION = 'Bin2Text v'+dcB2T_Verno+'  Bin <> Text, Error FoxBin2Prg'
		ELSE  &&this.cusB2T.Get_Converter(,@loConverter,.T.)
		 THIS.CAPTION = 'Bin2Text v'+dcB2T_Verno+'  Bin <> Text, FoxBin2Prg v'+m.loConverter.c_FB2PRG_VERSION_REAL
		ENDIF &&this.cusB2T.Get_Converter(,@loConverter,.T.)
		
		lnAnchor1 = THIS.grdList.ANCHOR
		lnAnchor2 = THIS.cmdOK.ANCHOR
		lnAnchor3 = THIS.cmdCancel.ANCHOR
		
		THIS.grdList.ANCHOR   = 0
		THIS.cmdOK.ANCHOR     = 0
		THIS.cmdCancel.ANCHOR = 0
		
		IF EMPTY(m.lcBranch) THEN
		 THIS.lblGit_All.CAPTION = '  process all projects  '
		 THIS.lblGit.CAPTION     = '  not gited  '
		
		 THIS.Shape1.VISIBLE = .T.
		 THIS.lblGit.VISIBLE = .T.
		
		 THIS.lblGUI.VISIBLE        = .F.
		 THIS.txtGUI.VISIBLE        = .F.
		 THIS.cmdGUI.VISIBLE        = .F.
		 THIS.lblAutoCommit.VISIBLE = .F.
		 THIS.chkAutoCommit.VISIBLE = .F.
		 THIS.lblUseBash.VISIBLE    = .F.
		 THIS.chkUseBash.VISIBLE    = .F.
		 THIS.lblAutoCommit.VISIBLE = .F.
		 THIS.chkAutoCommit.VISIBLE = .F.
		
		 THIS.Shape2.VISIBLE     = .F.
		 THIS.lblGit_act.VISIBLE = .F.
		 THIS.lblGit_PJX.VISIBLE = .F.
		 THIS.chkGit_PJX.VISIBLE = .F.
		
		 THIS.cmdOK.TOP     = THIS.Shape1.TOP
		 THIS.cmdCancel.TOP = THIS.Shape1.TOP
		
		 THIS.MINHEIGHT = THIS.cmdCancel.TOP+THIS.cmdCancel.HEIGHT+5
		 THIS.HEIGHT    = THIS.MINHEIGHT
		
		ELSE  &&EMPTY(m.lcBranch)
		 THIS.lblGit_All.CAPTION = '  process / commit all projects  '
		 THIS.lblGit.CAPTION     = '  git - on branch '+m.lcBranch+'  '
		
		 THIS.Shape1.VISIBLE = .T.
		 THIS.lblGit.VISIBLE = .T.
		
		 THIS.lblGUI.VISIBLE        = .T.
		 THIS.txtGUI.VISIBLE        = .T.
		 THIS.cmdGUI.VISIBLE        = .T.
		 THIS.lblAutoCommit.VISIBLE = .T.
		 THIS.chkAutoCommit.VISIBLE = .T.
		 THIS.lblUseBash.VISIBLE    = .T.
		 THIS.chkUseBash.VISIBLE    = .T.
		 THIS.lblAutoCommit.VISIBLE = .T.
		 THIS.chkAutoCommit.VISIBLE = .T.
		
		 THIS.Shape2.VISIBLE     = .T.
		 THIS.lblGit_act.VISIBLE = .T.
		 THIS.lblGit_PJX.VISIBLE = .T.
		 THIS.chkGit_PJX.VISIBLE = .T.
		
		 IF USED('curBin2Text') THEN
		  THIS.Shape3.VISIBLE     = .T.
		  THIS.lblGit_All.VISIBLE = .T.
		  THIS.cmdNew.VISIBLE     = .T.
		  THIS.cmdDel.VISIBLE     = .T.
		  THIS.cmdPick.VISIBLE    = .T.
		  THIS.grdList.VISIBLE    = .T.
		
		 ELSE  &&USED('curBin2Text')
		
		  THIS.Shape3.VISIBLE     = .F.
		  THIS.lblGit_All.VISIBLE = .F.
		  THIS.cmdNew.VISIBLE     = .F.
		  THIS.cmdDel.VISIBLE     = .F.
		  THIS.cmdPick.VISIBLE    = .F.
		  THIS.grdList.VISIBLE    = .F.
		
		  THIS.cmdOK.TOP     = THIS.Shape3.TOP
		  THIS.cmdCancel.TOP = THIS.Shape3.TOP
		
		  THIS.MINHEIGHT = THIS.cmdCancel.TOP+THIS.cmdCancel.HEIGHT+5
		  THIS.HEIGHT    = .MINHEIGHT
		
		 ENDIF &&USED('curBin2Text')
		ENDIF &&EMPTY(m.lcBranch)
		
		THIS.grdList.ANCHOR   = m.lnAnchor1
		THIS.cmdOK.ANCHOR     = m.lnAnchor2
		THIS.cmdCancel.ANCHOR = m.lnAnchor3
		
		RETURN DODEFAULT(@tnStyle)
		
	ENDPROC

	PROCEDURE storage_get		&& Get the storage settings and put the values of the surface objects.
		LPARAMETERS;
		 toSettings AS COLLECTION
		
		*!*	<pdm>
		*!*	<descr>Puts values of the settings object to visible objects.</descr>
		*!*	<params name="toSettings" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		LOCAL;
		 loSetting AS EMPTY
		
		loSetting                =  m.toSettings.ITEM("gcB2T_Path")
		THIS.txtPath.VALUE       =  m.loSetting.gcFile
		
		loSetting                =  m.toSettings.ITEM("gcB2T_FB2T")
		THIS.txtMain.VALUE       =  m.loSetting.gcFile
		
		loSetting                =  m.toSettings.ITEM("gcB2T_Config")
		THIS.txtConfig.VALUE     =  m.loSetting.gcFile
		
		loSetting                =  m.toSettings.ITEM("gcB2T_GUI")
		THIS.txtGUI.VALUE        =  m.loSetting.gcFile
		
		loSetting                =  m.toSettings.ITEM("gcB2T_DBC")
		THIS.chkDBC.VALUE        =  m.loSetting.gcFile=="1"
		
		loSetting                =  m.toSettings.ITEM("gcB2T_Opt")
		THIS.chkAll.VALUE        = !m.loSetting.gcFile=="1"
		
		loSetting                =  m.toSettings.ITEM("gcB2T_Commit")
		THIS.chkAutoCommit.VALUE =  m.loSetting.gcFile=="1"
		
		loSetting                =  m.toSettings.ITEM("gcB2T_GitPjx")
		THIS.chkGit_PJX.VALUE    =  m.loSetting.gcFile=="1"
		
		loSetting                =  m.toSettings.ITEM("gcB2T_Delete")
		THIS.chkDel.VALUE        =  m.loSetting.gcFile=="1"
		
		loSetting                =  m.toSettings.ITEM("gcB2T_UseBash")
		THIS.chkUseBash.VALUE    =  m.loSetting.gcFile=="1"
		
		loSetting                =  m.toSettings.ITEM("gcB2T_Log")
		THIS.chkLog.VALUE        =  m.loSetting.gcFile=="1"
		
		THIS.ADDPROPERTY("glSet",.F.)
		
		IF USED('curBin2Text') THEN
		 THIS.grdList.COLUMNCOUNT             = 0
		 THIS.grdList.RECORDSOURCE            = 'curBin2Text'
		 THIS.grdList.COLUMNCOUNT             = 1
		 THIS.grdList.Column1.WIDTH           = 580
		 THIS.grdList.Column1.CONTROLSOURCE   = 'curBin2Text.cFile'
		 THIS.grdList.Column1.Header1.CAPTION = 'File'
		ENDIF &&USED('curBin2Text')
		
	ENDPROC

	PROCEDURE storage_put		&& Get the values from the the surface objects and put to storage settings.
		LPARAMETERS;
		 toSettings AS COLLECTION
		
		*!*	<pdm>
		*!*	<descr>Stores changes to the settings object.</descr>
		*!*	<params name="toSettings" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		 
		loSetting        = m.toSettings.ITEM("gcB2T_Path")
		loSetting.gcFile = THIS.txtPath.VALUE
		
		loSetting        = m.toSettings.ITEM("gcB2T_FB2T")
		loSetting.gcFile = THIS.txtMain.VALUE
		
		loSetting        = m.toSettings.ITEM("gcB2T_Config")
		loSetting.gcFile = THIS.txtConfig.VALUE
		
		loSetting        = m.toSettings.ITEM("gcB2T_GUI")
		loSetting.gcFile = THIS.txtGUI.VALUE
		
		loSetting        = m.toSettings.ITEM("gcB2T_DBC")
		loSetting.gcFile = IIF(THIS.chkDBC.VALUE,"1","0")
		
		loSetting        = m.toSettings.ITEM("gcB2T_Opt")
		loSetting.gcFile = IIF(THIS.chkAll.VALUE,"0","1")
		
		loSetting        = m.toSettings.ITEM("gcB2T_Commit")
		loSetting.gcFile = IIF(THIS.chkAutoCommit.VALUE,"1","0")
		
		loSetting        = m.toSettings.ITEM("gcB2T_GitPjx")
		loSetting.gcFile = IIF(THIS.chkGit_PJX.VALUE,"1","0")
		
		loSetting        = m.toSettings.ITEM("gcB2T_Delete")
		loSetting.gcFile = IIF(THIS.chkDel.VALUE,"1","0")
		
		loSetting        =  m.toSettings.ITEM("gcB2T_Log")
		loSetting.gcFile = IIF(THIS.chkLog.VALUE,"1","0")
		
		loSetting        = m.toSettings.ITEM("gcB2T_UseBash")
		loSetting.gcFile = IIF(THIS.chkUseBash.VALUE,"1","0")
		
		toSettings.ADD(THIS.glSet,"glSet")
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		*!*	<pdm>
		*!*	<descr>Hide form, do not store.</descr>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		THISFORM.Revert_File()
		THIS.PARENT.glSet = .F.
		THIS.PARENT.HIDE
		
	ENDPROC

	PROCEDURE cmdConfig.Click
		*!*	<pdm>
		*!*	<descr>Get storage location of Default - config file for FoxBin2Prg.</descr>
		*!*	<copyright><i>&copy; 31.08.2023 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile    AS CHARACTER.;
		 lcOldPath AS CHARACTER
		
		lcOldPath = FULLPATH(CURDIR())
		IF !EMPTY(THIS.PARENT.txtConfig.VALUE) THEN
		 CD (JUSTPATH(THIS.PARENT.txtConfig.VALUE))
		ENDIF &&!EMPTY(THIS.PARENT.txtConfig.VALUE)
		
		lcFile = GETFILE("cfg","",'',0,"FoxBin2Prg config file")
		IF FILE(m.lcFile) THEN
		 THIS.PARENT.txtConfig.VALUE = m.lcFile
		ENDIF &&FILE(m.lcFile)
		
		CD (m.lcOldPath)
		
	ENDPROC

	PROCEDURE cmdConfig_Del.Click
		THIS.PARENT.txtConfig.VALUE = ""
		
	ENDPROC

	PROCEDURE cmdDel.Click
		THISFORM.Del_File()
		
	ENDPROC

	PROCEDURE cmdGUI.Click
		*!*	<pdm>
		*!*	<descr>Get storage location of FoxBin2Prg.prg.</descr>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile    AS CHARACTER.;
		 lcOldPath AS CHARACTER
		
		lcOldPath = FULLPATH(CURDIR())
		CD (JUSTPATH(THIS.PARENT.txtGUI.VALUE))
		
		lcFile = GETFILE("exe","",'',0,"GUI programm")
		 THIS.PARENT.txtGUI.VALUE = m.lcFile
		
		CD (m.lcOldPath)
		
	ENDPROC

	PROCEDURE cmdMain.Click
		*!*	<pdm>
		*!*	<descr>Get storage location of FoxBin2Prg.prg.</descr>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile    AS CHARACTER.;
		 lcOldPath AS CHARACTER
		
		lcOldPath = FULLPATH(CURDIR())
		CD (JUSTPATH(THIS.PARENT.txtMain.VALUE))
		
		lcFile = GETFILE("prg","",'',0,"Main programm")
		IF !FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG" THEN
		 MESSAGEBOX('FoxBin2PRG not found',0,'Bin2Text v'+dcB2T_Verno)
		ELSE &&!FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG"
		 THIS.PARENT.txtMain.VALUE = m.lcFile
		ENDIF &&!FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG"
		
		CD (m.lcOldPath)
		
	ENDPROC

	PROCEDURE cmdNew.Click
		THISFORM.New_File(.T.)
		
	ENDPROC

	PROCEDURE cmdOK.Click
		*!*	<pdm>
		*!*	<descr>Hide form, store.</descr>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		THISFORM.Save_File()
		THIS.PARENT.glSet = .T.
		THIS.PARENT.HIDE
		
	ENDPROC

	PROCEDURE cmdPick.Click
		THISFORM.Pick_File()
		
	ENDPROC

	PROCEDURE txtConfig.When
		RETURN .F.
		
	ENDPROC

	PROCEDURE txtGUI.When
		RETURN .F.
		
	ENDPROC

	PROCEDURE txtMain.When
		RETURN .F.
		
	ENDPROC

	PROCEDURE txtPath.When
		RETURN .F.
		
	ENDPROC

ENDDEFINE
