*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="bin_2_text.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS cusstorage AS custom 		&& The stuff that does the work.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\stuff.h"
	*<DefinedPropArrayMethod>
		*m: check_scx		&& Checks a given scx file for changes.
		*m: check_vcx		&& Checks a given vcx file for changes.
		*m: convert		&& Convert complete set, not partial.
		*m: filestoprocess		&& Test if files are changed since last run.
		*m: get_converter		&& Create FoxBin2PRG object.
		*m: get_dbc_tables		&& Return the tables of DBCs processed.
		*m: get_md5
		*m: oget_setting		&& Returns a settings object of a given path with config from FoxBin2PRG.
		*m: process_bin2txt		&& Process all files of a given array to text files.
		*m: process_bin2txt_dir		&& Process all directories of a given array to text. Storage not used.
		*m: process_txt2bin		&& Process all files of a given array to binary files.
		*m: process_txt2bin_dir		&& Process all directories of a given array to binary. Storage not used.
		*m: storage_check		&& Check for valid  storage settings, alter settings
		*m: storage_check_bin2prg		&& Check location of FoxBin2Prg.
		*m: storage_close		&& Close the storage file.
		*m: storage_get		&& Get settings information out of storage
		*m: storage_location		&& Get location for storage file.
		*m: storage_open		&& Opens the storage file.
		*m: storage_set		&& Set settings information to storage.
		*m: sync_file		&& Test change of checksum (crc32) for a given file (pair) against the storage table.
		*m: sync_objects		&& Compares a help cursor with the storage table. Compares objects of a vcx / scx.
	*</DefinedPropArrayMethod>

	Name = "cusstorage"
	
	PROCEDURE check_scx		&& Checks a given scx file for changes.
		LPARAMETERS;
		 tcFile,;
		 tcPath,;
		 tlText2Bin,;
		 tcStorage,;
		 toSett
		
		*!*	<pdm>
		*!*	<descr>Checks a given scx file for changes.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Full qualified file to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Path of the operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSett" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail>Object with folder settings of FoxBin2PRG.</detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="1" /> is changed.</retval>
		*!*	<remarks>
		*<p>This will test checksum first.</p>
		*<p>If checksum is changed check SCX for timestamp change.</p>
		*<p>A object is a record in the scx with <expr>PLATFORM=="WINDOWS" AND LEN(PARENT)=0</expr>.
		* basically dataenvironment and form.</p>
		*<p>FoxBin2PRG separates them, for whatever reason, so I keep track.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 10.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnStep      AS INTEGER,;
		 llDirty     AS BOOLEAN,;
		 llOk        AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llDirty = .F.
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE m.lnStep=1   &&test for changes on file (checksum)
		*llOk - nothing changed on file
		   llOk = !THIS.Sync_File('K',m.tcFile,m.tlText2Bin,m.tcStorage)
		*/  &&m.lnStep=1  &&test for changes on file (checksum)
		
		  CASE m.lnStep=2 AND toSett.n_UseClassPerFile=0    &&Do not split classlib into classlib.class.vc2
		*Sync_File was dirty,
		*this could be one out of two problems
		*-file is not to be deleted (8,9) - we are not dirty
		   SELECT;
		    Cur1.iDirty;
		    FROM (m.tcStorage) AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType=='K';
		    AND Cur1.iDirty IN (8,9)
		*-if not found we are dirty
		   llDirty = RECCOUNT('curHelp')=0
		
		   USE IN curHelp
		* and done
		   llOk = .T.
		*/  &&m.lnStep=2 AND toSett.n_UseClassPerFile=0   &&Do not split classlib into classlib.class.vc2
		
		  CASE m.lnStep=2
		*just loop
		
		  CASE m.lnStep=3  &&Test access
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS scx IN SELECT('scx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=3 &&Test  access
		
		  CASE m.lnStep=4    &&Test if VCX is usable
		*okä, now test this thing
		   SELECT;
		    Cur1.UniqueID,;
		    COUNT(*) AS nCount;
		    FROM scx AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0;
		    GROUP BY 1 HAVING nCount>1
		
		*/  &&m.lnStep=4   &&Test if SCX is usable
		
		  CASE m.lnStep=5 AND RECCOUNT()>0
		*UniqueID not so unique
		*rebuild, delete from Storage
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx') EXCLUSIVE
		
		     SELECT vcx
		     REPLACE;
		      UniqueID WITH SYS(2015);
		      FOR PLATFORM='WINDOWS'
		
		     USE (m.tcFile) ALIAS scx IN SELECT('scx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=5 &&Test if SCX is usable
		
		  CASE m.lnStep=5
		*just loop
		
		  CASE m.lnStep=6  &&test for changes on classes
		*(only if checksum is changed)
		
		*so now let's see if something is changed
		*get vcx data
		   SELECT;
		    CAST(Cur1.ObjName AS c(240))         AS cObjName,;
		    Cur1.UniqueID+BINTOC(Cur1.TIMESTAMP) AS cUniqueId;
		    FROM scx AS Cur1;
		    INTO CURSOR curSCX;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0
		
		   INDEX ON cObjName  TAG _cObj
		   INDEX ON cUniqueId TAG _cUni
		
		   llDirty = THIS.Sync_Objects('k',m.tcFile,m.tlText2Bin,'curSCX',m.tcStorage)
		
		*/   &&m.lnStep=2 &&test for changes on classes
		
		  OTHERWISE && end loop
		   EXIT
		 ENDCASE
		
		 IF m.llDirty OR m.llOk THEN 
		  EXIT
		 ELSE  &&m.llDirty
		  lnStep = m.lnStep+1
		 ENDIF &&m.llDirty OR m.llOk
		
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		USE IN SELECT('scx')
		USE IN SELECT('curSCX')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty
		
		
	ENDPROC

	PROCEDURE check_vcx		&& Checks a given vcx file for changes.
		LPARAMETERS;
		 tcFile,;
		 tcPath,;
		 tlText2Bin,;
		 tcStorage,;
		 toSett
		
		*!*	<pdm>
		*!*	<descr>Checks a given vcx file for changes.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Full qualified file to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Path of the operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSett" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail>Object with folder settings of FoxBin2PRG.</detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="1" /> is changed.</retval>
		*!*	<remarks>
		*<p>This will test checksum first.</p>
		*<p>If checksum is changed and multi class processing it will check single classes for change.</p>
		*<p>This will parse out any class in a given vcx.
		*It checks for uniquenes of the UniqueID field of the vcx.
		*If this is not unique it will first make it unique.</p>
		*<p>A class is a record in the vcx with <expr>PLATFORM=="WINDOWS" AND LEN(PARENT)=0</expr> .</p>
		*<p>It will store information about the classes, not the classlib.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 10.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnStep      AS INTEGER,;
		 llDirty     AS BOOLEAN,;
		 llOk        AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llDirty = .F.
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE m.lnStep=1   &&test for changes on file (checksum)
		*llOk - nothing changed on file (we do not need to lookup classes too)
		   llOk = !THIS.Sync_File('V',m.tcFile,m.tlText2Bin,m.tcStorage)
		*/  &&m.lnStep=1  &&test for changes on file (checksum)
		
		  CASE m.lnStep=2 AND toSett.n_UseClassPerFile=0    &&Do not split classlib into classlib[.baseclass].class.vc2
		*Sync_File was dirty, we are dirty and done
		*Sync_File was dirty,
		*this could be one out of two problems
		*-file is not to be deleted (8,9) - we are not dirty
		   SELECT;
		    Cur1.iDirty;
		    FROM (m.tcStorage) AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType=='V';
		    AND Cur1.iDirty IN (8,9)
		*-if not found we are dirty
		   llDirty = RECCOUNT('curHelp')=0
		
		   USE IN curHelp
		* and done
		   llOk = .T.
		*/  &&m.lnStep=2 AND toSett.n_UseClassPerFile=0  &&Do not split into classlib[.baseclass].class.vc2
		
		  CASE m.lnStep=2
		*just loop
		
		  CASE m.lnStep=3  &&Test access
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=3 &&Test  access
		
		  CASE m.lnStep=4    &&Test if VCX is usable
		*okä, now test this thing
		   SELECT;
		    Cur1.UniqueID,;
		    COUNT(*) AS nCount;
		    FROM vcx AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0;
		    GROUP BY 1 HAVING nCount>1
		
		*/  &&m.lnStep=4   &&Test if VCX is usable
		
		  CASE m.lnStep=5 AND RECCOUNT()>0
		*UniqueID not so unique
		*rebuild, delete from Storage
		   TRY
		*Was zu testen ist
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx') EXCLUSIVE
		
		     SELECT vcx
		     REPLACE;
		      UniqueID WITH SYS(2015);
		      FOR PLATFORM='WINDOWS'
		
		     USE (m.tcFile) ALIAS vcx IN SELECT('vcx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&m.lnStep=5 &&Test if VCX is usable
		
		  CASE m.lnStep=5
		*just loop
		
		  CASE m.lnStep=6  &&test for changes on classes
		*(only if checksum is changed)
		
		*so now let's see if something is changed
		*get vcx data
		   SELECT;
		    CAST(Cur1.ObjName AS c(240))         AS cObjName,;
		    Cur1.UniqueID+BINTOC(Cur1.TIMESTAMP) AS cUniqueId;
		    FROM vcx AS Cur1;
		    INTO CURSOR curVCX;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0
		
		   INDEX ON cObjName  TAG _cObj
		   INDEX ON cUniqueId TAG _cUni
		
		   llDirty = THIS.Sync_Objects('v',m.tcFile,m.tlText2Bin,'curVCX',m.tcStorage)
		
		*/   &&m.lnStep=6 &&test for changes on classes
		
		  OTHERWISE && end loop
		   EXIT
		 ENDCASE
		
		 IF m.llDirty OR m.llOk THEN
		  EXIT
		 ELSE  &&m.llDirty
		  lnStep = m.lnStep+1
		 ENDIF &&m.llDirty OR m.llOk
		
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		USE IN SELECT('vcx')
		USE IN SELECT('curVCX')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty
		
		
	ENDPROC

	PROCEDURE convert		&& Convert complete set, not partial.
		LPARAMETERS;
		 taFiles,;
		 tlProcess,;
		 toConverter,;
		 tnOffset,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<descr>Converts a preprocessed bunch of files with FoxBin2Prg.Execute</descr>
		*!*	<params name="taFiles" type="Array" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*!*	<p>A Three column array.</p>
		*!*	<dl>
		*!*	 <dt>Column one</dt><dd>File to process.</dd>
		*!*	 <dt>Column two</dt><dd>Second parameter of FoxBin2PRG's Execute</dd>
		*!*	 <dt>Column three</dt><dd>Include file of colum 1 in output to screen</dd>
		*!*	</dl>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlProcess" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Value for FoxBin2PRG's l_ProcessFiles.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<params name="tnOffset" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Offset for progress bar.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">Operation successfully ended.</retval>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 18.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,13:00:00}">Changed by: SF<br />
		*!*	Modified to deal with single classes of libraries.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-28,12:00:00}">Changed by: SF<br />
		*!*	Modified to deal ::(import|export)
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2021-03-02,10:46:00}">Changed by: SF<br />
		*!*	Added functionality to display selected files only, and state of (pre) processing
		*!*	</change>
		*!*	</pdm>
		
		LOCAL;
		 lcFile_Test AS STRING
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile      AS CHARACTER,;
		 lnFile      AS NUMBER,;
		 lnFiles     AS NUMBER,;
		 llOk        AS BOOLEAN
		
		lnFiles	= ALEN(m.taFiles,1)
		llOk	= True
		
		toConverter.l_AutoClearProcessedFiles = .T.
		
		FOR lnFile = 1 TO m.lnFiles
		 ACTIVATE SCREEN
		
		 lcFile		 = m.taFiles(m.lnFile,1)
		 lcFile_Test = m.lcFile
		 IF '::'$m.lcFile_Test THEN
		  lcFile_Test = FORCEEXT(STRTRAN(m.lcFile_Test,'::','.',1,1),'')
		 ENDIF &&'::'$m.lcFile_Test
		
		 DO CASE
		  CASE !FILE(m.lcFile_Test) AND !DIRECTORY(m.lcFile_Test)
		   ?JUSTFNAME(m.lcFile)+" - not found"
		   LOOP
		  CASE m.taFiles(m.lnFile,3)
		   ?JUSTFNAME(m.lcFile)
		 ENDCASE
		
		 toConverter.l_ProcessFiles = .T.
		 m.toConverter.UpdateProgressbar('',m.lnFile+m.tnOffset,m.lnFiles+m.tnOffset+1,0)
		 toConverter.l_ProcessFiles				  = m.tlProcess
		 toConverter.l_ClassPerFileCheck		  = .F.
		 toConverter.l_RedirectClassPerFileToMain = .T.
		
		*!*	obj.execute(cInputFile [,cType [,cTextName [,lGenText [,cDontShowErrors [,cDebug;
		*!*	 [,cDontShowProgress [,oModule [,oEx [,lRelanzarError [,cOriginalFileName;
		*!*	 [,cRecompile [,cNoTimestamps [,cBackupLevels [,cClearUniqueID [,cOptimizeByFilestamp [,cCFG_File]]]]]]]]]]]]]]])
		* IF m.toConverter.Execute(m.lcFile,m.taFiles(m.lnFile,2),"0","0","0","1","1",,,,,,,,,,)#0 THEN
		 IF m.toConverter.Execute(m.lcFile,m.taFiles(m.lnFile,2),"0","0","0","0","1",,,,,,,,,,m.toFB2T_Setting)#0 THEN
		  llOk = .F.
		  EXIT
		 ENDIF &&toConverter.Execute(m.lcFile,taFiles(m.lnFile,2),"0","0","0","0","1", ,,,,,,,,,m.toFB2T_Setting)#0
		
		 toConverter.l_AutoClearProcessedFiles = .F.
		ENDFOR &&lnFile
		
		RETURN m.llOk
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS;
		 tnError,;
		 tcMethod,;
		 tnLine
		
		LOCAL ARRAY;
		 laError(1,7)
		
		AERROR(laError)
		MESSAGEBOX('Ooops, works not as expected.'+0h0d0a0d0a+;
		'Error:'+PADL(m.tnError,5)+', '+MESSAGE()+0h0d0a+;
		 'Code block: '+THIS.CLASS+'.'+m.tcMethod+0h0d0a+;
		 'Code line: '+PADL(m.tnLine,7),;
		 64,'Bin2Text v'+dcB2T_Verno)
		DEBUG
		SUSPEND
		RETRY
		CANCEL
		
		*!*	<pdm>
		*!*	<descr>Just a bit more then just let it crash.</descr>
		*!*	<params name="tnError" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcMethod" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tnLine" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
	ENDPROC

	PROCEDURE filestoprocess		&& Test if files are changed since last run.
		LPARAMETERS;
		 taFiles,;
		 tcPath,;
		 tlText2Bin,;
		 tlCheckAll,;
		 tcStorage,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Test if files are changed since last run.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*<p>The output of FoxBin2Prg <b>Get_Processed</b> method.</p>
		*<p>After return the Array will hold files to be processed.</p>
		*</detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source path of the Operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*<p>Checks if all files listed in <pdmpara num="5" /> are used in <pdmpara num="1" />.</p>
		*<p>If a file is not found, text file corresponding will be deleted.</p>
		*<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">Notes if the array need to be processed.</retval>
		*!*	<remarks>
		*<p>Parses <pdmpara num="1" /> for binaries that can be checked for changed. For now this will be scx and vcx files.</p>
		*<p>The actual state will be stored in a file <b>Bin2Txt.DBF</b> in <pdmpara num="2" /> path.</p>
		*<p>This file will hold information about any object of a vcx and information about scx.</p>
		*<p>The function will not handle any <b>source</b> file not found in the Array.</p>
		*<p>It is possible to delete splitted classes text file if the class is removed from an scx /vcx.</p>
		*<p>If <pdmpara num="4" /> is true, text files for binary files removed might be deleted too.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 5.6.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" />
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile    AS CHARACTER,;
		 lnLine    AS NUMBER,;
		 lnLines   AS NUMBER,;
		 lnInPut   AS NUMBER,;
		 lnDirty   AS NUMBER,;
		 llDirty   AS BOOLEAN,;
		 loSett    AS OBJECT
		
		STORE ALEN(taFiles,1) TO;
		 lnLines,;
		 lnInPut
		
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:31:00}">Changed by: SF<br />
		*!*	Handle deletion of obsolete text files for binaries.
		*!*	</change>
		*!*	</pdm>
		
		 IF m.tlCheckAll THEN
		*we clean up now, because of post-processing
		*we clean up deleted now, because of post-processing
		 DELETE Cur1;
		  FROM (m.tcStorage) AS Cur1;
		  WHERE Cur1.iDirty=-2
		
		*check obsolete files
		 UPDATE Cur1 SET;
		  iDirty   = -1,;
		  tLastUse = DATETIME();
		  FROM (m.tcStorage) AS Cur1;
		  WHERE !EMPTY(Cur1.cFile);
		  AND Cur1.cType IN ('V','v','R','M','d','D','P','B','K','k','f','m')
		ENDIF &&m.tlCheckAll
		*!*	/Changed by: SF 4.6.2015
		
		lnDirty = 0
		FOR lnLine = lnLines TO 1 STEP -1
		 lcFile  = taFiles(m.lnLine,1)
		 llDirty = .F.
		 DO CASE
		  CASE !TRIM(taFiles(m.lnLine,2))=="O" AND  m.tlText2Bin
		*ToBin, we process only output (binaries only)
		   lnInPut = m.lnInPut-1
		  CASE !TRIM(taFiles(m.lnLine,2))=="I" AND !m.tlText2Bin
		*ToText, we process only input
		   lnInPut = m.lnInPut-1
		  CASE !TRIM(taFiles(m.lnLine,3))=="P1"
		*File must be processed
		   lnInPut = m.lnInPut-1
		  CASE !TRIM(taFiles(m.lnLine,6))=="X0"
		*file must be main file, no split file
		   lnInPut = m.lnInPut-1
		  CASE UPPER(JUSTEXT(m.lcFile))=="VCX"
		   loSett  = THIS.OGet_Setting(JUSTPATH(m.lcFile),m.toConverter)
		   llDirty = THIS.Check_VCX(UPPER(m.lcFile),tcPath,m.tlText2Bin,m.tcStorage,m.loSett)
		  CASE UPPER(JUSTEXT(m.lcFile))=="FRX"
		   llDirty = THIS.Sync_File('R',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="MNX"
		   llDirty = THIS.Sync_File('M',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="DBF"
		   llDirty = THIS.Sync_File('D',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		*   llDirty = THIS.Sync_File('d',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="DBC"
		   llDirty = THIS.Sync_File('d',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		*   llDirty = THIS.Sync_File('D',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="PJX"
		   llDirty = THIS.Sync_File('P',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="LBX"
		   llDirty = THIS.Sync_File('B',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="SCX"
		   loSett  = THIS.OGet_Setting(JUSTPATH(m.lcFile),m.toConverter)
		   llDirty = THIS.Check_SCX(UPPER(m.lcFile),tcPath,m.tlText2Bin,m.tcStorage,m.loSett)
		
		  CASE UPPER(JUSTEXT(m.lcFile))=="MEM"
		   llDirty = THIS.Sync_File('m',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  CASE UPPER(JUSTEXT(m.lcFile))=="FKY"
		   llDirty = THIS.Sync_File('f',UPPER(m.lcFile),m.tlText2Bin,m.tcStorage)
		  OTHERWISE
		   llDirty = .T.
		 ENDCASE
		 IF m.llDirty THEN
		  lnDirty = m.lnDirty+1
		 ELSE  &&m.llDirty
		  ADEL(taFiles,MAX(m.lnLine,1))
		 ENDIF &&m.llDirty
		ENDFOR &&m.lnLine
		
		DIMENSION;
		 taFiles(MAX(m.lnDirty,1),ALEN(taFiles,2))
		
		IF m.lnDirty<1 THEN
		 taFiles = ''
		ENDIF &&m.lnDirty<1
		
		RETURN IIF(m.lnDirty=m.lnInPut,NIL,m.lnDirty>0)
		
	ENDPROC

	PROCEDURE get_converter		&& Create FoxBin2PRG object.
		LPARAMETERS;
		 tcStorage,;
		 toConverter,;
		 tlCloseTable
		
		*!*	<pdm>
		*!*	<descr>Create converter object and open storage table</descr>
		*!*	<params name="tcStorage" type="Character" byref="1" dir="Out" inb="0" outb="0">
		*!*	<short>Alias of storage table.</short>
		*!*	<detail><expr>.NULL.</expr> if not found or closed by <pdmpara num="3" />. </detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Character" byref="1" dir="Out" inb="0" outb="0">
		*!*	<short>Instance of FoxBin2PRG.</short>
		*!*	<detail><expr>.NULL.</expr> id not instantiated. </detail>
		*!*	</params>
		*!*	<params name="tlCloseTable" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Do not keep storage table open.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Error</retval>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnResult AS NUMBER,;
		 llOk     AS BOOLEAN
		
		llOk = True
		IF PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path) THEN
		 tcStorage = THIS.Storage_Open(_SCREEN.gcB2T_Path)
		
		ELSE  &&PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		 tcStorage = THIS.Storage_Check(False)
		
		ENDIF &&PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		
		IF ISNULL(m.tcStorage) THEN
		 llOk = False
		ENDIF &&ISNULL(m.tcStorage)
		
		IF m.llOk THEN
		 toConverter = NEWOBJECT("c_foxbin2prg",_SCREEN.gcB2T_FB2T)
		 IF !VARTYPE(m.toConverter)="O" OR ISNULL(m.toConverter) THEN
		  toConverter = NIL
		  llOk		  = False
		 ENDIF &&!TYPE(toConverter)="O" OR ISNULL(m.toConverter)
		ELSE  &&m.llOk
		 toConverter = NIL
		ENDIF &&m.llOk
		
		IF m.llOk THEN
		 lnResult = Compare_Verno(dcFB2P_Verno_Min,m.toConverter.c_FB2PRG_VERSION_REAL)
		
		 DO CASE
		
		  CASE m.lnResult=1
		*FoxBin2Prg
		*update added here ....
		   ?"Wrong version of FoxBin2Prg, min Version: "+dcFB2P_Verno_Min
		   toConverter = NIL
		   llOk		   = False
		
		  OTHERWISE
		* m.lnResult In 0, 12
		*version fit, do nothing
		
		 ENDCASE
		ENDIF &&m.llOk
		
		IF (!m.llOk OR m.tlCloseTable) AND !ISNULL(m.tcStorage) THEN
		 THIS.Storage_Close(m.tcStorage,True)
		 tcStorage = NIL
		ENDIF &&(!m.llOk OR tlCloseTable) AND !ISNULL(m.tcStorage)
		
		llOk = !m.llOk
		
		RETURN m.llOk
		
	ENDPROC

	PROCEDURE get_dbc_tables		&& Return the tables of DBCs processed.
		LPARAMETERS;
		 taSource,;
		 taSearched,;
		 taReturn,;
		 tnOffset,;
		 tcMode,;
		 tlText2Bin,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Resolve tables of databases.</descr>
		*!*	<params name="taSource" type="Array" byref="1" dir="In" inb="0" outb="0">
		*!*	<short>Source array.</short>
		*!*	<detail>Array what is parsed for Datrabases. The databases found in column 1 where searched for tables.</detail>
		*!*	</params>
		*!*	<params name="taSearched" type="Array" byref="1" dir="In" inb="0" outb="0">
		*!*	<short>Array with tables.</short>
		*!*	<detail>This array is checked for tables found in the databases.
		*!*	If an entry is found in column 1, the table will not be added to <pdmpara num="3" />.</detail>
		*!*	</params>
		*!*	<params name="taReturn" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<shortArray that will hold tables found.</short>
		*!*	<detail>Tables will be added to the array.<p/>
		*!*	Table structure is the one of parameter taFiles of <see pem="Convert" /></detail>
		*!*	</params>
		*!*	<params name="tnOffset" type="Numeric" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>The last valid record in <pdmpara num="3" /></short>
		*!*	<detail>tables will be appended after this row. The array will be resized to it's lenght. Will hold total row number at return.</detail>
		*!*	</params>
		*!*	<params name="tcMode" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>FoxBin2PRG's mode switch.</short>
		*!*	<detail>
		*!*	"PRG2BIN","BIN2PRG" for the use of FoxBin2Prg.
		*</detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="In" inb="0" outb="0">
		*!*	<short>Direction of operation,</short>
		*!*	<detail>To determin file extension.</detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="In" inb="0" outb="0">
		*!*	<short>FoxBin2Prg object.</short>
		*!*	<detail>To get settings.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">At least one table is added to <pdmpara num="3" /></retval>
		*!*	<remarks></remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 3.3.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		 
		EXTERNAL ARRAY;
		 taSource,;
		 taSearched,;
		 taReturn
		
		LOCAL;
		 lcFile       AS STRING,;
		 lcTable      AS STRING,;
		 lcDataBase   AS STRING,;
		 lcExt        AS STRING,;
		 lcExt1       AS STRING,;
		 lnDBCFound   AS NUMBER,;
		 lnFile       AS NUMBER,;
		 lnFiles      AS NUMBER,;
		 lnTable      AS NUMBER,;
		 lnTableFound AS NUMBER,;
		 lnTables     AS NUMBER,;
		 lnCols       AS NUMBER,;
		 llReturn     AS BOOLEAN,;
		 loSett       AS OBJECT
		
		LOCAL ARRAY;
		 laDatabases(1,4),;
		 laTables(1)
		
		lnFiles	= ALEN(m.taSource,1)
		lnCols	= ALEN(m.taReturn,2)
		
		laDatabases = ""
		= ADATABASES(laDatabases)
		
		FOR lnFile = 1 TO m.lnFiles
		 lcFile	= m.taSource(m.lnFile,1)
		 lcExt	= 'DBC'
		 loSett	= THIS.oGet_Setting(JUSTPATH(m.lcFile),m.toConverter)
		 lcExt1	= UPPER(m.loSett.c_DC2)
		
		 IF UPPER(JUSTEXT(m.lcFile))==m.lcExt OR UPPER(JUSTEXT(m.lcFile))==m.lcExt1 THEN
		* simply add the tables up to us in the array, if missing they will be removed in the next loops
		  lcFile	 = FORCEEXT(m.lcFile,'DBC')
		  lnDBCFound = ASCAN(m.laDatabases,m.lcFile,1,-1,2,15)
		  lcDataBase = DBC()
		
		  IF EMPTY(m.lnDBCFound) THEN
		   OPEN DATABASE (m.lcFile) SHARED NOUPDATE
		  ELSE  &&EMPTY(m.lnDBCFound)
		   SET DATABASE TO (m.lcFile)
		  ENDIF &&EMPTY(m.lnDBCFound)
		
		  lnTables = ADBOBJECTS(m.laTables,"TABLE")
		  llReturn = m.llReturn OR m.lnTables>0
		
		  FOR lnTable = 1 TO m.lnTables
		   lcTable		= FORCEEXT(FULLPATH(m.laTables(m.lnTable),m.lcFile),'DBF')
		   lnTableFound	= ASCAN(m.taSearched,m.lcTable,1,-1,2,15)
		   IF EMPTY(m.lnTableFound) THEN
		    tnOffset   = m.tnOffset+1
		    DIMENSION;
		     m.taReturn(m.tnOffset,m.lnCols)
		
		    IF m.tlText2Bin THEN
		     loSett	 = THIS.oGet_Setting(JUSTPATH(m.lcTable),m.toConverter)
		     lcTable = FORCEEXT(m.lcTable,m.loSett.c_DB2)
		    ENDIF &&m.tlText2Bin
		
		    taReturn(m.tnOffset,1) = m.lcTable
		    taReturn(m.tnOffset,2) = m.tcMode
		    IF m.lnCols>2 THEN
		     taReturn(m.tnOffset,3)	= m.lcTable
		     taReturn(m.tnOffset,4)	= 0											&&no Hook
		    ENDIF &&m.lnCols>2
		   ENDIF &&EMPTY(m.lnTableFound)
		
		  ENDFOR &&lnTable
		
		  IF EMPTY(m.lnDBCFound) THEN
		   CLOSE DATABASES
		  ENDIF &&EMPTY(m.lnDBCFound)
		  SET DATABASE TO (m.lcDataBase)
		* add tables of the DBC
		
		 ENDIF &&UPPER(JUSTEXT(m.lcFile))==m.lcExt OR UPPER(JUSTEXT(m.lcFile))==m.lcExt1
		ENDFOR &&lnFile
		
		RETURN m.llReturn
		
	ENDPROC

	PROCEDURE get_md5
		#IF .F. THEN
		 #include "C:\Program Files (x86)\Microsoft Visual FoxPro 9\ffc\wincrypt.h"
		
		* This routine takes a string as input
		* and returns an MD5 hash value as a string.
		*
		* The calculation in implemented using the MS Crypto API and the RSA provider.
		 LPARAMETERS;
		  tcData
		
		 LOCAL;
		  lnStatus,;
		  lnErr,;
		  lhProv,;
		  lhHashObject,;
		  lnDataSize,;
		  lcHashValue,;
		  lnHashSize
		
		 lhProv = 0
		 lhHashObject = 0
		 lnDataSize = LEN(tcData)
		 lcHashValue = REPLICATE(CHR(0), 16)
		 lnHashSize = LEN(lcHashValue)
		
		
		 TRY
		
		   DECLARE INTEGER GetLastError ;
		    IN win32api AS GetLastError
		
		   DECLARE INTEGER CryptAcquireContextA ;
		    IN WIN32API AS CryptAcquireContext ;
		    INTEGER @lhProvHandle, ;
		    STRING  cContainer, ;
		    STRING  cProvider, ;
		    INTEGER nProvType, ;
		    INTEGER nFlags
		
		* load a crypto provider
		   lnStatus = CryptAcquireContext(@lhProv, 0, 0, dnPROV_RSA_FULL, dnCRYPT_VERIFYCONTEXT)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		   DECLARE INTEGER CryptCreateHash ;
		    IN WIN32API AS CryptCreateHash ;
		    INTEGER hProviderHandle, ;
		    INTEGER nALG_ID, ;
		    INTEGER hKeyhandle, ;
		    INTEGER nFlags, ;
		    INTEGER @hCryptHashHandle
		
		* create a hash object that uses MD5 algorithm
		   lnStatus = CryptCreateHash(lhProv, dnCALG_MD5, 0, 0, @lhHashObject)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptHashData ;
		    IN WIN32API AS CryptHashData ;
		    INTEGER hHashHandle, ;
		    STRING  @cData, ;
		    INTEGER nDataLen, ;
		    INTEGER nFlags
		
		* add the input data to the hash object
		   lnStatus = CryptHashData(lhHashObject, tcData, lnDataSize, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptGetHashParam ;
		    IN WIN32API AS CryptGetHashParam ;
		    INTEGER hHashHandle, ;
		    INTEGER nParam, ;
		    STRING  @cHashValue, ;
		    INTEGER @nHashSize, ;
		    INTEGER nFlags
		
		* retrieve the hash value, if caller did not provide enough storage (16 bytes for MD5)
		* this will fail with dnERROR_MORE_DATA and lnHashSize will contain needed storage size
		   lnStatus = CryptGetHashParam(lhHashObject, dnHP_HASHVAL, @lcHashValue, @lnHashSize, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptDestroyHash ;
		    IN WIN32API AS CryptDestroyHash;
		    INTEGER hKeyHandle
		
		* free the hash object
		   lnStatus = CryptDestroyHash(lhHashObject)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptReleaseContext ;
		    IN WIN32API AS CryptReleaseContext ;
		    INTEGER hProvHandle, ;
		    INTEGER nReserved
		
		* release the crypto provider
		   lnStatus = CryptReleaseContext(lhProv, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		  CATCH TO lnErr
		
		* clean up the hash object and release provider
		   IF lhHashObject != 0
		    CryptDestroyHash(lhHashObject)
		   ENDIF
		
		
		   IF lhProv != 0
		    CryptReleaseContext(lhProv, 0)
		   ENDIF
		
		   ERROR("HashMD5 Failed")
		
		 ENDTRY
		
		 RETURN lcHashValue
		#ENDIF &&.F.
		
	ENDPROC

	PROCEDURE oget_setting		&& Returns a settings object of a given path with config from FoxBin2PRG.
		LPARAMETERS;
		 tcPath,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Returns FoxBin2Prg's setting.</descr>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source path of the operation</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<retval type="Object">Settings object of FoxBin2Prg.</retval>
		*!*	<remarks>Returns FoxBin2Prg's setting for path <pdmpara num="1" />.</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 13.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcTemp    AS CHARACTER,;
		 loSett    AS OBJECT
		
		
		IF !PEMSTATUS(THIS,'goSetts',5) THEN
		 THIS.ADDPROPERTY('goSetts',NEWOBJECT("COLLECTION"))
		ENDIF &&!PEMSTATUS(THIS,'goSetts',5)
		
		lcTemp = SYS(2007,UPPER(tcPath),0,2)
		IF THIS.goSetts.GETKEY(m.lcTemp)#0 THEN
		 loSett = THIS.goSetts.ITEM(m.lcTemp)
		ELSE  &&THIS.goSetts.GETKEY(m.lcTemp)#0
		 loSett = toConverter.Get_DirSettings(tcPath)
		 THIS.goSetts.ADD(m.loSett,m.lcTemp)
		ENDIF &&THIS.goSetts.GETKEY(m.lcTemp)#0
		
		RETURN m.loSett
		
	ENDPROC

	PROCEDURE process_bin2txt		&& Process all files of a given array to text files.
		LPARAMETERS;
		 taFiles,;
		 tcMode,;
		 tlCheckAll,;
		 tlIncludeAll,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<descr>Process all files of a given Array.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*!*	<p>List of files to process.</p>
		*!*	<p>Allways binaries, even if as target not existing yet!.</p>
		*!*	<p>The method determines correct extensions for text files itself.</p>
		*!*	<p>The array can be one or two dimensional</p>
		*!*	<dl>
		*!*	 <dt>Column one</dt><dd>Binary file with path.</dd>
		*!*	 <dt>Column two</dt>
		*!*	  <dd>
		*!*	   Optional. Defines a ProjectHook.<br />
		*!*	   <expr>.NULL.</expr> if not determined, Empty, if no ProjectHook is to be processed.<br />
		*!*	   Only valid for PJX files in column one.
		*!*	  </dd>
		*!*	 <dt>Column three</dt>
		*!*	 <dd>
		*!*	  Additional files to process, non structural index-files for DBF.
		*!*	  List of files, delimited by <expr>CHR(0)</expr>, starting with <expr>CHR(0)</expr>.<br/>
		*!*	  Ignored if empty.
		*!*	 </dd>
		*!*	</dl>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*!*	<p>Checks if all files listed in <pdmpara num="1" /> are used.</p>
		*!*	<p>If a file is not found, text file corresponding will be deleted.</p>
		*!*	<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlIncludeAll" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Convert all files.</short>
		*!*	<detail>
		*!*	<p>Controls if all files are transformed.</p>
		*!*	<p>Only the files changed might be transformed.
		*!*	This can override stored setting.</p>
		*!*	<p>If True, the file will not be synched with the storage table.</p>
		*!*	<p>If parameter is not passed, this default to the setting stored.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.<br />
		*Will be passed to <see pem="Convert" /></detail>
		*!*	</params>
		
		*!*	<retval type="Boolean">Returns succcess of operation.</retval>
		*!*	<remarks>
		*!*	<b>This is the main method. What makes it different from a plain call to FoxBin2Prg is:</b>
		*!*	<ul>
		*!*	 <li>Accepts a mixed array of files. (including whole PJX) </li>
		*!*	 <li>Can limit the Bin2Text operation to dirty files only.</li>
		*!*	 <li>Can delete obsolete class files in ClassPerFile operations.</li>
		*!*	 <li>Can delete obsolete files for removed binaries if <pdmpara num="3" />.</li>
		*!*	</ul>
		*!*	<p>If text to binary, it just passes the files to FoxBin2Prg</p>
		*!*	<p>Creating text files, depending on a setting, it first let check FoxBin2Prg what to do.
		*!*	 IOW what files are included in the process.</p>
		*!*	<p>Then it calls for <see pem="FilesToProcess" /> to see if files are changed.
		*!*	 Only files marked as dirty will be processed.</p>
		*!*	<p>A postprocess will delete / remove obsolete text files.</p>
		*!*	</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="3" />
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,13:00:00}">Changed by: SF<br />
		*!*	Modified to deal with single classes of libraries.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,14:00:00}">Changed by: SF<br />
		*!*	<pdmpara num="1" /> may now hold text files for Text To Bin operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,16:00:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" /> to force single file operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-28,12:00:00}">Changed by: SF<br />
		*!*	Modified to deal ::(import|export)
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile        AS CHARACTER,;
		 lcMode        AS CHARACTER,;
		 lcPath        AS CHARACTER,;
		 lcSourceExt   AS CHARACTER,;
		 lcStorage     AS CHARACTER,;
		 lcTarget      AS CHARACTER,;
		 lcClass       AS CHARACTER,;
		 lnFile        AS NUMBER,;
		 lnFilesFound  AS NUMBER,;
		 lnTable       AS NUMBER,;
		 lnOffsets     AS NUMBER,;
		 lnConvert     AS NUMBER,;
		 lnTableFound  AS NUMBER,;
		 llFound       AS BOOLEAN,;
		 llMaxiLoop    AS BOOLEAN,;
		 llSingleClass AS BOOLEAN,;
		 llProcess     AS BOOLEAN,;
		 llExpandDBC   AS BOOLEAN,;
		 llPJXOpen     AS BOOLEAN,;
		 llPJXUsed     AS BOOLEAN,;
		 lvTime        AS VARIANT,;
		 loProject     AS PROJECT,;
		 loException   AS EXCEPTION,;
		 loSetting     AS EMPTY,;
		 loSett        AS OBJECT,;
		 loExtraFiles  AS OBJECT,;
		 loConverter   AS "c_foxbin2prg" OF "E:\x\Helper\ThirdParty\VFPX\FoxBin2PRG\FOXBIN2PRG.PRG"
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 m.lnFiles,;
		 m.lnOffsets
		
		lcMode = "BIN2PRG"
		
		loExtraFiles = NEWOBJECT('collection')
		THIS.Storage_Get("S",m.loExtraFiles,m.lcStorage)
		
		* Check Include DBF of DBC [1 On; else OFF]
		IF !EMPTY(m.loExtraFiles.GETKEY("gcB2T_DBC")) THEN
		 loSetting = m.loExtraFiles.ITEM("gcB2T_DBC")
		 llExpandDBC = m.loSetting.gcFile=="1"
		ENDIF &&!EMPTY(loExtraFiles.GetKey("gcB2T_DBC"))
		* /Check Include DBF of DBC [1 On; else OFF]
		
		*!*	Changed  by: SF 28.2.2021
		*!*	<pdm>
		*!*	<change date="{^2021-02-28,21:02:00}">Changed  by: SF<br />
		*!*	Add List of files stored with settings.
		*!*	</change>
		*!*	</pdm>
		
		IF ATC('-IncludeList',m.tcMode)>0 THEN
		 tcMode        = STRTRAN(m.tcMode,'-IncludeList','',1,-1,1)
		
		 m.loExtraFiles.REMOVE(-1)
		 THIS.Storage_Get("A",m.loExtraFiles,m.lcStorage)
		
		 FOR EACH loSetting IN m.loExtraFiles FOXOBJECT
		  IF EMPTY(ASCAN(m.taFiles,m.loSetting.gcFile,1,-1,2,15)) THEN
		*additional file not found. Add
		   lnFiles   = m.lnFiles+1
		   lnOffsets = m.lnOffsets+1
		   DIMENSION;
		    m.taFiles(m.lnFiles,ALEN(m.taFiles,2))
		
		   taFiles(m.lnFiles,1)	= m.loSetting.gcFile
		   taFiles(m.lnFiles,2)	= m.lcMode
		  ENDIF &&EMPTY(ASCAN(m.taFiles,m.lcFile,1,-1,2,15))
		
		 ENDFOR &&loSetting
		
		ENDIF &&ATC('-IncludeList',m.tcMode)>0
		
		*!*	/Changed  by: SF 28.2.2021
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,4),;
		 laToConvert(1,4),;
		 laDBC_Tables(1,4),;
		 laDBCs(1,2)
		
		laDBCs = .NULL.
		
		lnFilesFound = 0
		lnTableFound = 0
		
		* Process Databases that are within the array
		* Databases in PJX will be parsed out later
		FOR lnFile = 1 TO m.lnFiles
		 laFiles(m.lnFile,1) = m.taFiles(m.lnFile,1)
		ENDFOR &&lnFile
		
		THIS.Get_DBC_Tables(@laFiles,@laFiles,@laDBC_Tables,@lnTableFound,m.lcMode,.F.,m.loConverter)
		
		DIMENSION;
		 m.laFiles(m.lnFiles,4)
		
		laFiles     = NIL
		* /Process Databases that are within the array
		
		*process sourcefiles
		lnFile = 0
		DO WHILE m.lnFile<m.lnFiles
		 lnFile		  = m.lnFile+1
		 lnFilesFound = m.lnFilesFound+1
		*wie machen wir das, wenn wir noch keine pjx haben?!!!
		
		*extract class for processing
		 lcClass = ""
		 IF '::'$m.taFiles(m.lnFile,1) THEN
		  taFiles(m.lnFile,1) = STRTRAN(m.taFiles(m.lnFile,1),'::','.',1,1)
		  lcClass			  = "::"+JUSTEXT(m.taFiles(m.lnFile,1))
		  taFiles(m.lnFile,1) = FORCEEXT( m.taFiles(m.lnFile,1),'')
		  llSingleClass		  = True
		 ENDIF &&'::'$taFiles(m.lnFile,1)
		
		 loSett		 = THIS.oGet_Setting(JUSTPATH(m.taFiles(m.lnFile,1)),m.loConverter)
		 lcSourceExt = UPPER(JUSTEXT(m.taFiles(m.lnFile,1)))
		
		*check if just a binary file name is send, as expected
		 DO CASE
		  CASE UPPER(m.lcSourceExt)=="VCX"
		  CASE UPPER(m.lcSourceExt)=="FRX"
		  CASE UPPER(m.lcSourceExt)=="MNX"
		  CASE UPPER(m.lcSourceExt)=="DBF"
		  CASE UPPER(m.lcSourceExt)=="DBC"
		  CASE UPPER(m.lcSourceExt)=="PJX"
		  CASE UPPER(m.lcSourceExt)=="LBX"
		  CASE UPPER(m.lcSourceExt)=="SCX"
		  CASE UPPER(m.lcSourceExt)=="SCX"
		*Additional extensions
		  CASE UPPER(m.lcSourceExt)=="FKY"
		  CASE UPPER(m.lcSourceExt)=="MEM"
		  OTHERWISE
		*Error, no known extension
		   lcSourceExt = ""
		 ENDCASE
		
		 IF EMPTY(m.lcSourceExt) THEN
		*undefined extension, just ignore
		  ADEL(m.laFiles,m.lnFilesFound)
		  lnFilesFound = m.lnFilesFound-1
		  lnOffsets	   = m.lnOffsets-1
		  IF m.lnFilesFound=0 THEN
		   EXIT
		
		  ELSE  &&m.lnFilesFound=0
		   DIMENSION;
		    m.laFiles(m.lnOffsets,4)
		   LOOP
		  ENDIF &&m.lnFilesFound=0
		
		 ELSE  &&EMPTY(m.lcSourceExt)
		  laFiles(m.lnFilesFound,1) = FORCEEXT(m.taFiles(m.lnFile,1),m.lcSourceExt)+;
		   m.lcClass															&&Source File of transformation; Text or Text
		 ENDIF &&EMPTY(m.lcSourceExt)
		
		 laFiles(m.lnFilesFound,2) = m.tcMode 									&&a project file bin or text
		 laFiles(m.lnFilesFound,3) = m.taFiles(m.lnFile,1)						&&VFP Bin File
		 DO CASE
		  CASE !UPPER(JUSTEXT(m.taFiles(m.lnFile,1)))='PJX'
		*nothing to do
		   laFiles(m.lnFilesFound,2) = m.lcMode									&&not a project file
		   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		*odd order?, next three pairs:
		*!*	  CASE ALEN(m.taFiles,2)<2
		*!*	*nothing defined yet, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but maybe after conversion
		*!*	  CASE ALEN(m.taFiles,2)<2 AND !m.tlText2Bin
		*!*	*nothing defined, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		  CASE ALEN(m.taFiles,2)<2
		*nothing defined, parse later
		   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		*!*	  CASE ISNULL(m.taFiles(m.lnFile,2))
		*!*	*nothing defined yet, parse again after processing (if pjx changed)
		*!*	   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE ISNULL(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*nothing defined yet, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		  CASE ISNULL(m.taFiles(m.lnFile,2))
		*nothing defined yet, parse later
		   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		*!*	  CASE EMPTY(m.taFiles(m.lnFile,2))
		*!*	*nothing hook defined yet, but may change again after processing (if pjx changed)
		*!*	   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE EMPTY(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*no Hook, do nothing
		*!*	   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		  CASE EMPTY(m.taFiles(m.lnFile,2))
		*no Hook, do nothing
		   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		
		  OTHERWISE
		*Hook, to text
		   lnOffsets = m.lnOffsets+1
		   DIMENSION;
		    m.laFiles(m.lnOffsets,4)
		
		   laFiles(m.lnOffsets,1) = m.taFiles(m.lnFile,2)						&&Source File of transformation; Bin
		   laFiles(m.lnOffsets,2) = m.lcMode									&&not a project file
		   laFiles(m.lnOffsets,3) = m.taFiles(m.lnFile,2)						&&VFP Bin File
		   laFiles(m.lnOffsets,4) = 0											&&no Hook
		
		   laFiles(m.lnFilesFound,4) = 0										&&no Hook
		 ENDCASE
		ENDDO &&m.lnFile<m.lnFiles
		
		*!*	Change by: SF 15.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-15,06:56:00}">Change by: SF<br />
		*!*	Preprocessing <expr>PROJECTHOOKLIBRARY</expr> only for Bin 2 Text
		*!*	</change>
		*!*	</pdm>
		
		*process transformation, only for Bin 2 Text (Text 2 Bin will be read after recreating)
		FOR lnFile = 1 TO m.lnFilesFound
		 lcFile = m.laFiles(m.lnFile,3)
		
		 IF FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX' THEN
		  llPJXOpen = .F.
		
		  TRY
		*Was zu testen ist
		    _VFP.PROJECTS.ITEM(m.lcFile)
		    llPJXOpen = .T.
		
		   CATCH TO loException WHEN m.loException.ERRORNO=1429 OR m.loException.ERRORNO=1428
		* Abzufangender Fehler
		    llPJXOpen = .F.
		   CATCH TO loException
		* andere Fehler, Standardhandler rufen
		    THROW
		   FINALLY
		    llPJXUsed = .F.
		  ENDTRY
		
		* parse out DBC
		  IF m.llExpandDBC THEN
		   IF !m.llPJXOpen AND !m.llPJXUsed THEN
		    MODIFY PROJECT (m.lcFile) NOWAIT NOSHOW NOPROJECTHOOK
		    llPJXUsed = .T.
		   ENDIF &&!m.llPJXOpen AND !m.llPJXUsed
		   TRY
		*Was zu testen ist
		     loProject = _VFP.PROJECTS(JUSTFNAME(m.lcFile))
		
		    CATCH TO loException WHEN m.loException.ERRORNO=1429 OR m.loException.ERRORNO=1428
		* Abzufangender Fehler -> project open cancled
		     llPJXUsed = .F.
		    CATCH TO loException
		* andere Fehler, Standardhandler rufen
		     THROW
		    FINALLY
		
		   ENDTRY
		
		   IF !m.llPJXUsed THEN
		    LOOP
		   ENDIF &&!m.llPJXUsed
		
		   lnTable = 0
		
		   FOR EACH m.lcTarget IN m.loProject.FILES FOXOBJECT
		    IF m.lcTarget.TYPE=='d' THEN
		
		     lcTarget = ALLTRIM(m.lcTarget.NAME)
		
		     lnTable = m.lnTable+1
		     DIMENSION;
		      m.laDBCs(m.lnTable,2)
		
		     laDBCs(m.lnTable,1) = m.lcTarget			&&Source File of transformation; Bin
		     laDBCs(m.lnTable,2) = m.lcMode				&&not a project file
		    ENDIF &&m.lcTarget.TYPE=='d'
		   ENDFOR &&m.lcTarget
		
		   IF m.lnTable>0 THEN
		    THIS.Get_DBC_Tables(@laDBCs,@laFiles,@laDBC_Tables,@lnTableFound,m.lcMode,.F.,m.loConverter)
		   ENDIF &&lnTable>0
		
		   lnTable = 0
		   DIMENSION;
		    m.laDBCs(1,2)
		
		   laDBCs = .NULL.
		  ENDIF &&m.llExpandDBC
		* /parse out DBC
		
		  IF m.laFiles(m.lnFile,4)=1 THEN
		
		   IF !m.llPJXOpen AND !m.llPJXUsed THEN
		    MODIFY PROJECT (m.lcFile) NOWAIT NOSHOW NOPROJECTHOOK
		    llPJXUsed = .T.
		   ENDIF &&!m.llPJXOpen AND !m.llPJXUsed
		
		   TRY
		*Was zu testen ist
		     loProject = _VFP.PROJECTS(JUSTFNAME(m.lcFile))
		
		    CATCH TO loException WHEN m.loException.ERRORNO=1429 OR m.loException.ERRORNO=1428
		* Abzufangender Fehler -> project open cancled
		     llPJXUsed = .F.
		    CATCH TO loException
		* andere Fehler, Standardhandler rufen
		     THROW
		    FINALLY
		
		   ENDTRY
		
		   IF !m.llPJXUsed THEN
		    LOOP
		   ENDIF &&!m.llPJXUsed
		
		   lcFile = ALLTRIM(m.loProject.PROJECTHOOKLIBRARY)
		
		   IF !EMPTY(m.lcFile) THEN
		    lnOffsets = m.lnOffsets+1
		    DIMENSION;
		     m.laFiles(m.lnOffsets,4)
		
		    laFiles(m.lnOffsets,1)	= m.lcFile								&&Source File of transformation; Bin
		    laFiles(m.lnOffsets,2)	= m.lcMode								&&not a project file
		    laFiles(m.lnOffsets,3)	= m.lcFile								&&VFP Bin File
		    laFiles(m.lnOffsets,4)	= 0										&&No Hook :)
		   ENDIF &&!EMPTY(m.lcFile)
		  ENDIF &&laFiles(m.lnFile,4)=1
		
		  IF m.llPJXUsed THEN
		   loProject.CLOSE
		   loProject = .NULL.
		   llPJXUsed = .F.
		  ENDIF &&m.llPJXUsed
		
		 ENDIF &&FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX'
		ENDFOR &&m.lnFile
		
		*!*	/Change by: SF 15.6.2015
		
		* only bin to text for now and switch not all set
		IF PCOUNT()<5 THEN
		 tlIncludeAll = NIL
		ENDIF &&PCOUNT()<5
		
		llMaxiLoop = !ISNULL(m.lcStorage) AND NVL(!m.tlIncludeAll,TYPE('_SCREEN.gcB2T_Opt')="C" AND _SCREEN.gcB2T_Opt=="1")
		llFound	   = .T.
		
		lcPath = JUSTPATH(_SCREEN.gcB2T_Path)
		
		m.loConverter.LoadProgressbarForm()
		ACTIVATE SCREEN
		
		IF m.lnFilesFound>0 THEN
		* we have something to parse
		* number of files to parse: m.lnOffsets ( this is m.lnFilesFound + Hooks) + m.lnTableFound
		 DIMENSION;
		  laToConvert(m.lnOffsets+m.lnTableFound,3),;
		  laFiles(m.lnOffsets+m.lnTableFound,4)
		
		* files in parameters section
		* must be shown, because they are processed or pre-processed
		 FOR lnConvert = 1 TO m.lnFilesFound
		  laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		* Hooks
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = m.lnFilesFound+1 TO m.lnOffsets
		  laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = !m.llMaxiLoop
		 ENDFOR &&lnConvert
		
		* Table of Databases (laDBC_Tables) figured out above
		* - add to laFiles for later processing
		* - add to laToConvert for processing here
		
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = 1 TO m.lnTableFound
		  laFiles(m.lnOffsets+m.lnConvert,1) = m.laDBC_Tables(m.lnConvert,1)
		  laFiles(m.lnOffsets+m.lnConvert,2) = m.laDBC_Tables(m.lnConvert,2)
		  laFiles(m.lnOffsets+m.lnConvert,3) = m.laDBC_Tables(m.lnConvert,3)
		  laFiles(m.lnOffsets+m.lnConvert,4) = m.laDBC_Tables(m.lnConvert,4)
		
		  laToConvert(m.lnOffsets+m.lnConvert,1) = m.laDBC_Tables(m.lnConvert,1)
		  laToConvert(m.lnOffsets+m.lnConvert,2) = m.laDBC_Tables(m.lnConvert,2)
		  laToConvert(m.lnOffsets+m.lnConvert,3) = !m.llMaxiLoop
		 ENDFOR &&lnConvert
		
		 IF m.llMaxiLoop THEN
		  ?'Pre - processing:'
		 ELSE  &&m.llMaxiLoop
		  ?'Processing:'
		 ENDIF &&m.llMaxiLoop
		 llFound = THIS.Convert(@laToConvert,!m.llMaxiLoop,m.loConverter,0,m.toFB2T_Setting)
		ELSE  &&m.lnFilesFound>0
		 llFound = False
		ENDIF &&m.lnFilesFound>0
		
		*ReRun only file(s) changed
		*Ignore Storage if tlIncludeAll
		IF m.llFound THEN
		 IF NVL(!m.tlIncludeAll,True) THEN
		  LOCAL ARRAY;
		   laFiles2(1,2)
		
		  laFiles2 = ''
		  IF m.loConverter.Get_Processed(@laFiles2)#0 THEN
		*Call FilesToProcess in every case, if run after Text2Bin it will set Storage to
		*actual values
		
		*Note! This will change the array!
		*just process all if
		* !maxiloop and !isnull(storage) -> just process files
		* maxiloop (only if  !ISNULL(storage!!)) and processfiles -> run partial
		*maxiloop and isnull(storage)
		   IF !m.llMaxiLoop AND !ISNULL(m.lcStorage) THEN
		*Complete convert is done, just store result
		    THIS.FilesToProcess(@laFiles2,m.lcPath,.F.,m.tlCheckAll,m.lcStorage,m.loConverter)
		*but if we create binaries we may have still undone stuff like new hooks or DBFs of DBCs
		
		   ELSE  &&!m.llMaxiLoop AND !ISNULL(m.lcStorage)
		    llProcess = THIS.FilesToProcess(@laFiles2,m.lcPath,.F.,m.tlCheckAll,m.lcStorage,m.loConverter)
		    DO CASE
		     CASE ISNULL(m.llProcess)
		*need to process all files -> just let FoxBin2PRG do, faster.
		      DIMENSION;
		       m.laToConvert(ALEN(m.laFiles,1),3)
		
		* must be show, because they are processed
		      FOR lnConvert = 1 TO ALEN(m.laFiles,1)
		       laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		       laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		     CASE m.llProcess
		*If not processed in first loop, process now, file by file.
		      loConverter.l_ProcessFiles			= .T.
		      loConverter.l_AutoClearProcessedFiles	= .T.
		
		      lnFiles  = ALEN(m.laFiles2,1)
		*just set "not a project"
		      FOR lnFile = 1 TO m.lnFiles
		       laFiles2(m.lnFile,2) = m.lcMode
		      ENDFOR &&lnFile
		
		      DIMENSION;
		       m.laToConvert(ALEN(m.laFiles2,1),3)
		
		      FOR lnConvert = 1 TO ALEN(m.laFiles2,1)
		       laToConvert(m.lnConvert,1) = m.laFiles2(m.lnConvert,1)					&& File
		       laToConvert(m.lnConvert,2) = m.laFiles2(m.lnConvert,2)					&& Mode
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnOffsets,m.toFB2T_Setting)
		    ENDCASE
		
		   ENDIF &&!m.llMaxiLoop AND !ISNULL(m.lcStorage)
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:40:00}">Changed by: SF<br />
		*!*	Code to delte / backup text files no more needed.
		*!*	</change>
		*!*	</pdm>
		
		   IF _SCREEN.gcB2T_Delete=="1" THEN
		*Delete obsolete classes from classlibs
		    SELECT (m.lcStorage)
		*sfx todo SQL
		    SCAN FOR iDirty=-1
		
		     loSett		 = THIS.oGet_Setting(JUSTPATH(cFile),m.loConverter)
		     lcSourceExt = UPPER(JUSTEXT(cFile))
		
		     DO CASE
		      CASE UPPER(m.lcSourceExt)=="VCX"
		       lcSourceExt = m.loSett.c_VC2
		      CASE UPPER(m.lcSourceExt)=="FRX"
		       lcSourceExt = m.loSett.c_FR2
		      CASE UPPER(m.lcSourceExt)=="MNX"
		       lcSourceExt = m.loSett.c_MN2
		      CASE UPPER(m.lcSourceExt)=="DBF"
		       lcSourceExt = m.loSett.c_DB2
		      CASE UPPER(m.lcSourceExt)=="DBC"
		       lcSourceExt = m.loSett.c_DC2
		      CASE UPPER(m.lcSourceExt)=="PJX"
		       lcSourceExt = m.loSett.c_PJ2
		      CASE UPPER(m.lcSourceExt)=="LBX"
		       lcSourceExt = m.loSett.c_LB2
		      CASE UPPER(m.lcSourceExt)=="SCX"
		*Fehler: c_CC2 statt c_SC2
		       lcSourceExt = m.loSett.c_SC2
		*Additional extensions
		      CASE UPPER(m.lcSourceExt)=="FKY"
		       lcSourceExt = m.loSett.c_FK2
		      CASE UPPER(m.lcSourceExt)=="MEM"
		       lcSourceExt = m.loSett.c_ME2
		      OTHERWISE
		       LOOP
		     ENDCASE
		
		     lcFile = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		      EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		     DO CASE
		      CASE !FILE(m.lcFile)
		*nothing found, nothing to do
		      CASE m.loSett.n_ExtraBackupLevels>0
		*Backup (only one level deep)
		       lcSourceExt = m.lcSourceExt+'.Del.Bak'
		       lcTarget = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		        EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		       IF FILE(m.lcTarget) THEN
		        DELETE FILE &lcTarget
		       ENDIF &&FILE(m.lcTarget)
		       RENAME &lcFile TO &lcTarget
		
		      OTHERWISE
		*Delete
		       DELETE FILE &lcFile
		     ENDCASE
		*sfx todo SQL
		     REPLACE;
		      iDirty WITH -2
		    ENDSCAN &&iDirty=-1
		   ENDIF &&_SCREEN.gcB2T_Delete=="1"
		*!*	/Changed by: SF 4.6.2015
		
		  ENDIF &&m.loConverter.Get_Processed(@laFiles2)#0
		 ELSE  &&NVL(!m.tlIncludeAll,True)
		
		 ENDIF &&NVL(!m.tlIncludeAll,True)
		ENDIF &&m.llFound
		
		m.loConverter.UnloadProgressbarForm()
		loConverter =  NIL
		
		THIS.Storage_Close(m.lcStorage,m.llFound)
		
		ACTIVATE SCREEN
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&!m.llFound
		 ?""
		ENDIF &&!m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE process_bin2txt_dir		&& Process all directories of a given array to text. Storage not used.
		LPARAMETERS;
		 taFiles,;
		 tlText2Bin
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="taFiles" type="Array" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		
		LOCAL;
		 lcStorage   AS STRING,;
		 llFound     AS BOOLEAN,;
		 lnFile      AS NUMBER,;
		 lnOffsets   AS NUMBER,;
		 loConverter AS OBJECT,;
		 lvTime      AS VARIANT
		
		EXTERNAL ARRAY;
		 taFiles
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 lnFiles
		
		STORE ALEN(m.taFiles,2) TO;
		 lnCols
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,4)
		
		lnOffsets = 0
		
		FOR lnFile = 1 TO m.lnFiles
		 DO CASE
		  CASE m.taFiles(m.lnFile,1)='.'
		  CASE m.taFiles(m.lnFile,1)='..'
		  CASE !DIRECTORY(m.taFiles(m.lnFile,1))
		  OTHERWISE
		
		   lnOffsets              = m.lnOffsets+1
		   laFiles(m.lnOffsets,1) = m.taFiles(m.lnFile,1)
		   laFiles(m.lnOffsets,2) = "BIN2PRG"
		   laFiles(m.lnOffsets,3) = .T.
		
		 ENDCASE
		ENDFOR &&lnfile
		
		IF m.lnOffsets>0 THEN
		 LOCAL ARRAY;
		  laFiles(m.lnOffsets,3)
		
		 m.loConverter.LoadProgressbarForm()
		 ACTIVATE SCREEN
		
		 ?'Processing:'
		 llFound = THIS.Convert(@laFiles,.T.,m.loConverter,0)
		
		 m.loConverter.UnloadProgressbarForm()
		ENDIF &&m.lnOffsets>0
		
		loConverter =  NIL
		
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&m.llFound
		 ?""
		ENDIF &&m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE process_txt2bin		&& Process all files of a given array to binary files.
		LPARAMETERS;
		 taFiles,;
		 tcMode,;
		 tlCheckAll,;
		 tlIncludeAll,;
		 toFB2T_Setting
		
		*!*	<pdm>
		*!*	<descr>Process all files of a given Array.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*!*	<p>List of files to process.</p>
		*!*	<p>Allways binaries, even if as target not existing yet!.</p>
		*!*	<p>The method determines correct extensions for text files itself.</p>
		*!*	<p>The array can be one or two dimensional</p>
		*!*	<dl>
		*!*	 <dt>Column one</dt><dd>Binary file with path.</dd>
		*!*	 <dt>Column two</dt>
		*!*	  <dd>
		*!*	   Optional. Defines a ProjectHook.<br />
		*!*	   <expr>.NULL.</expr> if not determined, Empty, if no ProjectHook is to be processed.<br />
		*!*	   Only valid for PJX files in column one.
		*!*	  </dd>
		*!*	 <dt>Column three</dt>
		*!*	 <dd>
		*!*	  Empty, not used
		*!*	 </dd>
		*!*	</dl>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*!*	<p>Checks if all files listed in <pdmpara num="1" /> are used.</p>
		*!*	<p>If a file is not found, text file corresponding will be deleted.</p>
		*!*	<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="tlIncludeAll" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Convert all files.</short>
		*!*	<detail>
		*!*	<p>Controls if all files are transformed.</p>
		*!*	<p>If True, the file will not be synched with the storage table.</p>
		*!*	<p>If parameter is not passed, this default to the setting stored.</p>
		*!*	</detail>
		*!*	</params>
		*!*	<params name="toFB2T_Setting" type="Object" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Settinngs object</short>
		*!*	<detail>A settings object as returned by FoxBin2PRgs Get_DirSettings. May be used to manipulate special settings.<br />
		*!*	Will be passed to <see pem="Convert" /></detail>
		*!*	</params>
		
		*!*	<retval type="Boolean">Returns succcess of operation.</retval>
		*!*	<remarks>
		*!*	<b>This is the main method. What makes it different from a plain call to FoxBin2Prg is:</b>
		*!*	<ul>
		*!*	 <li>Accepts a mixed array of files. (including whole PJX) </li>
		*!*	 <li>Can limit the Bin2Text operation to dirty files only.</li>
		*!*	 <li>Can delete obsolete class files in ClassPerFile operations.</li>
		*!*	 <li>Can delete obsolete files for removed binaries if <pdmpara num="3" />.</li>
		*!*	</ul>
		*!*	<p>If text to binary, it just passes the files to FoxBin2Prg</p>
		*!*	<p>Creating text files, depending on a setting, it first let check FoxBin2Prg what to do.
		*!*	 IOW what files are included in the process.</p>
		*!*	<p>Then it calls for <see pem="FilesToProcess" /> to see if files are changed.
		*!*	 Only files marked as dirty will be processed.</p>
		*!*	<p>A postprocess will delete / remove obsolete text files.</p>
		*!*	</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="3" />
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,13:00:00}">Changed by: SF<br />
		*!*	Modified to deal with single classes of libraries.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,14:00:00}">Changed by: SF<br />
		*!*	<pdmpara num="1" /> may now hold text files for Text To Bin operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-13,16:00:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" /> to force single file operation.
		*!*	</change>
		*!*	</pdm>
		*!*	<pdm>
		*!*	<change date="{^2017-03-28,12:00:00}">Changed by: SF<br />
		*!*	Modified to deal ::(import|export)
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile        AS CHARACTER,;
		 lcMode        AS CHARACTER,;
		 lcPath        AS CHARACTER,;
		 lcSourceExt   AS CHARACTER,;
		 lcStorage     AS CHARACTER,;
		 lcTarget      AS CHARACTER,;
		 lcClass       AS CHARACTER,;
		 lnFile        AS NUMBER,;
		 lnFilesFound  AS NUMBER,;
		 lnTable       AS NUMBER,;
		 lnOffset      AS NUMBER,;
		 lnOffsets     AS NUMBER,;
		 lnConvert     AS NUMBER,;
		 lnTableFound  AS NUMBER,;
		 llFound       AS BOOLEAN,;
		 llSingleClass AS BOOLEAN,;
		 llProcess     AS BOOLEAN,;
		 llExpandDBC   AS BOOLEAN,;
		 llPJXUsed     AS BOOLEAN,;
		 lvTime        AS VARIANT,;
		 loSetting     AS EMPTY,;
		 loSett        AS OBJECT,;
		 loExtraFiles  AS OBJECT,;
		 loConverter   AS "c_foxbin2prg" OF "E:\x\Helper\ThirdParty\VFPX\FoxBin2PRG\FOXBIN2PRG.PRG"
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 m.lnFiles,;
		 m.lnOffsets
		
		lcMode = "PRG2BIN"
		
		loExtraFiles = NEWOBJECT('collection')
		THIS.Storage_Get("S",m.loExtraFiles,m.lcStorage)
		
		* Check Include DBF of DBC [1 On; else OFF]
		IF !EMPTY(m.loExtraFiles.GETKEY("gcB2T_DBC")) THEN
		 loSetting = m.loExtraFiles.ITEM("gcB2T_DBC")
		 llExpandDBC = m.loSetting.gcFile=="1"
		ENDIF &&!EMPTY(loExtraFiles.GetKey("gcB2T_DBC"))
		* /Check Include DBF of DBC [1 On; else OFF]
		
		*!*	Changed  by: SF 28.2.2021
		*!*	<pdm>
		*!*	<change date="{^2021-02-28,21:02:00}">Changed  by: SF<br />
		*!*	Add List of files stored with settings.
		*!*	</change>
		*!*	</pdm>
		
		IF ATC('-IncludeList',m.tcMode)>0 THEN
		 tcMode        = STRTRAN(m.tcMode,'-IncludeList','',1,-1,1)
		
		 m.loExtraFiles.REMOVE(-1)
		 THIS.Storage_Get("A",m.loExtraFiles,m.lcStorage)
		
		 FOR EACH loSetting IN m.loExtraFiles FOXOBJECT
		  IF EMPTY(ASCAN(m.taFiles,m.loSetting.gcFile,1,-1,2,15)) THEN
		*additional file not found. Add
		   lnFiles   = m.lnFiles+1
		   lnOffsets = m.lnOffsets+1 
		   DIMENSION;
		    m.taFiles(m.lnFiles,ALEN(m.taFiles,2))
		
		   taFiles(m.lnFiles,1)	= m.loSetting.gcFile
		   taFiles(m.lnFiles,2)	= m.lcMode
		  ENDIF &&EMPTY(ASCAN(m.taFiles,m.lcFile,1,-1,2,15))
		
		 ENDFOR &&loSetting
		
		ENDIF &&ATC('-IncludeList',m.tcMode)>0
		
		*!*	/Changed  by: SF 28.2.2021
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,4),;
		 laToConvert(1,4),;
		 laDBC_Tables(1,4),;
		 laDBCs(1,2)
		
		laDBCs = .NULL.
		
		lnFilesFound = 0
		lnTableFound = 0
		
		
		laFiles     = NIL
		
		*process sourcefiles
		lnFile = 0
		DO WHILE m.lnFile<m.lnFiles
		 lnFile		  = m.lnFile+1
		 lnFilesFound = m.lnFilesFound+1
		*wie machen wir das, wenn wir noch keine pjx haben?!!!
		
		*extract class for processing
		 lcClass = ""
		 IF '::'$m.taFiles(m.lnFile,1) THEN
		  taFiles(m.lnFile,1) = STRTRAN(m.taFiles(m.lnFile,1),'::','.',1,1)
		  lcClass			  = "::"+JUSTEXT(m.taFiles(m.lnFile,1))
		  taFiles(m.lnFile,1) = FORCEEXT( m.taFiles(m.lnFile,1),'')
		  llSingleClass		  = True
		 ENDIF &&'::'$taFiles(m.lnFile,1)
		
		 loSett		 = THIS.oGet_Setting(JUSTPATH(m.taFiles(m.lnFile,1)),m.loConverter)
		 lcSourceExt = UPPER(JUSTEXT(m.taFiles(m.lnFile,1)))
		
		*if binary file is send, gather text file extension
		 DO CASE
		  CASE m.llSingleClass
		   lcSourceExt = "VCX"
		  CASE UPPER(m.lcSourceExt)=="VCX"
		   lcSourceExt = m.loSett.c_VC2
		  CASE UPPER(m.lcSourceExt)=="FRX"
		   lcSourceExt = m.loSett.c_FR2
		  CASE UPPER(m.lcSourceExt)=="MNX"
		   lcSourceExt = m.loSett.c_MN2
		  CASE UPPER(m.lcSourceExt)=="DBF"
		   lcSourceExt = m.loSett.c_DB2
		  CASE UPPER(m.lcSourceExt)=="DBC"
		   lcSourceExt = m.loSett.c_DC2
		  CASE UPPER(m.lcSourceExt)=="PJX"
		   lcSourceExt = m.loSett.c_PJ2
		  CASE UPPER(m.lcSourceExt)=="LBX"
		   lcSourceExt = m.loSett.c_LB2
		  CASE UPPER(m.lcSourceExt)=="SCX"
		   lcSourceExt = m.loSett.c_SC2
		*Additional extensions
		  CASE UPPER(m.lcSourceExt)=="FKY"
		   lcSourceExt = m.loSett.c_FK2
		  CASE UPPER(m.lcSourceExt)=="MEM"
		   lcSourceExt = m.loSett.c_ME2
		
		*check if just a text file name is send,
		*for the logic of the programm, we need the binary, so we swap
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_VC2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"VCX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_FR2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"FRX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_MN2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"MNX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_DB2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"DBF")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_DC2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"DBC")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_PJ2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"PJX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_LB2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"LBX")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_SC2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"SCX")
		*Additional extensions
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_FK2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"FKY")
		  CASE UPPER(m.lcSourceExt)==m.loSett.c_ME2
		   taFiles(m.lnFile,1) = FORCEEXT(m.taFiles(m.lnFile,1),"MEM")
		  OTHERWISE
		*Error, no known extension
		   lcSourceExt = ""
		 ENDCASE
		
		 IF EMPTY(m.lcSourceExt) THEN
		*undefined extension, just ignore
		  ADEL(m.laFiles,m.lnFilesFound)
		  lnFilesFound = m.lnFilesFound-1
		  lnOffsets	   = m.lnOffsets-1
		  IF m.lnFilesFound=0 THEN
		   EXIT
		
		  ELSE  &&m.lnFilesFound=0
		   DIMENSION;
		    m.laFiles(m.lnOffsets,4)
		   LOOP
		  ENDIF &&m.lnFilesFound=0
		
		 ELSE  &&EMPTY(m.lcSourceExt)
		  laFiles(m.lnFilesFound,1) = FORCEEXT(m.taFiles(m.lnFile,1),m.lcSourceExt)+;
		   m.lcClass															&&Source File of transformation; Text or Text
		 ENDIF &&EMPTY(m.lcSourceExt)
		
		 laFiles(m.lnFilesFound,2) = m.tcMode 									&&a project file bin or text
		 laFiles(m.lnFilesFound,3) = m.taFiles(m.lnFile,1)						&&VFP Bin File
		 DO CASE
		  CASE !UPPER(JUSTEXT(m.taFiles(m.lnFile,1)))='PJX'
		*nothing to do
		   laFiles(m.lnFilesFound,2) = m.lcMode									&&not a project file
		   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		*odd order?, next three pairs:
		  CASE ALEN(m.taFiles,2)<2
		*nothing defined yet, parse later
		   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but maybe after conversion
		*!*	  CASE ALEN(m.taFiles,2)<2 AND !m.tlText2Bin
		*!*	*nothing defined, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		  CASE ISNULL(m.taFiles(m.lnFile,2))
		*nothing defined yet, parse again after processing (if pjx changed)
		   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE ISNULL(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*nothing defined yet, parse later
		*!*	   laFiles(m.lnFilesFound,4) = 1										&&No Hook, but maybe
		
		  CASE EMPTY(m.taFiles(m.lnFile,2))
		*nothing hook defined yet, but may change again after processing (if pjx changed)
		   laFiles(m.lnFilesFound,4) = 2										&&No Hook, but mybe after conversion
		*!*	  CASE EMPTY(m.taFiles(m.lnFile,2)) AND !m.tlText2Bin
		*!*	*no Hook, do nothing
		*!*	   laFiles(m.lnFilesFound,4) = 0										&&No Hook
		
		  OTHERWISE
		   laFiles(m.lnFilesFound,4) = 2											&&we have a hook, but check after conversion again
		
		 ENDCASE
		ENDDO &&m.lnFile<m.lnFiles
		
		* only bin to text for now and switch not all set
		IF PCOUNT()<5 THEN
		 tlIncludeAll = NIL
		ENDIF &&PCOUNT()<5
		
		llFound	   = .T.
		
		lcPath = JUSTPATH(_SCREEN.gcB2T_Path)
		
		m.loConverter.LoadProgressbarForm()
		ACTIVATE SCREEN
		
		IF m.lnFilesFound>0 THEN
		* we have something to parse
		* number of files to parse: m.lnOffsets ( this is m.lnFilesFound + Hooks) + m.lnTableFound
		 DIMENSION;
		  laToConvert(m.lnOffsets+m.lnTableFound,3),;
		  laFiles(m.lnOffsets+m.lnTableFound,4)
		
		* files in parameters section
		* must be shown, because they are processed or pre-processed
		 FOR lnConvert = 1 TO m.lnFilesFound
		  laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		* Hooks
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = m.lnFilesFound+1 TO m.lnOffsets
		  laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		  laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		  laToConvert(m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		
		* Table of Databases (laDBC_Tables) figured out above
		* - add to laFiles for later processing
		* - add to laToConvert for processing here
		
		* must be shown as only if we not pre-process
		* iow parse all (projects via FoxBin2Prg auto expanding PJX function, all other files via this array)
		 FOR lnConvert = 1 TO m.lnTableFound
		  laFiles(m.lnOffsets+m.lnConvert,1) = m.laDBC_Tables(m.lnConvert,1)
		  laFiles(m.lnOffsets+m.lnConvert,2) = m.laDBC_Tables(m.lnConvert,2)
		  laFiles(m.lnOffsets+m.lnConvert,3) = m.laDBC_Tables(m.lnConvert,4)
		
		  laToConvert(m.lnOffsets+m.lnConvert,1) = m.laDBC_Tables(m.lnConvert,1)
		  laToConvert(m.lnOffsets+m.lnConvert,2) = m.laDBC_Tables(m.lnConvert,2)
		  laToConvert(m.lnOffsets+m.lnConvert,3) = .T.
		 ENDFOR &&lnConvert
		
		  ?'Processing:'
		 llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,0,m.toFB2T_Setting)
		ELSE  &&m.lnFilesFound>0
		 llFound = False
		ENDIF &&m.lnFilesFound>0
		
		*ReRun only file(s) changed
		*Ignore Storage if tlIncludeAll
		IF m.llFound THEN
		 IF NVL(!m.tlIncludeAll,True) THEN
		  LOCAL ARRAY;
		   laFiles2(1,2)
		
		  laFiles2 = ''
		  IF m.loConverter.Get_Processed(@laFiles2)#0 THEN
		*Call FilesToProcess in every case, if run after Text2Bin it will set Storage to
		*actual values
		
		*Note! This will change the array!
		*just process all if
		* !maxiloop and !isnull(storage) -> just process files
		* maxiloop (only if  !ISNULL(storage!!)) and processfiles -> run partial
		*maxiloop and isnull(storage)
		   IF !ISNULL(m.lcStorage) THEN
		*Complete convert is done, just store result
		    THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,m.tlCheckAll,m.lcStorage,m.loConverter)
		*but if we create binaries we may have still undone stuff like new hooks or DBFs of DBCs
		
		    DIMENSION;
		     m.laFiles2(1,4)
		
		    lnOffset = 0
		    FOR lnFile = 1 TO m.lnFilesFound
		     lcFile = m.laFiles(m.lnFile,3)
		*search for project hooks
		     IF FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX' THEN
		
		* parse out DBC
		      IF m.llExpandDBC THEN
		       USE (m.lcFile) ALIAS curPJX IN SELECT('curPJX')
		       llPJXUsed = .T.
		
		       SELECT;
		        Cur1.NAME AS cFile;
		        FROM curPJX AS Cur1;
		        INTO CURSOR curW;
		        WHERE TYPE=='d'
		
		       lnTable = 0
		
		       SCAN
		        lcTarget = ADDBS(JUSTPATH(m.lcFile))+ALLTRIM(cFile)
		
		        lnTable = m.lnTable+1
		        DIMENSION;
		         m.laDBCs(m.lnTable,2)
		
		        loSett		 = THIS.oGet_Setting(JUSTPATH(m.lcTarget),m.loConverter)
		        lcSourceExt = m.loSett.c_DC2
		
		        laDBCs(m.lnTable,1) = FORCEEXT(m.lcTarget,m.lcSourceExt)			&&Source File of transformation; Bin
		        laDBCs(m.lnTable,2) = m.lcMode										&&not a project file
		       ENDSCAN &&All
		
		       IF m.lnTable>0 THEN
		        THIS.Get_DBC_Tables(@laDBCs,@laFiles2,@laFiles2,@lnOffset,m.lcMode,.T.,m.loConverter)
		       ENDIF &&lnTable>0
		
		       lnTable = 0
		       DIMENSION;
		        m.laDBCs(1,2)
		
		       laDBCs = .NULL.
		      ENDIF &&m.llExpandDBC
		* /parse out DBC
		
		*Project Hook
		      IF m.laFiles(m.lnFile,4)>1 THEN
		       IF !m.llPJXUsed THEN
		        USE (m.lcFile) ALIAS curPJX IN SELECT('curPJX')
		        llPJXUsed = .T.
		       ENDIF &&!m.llPJXUsed
		
		       SELECT;
		        Cur1.NAME AS cFile;
		        FROM curPJX AS Cur1;
		        INTO CURSOR curW;
		        WHERE TYPE=='W'
		
		       IF RECCOUNT()=0 OR EMPTY(cFile) THEN
		        lcFile    = ''
		       ELSE  &&RECCOUNT()=0
		        lcFile    = ADDBS(JUSTPATH(m.lcFile))+ALLTRIM(cFile)
		       ENDIF &&RECCOUNT()=0
		
		       IF !EMPTY(m.lcFile) THEN
		        lnOffset = m.lnOffset+1
		        DIMENSION;
		         m.laFiles2(m.lnOffset,3)
		
		        loSett		 = THIS.oGet_Setting(JUSTPATH(m.lcFile),m.loConverter)
		        lcSourceExt = m.loSett.c_VC2
		
		        laFiles2(m.lnOffset,1)	= FORCEEXT(m.lcFile,m.lcSourceExt)			&& Source File of transformation; Bin
		        laFiles2(m.lnOffset,2)	= m.lcMode									&& not a project file
		        laFiles2(m.lnOffset,3)	= 0											&& has no hook
		       ENDIF &&!EMPTY(m.lcFile)
		      ENDIF &&m.laFiles(m.lnFile,4)>1
		
		      IF m.llPJXUsed THEN
		       USE IN curPJX
		       USE IN curW
		       llPJXUsed = .F.
		      ENDIF &&m.llPJXUsed
		     ENDIF &&FILE(m.lcFile) AND UPPER(JUSTEXT(m.lcFile))=='PJX'
		
		*/search for project hooks
		    ENDFOR &&lnFile
		
		*!*	Changed by: SF 11.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-11,20:50:00}">Changed by: SF<br />
		*!* <expr>NOPROJECTHOOK</expr> will open the hook, but not use. So it fails with libray not existing
		*!*	</change>
		*!*	</pdm>
		
		*!*	/Changed by: SF 11.6.2015
		
		    IF m.lnOffset>0 THEN
		     ACTIVATE SCREEN
		
		     DIMENSION;
		      m.laToConvert(m.lnOffset,3)
		
		* files in parameters section
		* must be show, because they are processed
		     FOR lnConvert = 1 TO m.lnOffset
		      laToConvert(m.lnConvert,1) = m.laFiles2(m.lnConvert,1)
		      laToConvert(m.lnConvert,2) = m.laFiles2(m.lnConvert,2)
		      laToConvert(m.lnConvert,3) = .T.
		     ENDFOR &&lnConvert
		
		     ?"Post processing Project-Hooks and Databases DBF's:"
		     llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		
		     DIMENSION;
		      m.laFiles2(1,1)
		*just rework hooks and DBF's in storage table
		     IF m.loConverter.Get_Processed(@laFiles2)#0 THEN
		      THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,.F.,m.lcStorage,m.loConverter)
		     ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		    ENDIF &&m.lnOffset>0
		
		   ELSE  &&!ISNULL(m.lcStorage)
		    llProcess = THIS.FilesToProcess(@laFiles2,m.lcPath,.T.,m.tlCheckAll,m.lcStorage,m.loConverter)
		    DO CASE
		     CASE ISNULL(m.llProcess)
		*need to process all files -> just let FoxBin2PRG do, faster.
		      DIMENSION;
		       m.laToConvert(ALEN(m.laFiles,1),3)
		
		* must be show, because they are processed
		      FOR lnConvert = 1 TO ALEN(m.laFiles,1)
		       laToConvert(m.lnConvert,1) = m.laFiles(m.lnConvert,1)
		       laToConvert(m.lnConvert,2) = m.laFiles(m.lnConvert,2)
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		     CASE m.llProcess
		*If not processed in first loop, process now, file by file.
		      loConverter.l_ProcessFiles			= .T.
		      loConverter.l_AutoClearProcessedFiles	= .T.
		
		      lnFiles  = ALEN(m.laFiles2,1)
		*just set "not a project"
		      FOR lnFile = 1 TO m.lnFiles
		       laFiles2(m.lnFile,2) = m.lcMode
		      ENDFOR &&lnFile
		      DIMENSION;
		       m.laToConvert(ALEN(m.laFiles2,1),3)
		
		      FOR lnConvert = 1 TO ALEN(m.laFiles2,1)
		       laToConvert(m.lnConvert,1) = m.laFiles2(m.lnConvert,1)
		       laToConvert(m.lnConvert,2) = m.laFiles2(m.lnConvert,2)
		       laToConvert(m.lnConvert,3) = .T.
		      ENDFOR &&lnConvert
		
		      ?'Processing:'
		      llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnOffsets,m.toFB2T_Setting)
		    ENDCASE
		
		   ENDIF &&!ISNULL(m.lcStorage)
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:40:00}">Changed by: SF<br />
		*!*	Code to delte / backup text files no more needed.
		*!*	</change>
		*!*	</pdm>
		
		   IF _SCREEN.gcB2T_Delete=="1" THEN
		*Delete obsolete classes from classlibs
		    SELECT (m.lcStorage)
		*sfx todo SQL
		    SCAN FOR iDirty=-1
		
		     loSett		 = THIS.oGet_Setting(JUSTPATH(cFile),m.loConverter)
		     lcSourceExt = UPPER(JUSTEXT(cFile))
		
		     DO CASE
		      CASE UPPER(m.lcSourceExt)=="VCX"
		       lcSourceExt = m.loSett.c_VC2
		      CASE UPPER(m.lcSourceExt)=="FRX"
		       lcSourceExt = m.loSett.c_FR2
		      CASE UPPER(m.lcSourceExt)=="MNX"
		       lcSourceExt = m.loSett.c_MN2
		      CASE UPPER(m.lcSourceExt)=="DBF"
		       lcSourceExt = m.loSett.c_DB2
		      CASE UPPER(m.lcSourceExt)=="DBC"
		       lcSourceExt = m.loSett.c_DC2
		      CASE UPPER(m.lcSourceExt)=="PJX"
		       lcSourceExt = m.loSett.c_PJ2
		      CASE UPPER(m.lcSourceExt)=="LBX"
		       lcSourceExt = m.loSett.c_LB2
		      CASE UPPER(m.lcSourceExt)=="SCX"
		*Fehler: c_CC2 statt c_SC2
		       lcSourceExt = m.loSett.c_SC2
		*Additional extensions
		      CASE UPPER(m.lcSourceExt)=="FKY"
		       lcSourceExt = m.loSett.c_FK2
		      CASE UPPER(m.lcSourceExt)=="MEM"
		       lcSourceExt = m.loSett.c_ME2
		      OTHERWISE
		       LOOP
		     ENDCASE
		
		     lcFile = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		      EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		     DO CASE
		      CASE !FILE(m.lcFile)
		*nothing found, nothing to do
		      CASE m.loSett.n_ExtraBackupLevels>0
		*Backup (only one level deep)
		       lcSourceExt = m.lcSourceExt+'.Del.Bak'
		       lcTarget = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		        EVL(FORCEEXT(ALLTRIM(cObjName),m.lcSourceExt),m.lcSourceExt)
		
		       IF FILE(m.lcTarget) THEN
		        DELETE FILE &lcTarget
		       ENDIF &&FILE(m.lcTarget)
		       RENAME &lcFile TO &lcTarget
		
		      OTHERWISE
		*Delete
		       DELETE FILE &lcFile
		     ENDCASE
		*sfx todo SQL
		     REPLACE;
		      iDirty WITH -2
		    ENDSCAN &&iDirty=-1
		   ENDIF &&_SCREEN.gcB2T_Delete=="1"
		*!*	/Changed by: SF 4.6.2015
		
		  ENDIF &&m.loConverter.Get_Processed(@laFiles2)#0
		 ELSE  &&NVL(!m.tlIncludeAll,True)
		
		*!*	Changed by: SF 11.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-11,20:50:00}">Changed by: SF<br />
		*!* <expr>NOPROJECTHOOK</expr> will open the hook, but not use. So it fails with libray not existing
		*!*	</change>
		*!*	</pdm>
		
		  DIMENSION;
		   m.laFiles2(1,4)
		
		  lnOffset = 0
		
		*search for DBF's of DBC's
		  IF m.llExpandDBC THEN
		   THIS.Get_DBC_Tables(@laFiles,@taFiles,@laFiles2,@lnOffset,m.lcMode,.T.,m.loConverter)
		  ENDIF &&m.llExpandDBC
		*/search for DBF's of DBC's
		
		  IF m.lnOffset>0 THEN
		   ACTIVATE SCREEN
		   DIMENSION;
		    m.laToConvert(m.lnOffset,3)
		
		* files in parameters section
		* must be show, because they are processed
		   FOR lnConvert = 1 TO m.lnOffset
		    laToConvert(m.lnConvert,1) = m.laFiles2(m.lnConvert,1)
		    laToConvert(m.lnConvert,2) = m.laFiles2(m.lnConvert,2)
		    laToConvert(m.lnConvert,3) = .T.
		   ENDFOR &&lnConvert
		
		   ?"Post processing Databases DBF's"
		   llFound = THIS.Convert(@laToConvert,.T.,m.loConverter,m.lnFilesFound,m.toFB2T_Setting)
		
		   DIMENSION;
		    m.laFiles2(1,1)
		*just rework hooks and DBF's in storage table
		   IF m.loConverter.Get_Processed(@laFiles2)#0 THEN
		    THIS.FilesToProcess(@laFiles2,m.lcPath,m.tlText2Bin,.F.,m.lcStorage,m.loConverter)
		   ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		  ENDIF &&m.lnOffset>0
		
		*!*	/Changed by: SF 11.6.2015
		
		 ENDIF &&NVL(!m.tlIncludeAll,True)
		ENDIF &&m.llFound
		
		m.loConverter.UnloadProgressbarForm()
		loConverter =  NIL
		
		THIS.Storage_Close(m.lcStorage,m.llFound)
		
		ACTIVATE SCREEN
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&!m.llFound
		 ?""
		ENDIF &&!m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE process_txt2bin_dir		&& Process all directories of a given array to binary. Storage not used.
		LPARAMETERS;
		 taFiles,;
		 tlText2Bin
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="taFiles" type="Array" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		
		LOCAL;
		 lcStorage   AS STRING,;
		 llFound     AS BOOLEAN,;
		 lnFile      AS NUMBER,;
		 lnOffsets   AS NUMBER,;
		 loConverter AS OBJECT,;
		 lvTime      AS VARIANT
		
		EXTERNAL ARRAY;
		 taFiles
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		STORE ALEN(m.taFiles,1) TO;
		 lnFiles
		
		STORE ALEN(m.taFiles,2) TO;
		 lnCols
		
		LOCAL ARRAY;
		 laFiles(m.lnFiles,3)
		
		lnOffsets = 0
		
		FOR lnFile = 1 TO m.lnFiles
		 DO CASE
		  CASE m.taFiles(m.lnFile,1)='.'
		  CASE m.taFiles(m.lnFile,1)='..'
		  CASE !DIRECTORY(m.taFiles(m.lnFile,1))
		  OTHERWISE
		
		   lnOffsets              = m.lnOffsets+1
		   laFiles(m.lnOffsets,1) = m.taFiles(m.lnFile,1)
		   laFiles(m.lnOffsets,2) = "PRG2BIN"
		   laFiles(m.lnOffsets,3) = .T.
		
		 ENDCASE
		ENDFOR &&lnfile
		
		IF m.lnOffsets>0 THEN
		 LOCAL ARRAY;
		  laFiles(m.lnOffsets,3)
		
		 m.loConverter.LoadProgressbarForm()
		 ACTIVATE SCREEN
		
		 ?'Processing:'
		 llFound = THIS.Convert(@laFiles,.T.,m.loConverter,0)
		
		 m.loConverter.UnloadProgressbarForm()
		ENDIF &&m.lnOffsets>0
		
		loConverter =  NIL
		
		IF !m.llFound THEN
		 ?"Conversion is canceled "
		ELSE  &&m.llFound
		 ?""
		ENDIF &&m.llFound
		??'Duration:',SECONDS()-m.lvTime
		
		RETURN m.llFound
		
	ENDPROC

	PROCEDURE storage_check		&& Check for valid  storage settings, alter settings
		LPARAMETERS;
		 tlInterActive,;
		 tcHomePath
		
		*!*	<pdm>
		*!*	<descr>Check program settings.</descr>
		*!*	<params name="tlInterActive" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Interactive settings.</short>
		*!*	<detail>display the parent form to change the settings.</detail>
		*!*	</params>
		*!*	<params name="tcHomePath" type="Character" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Home path of he actual VFP IDE.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">
		*Alias of the storage table. <expr>.NULL.</expr> if error or <pdmpara num="1" />.
		*</retval>
		*!*	<remarks>
		*<p>Opens the storage file and read settings. Test if settings are existing, not if valid.</p>
		*<p>If set <pdmpara num="1" /> the form will be opened to change and store settings.</p>
		*<p>The storage file will kept open if not <pdmpara num="1" />, the alias will be returned if open.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile     AS CHARACTER,;
		 lcStorage  AS CHARACTER,;
		 llWrite    AS BOOLEAN,;
		 llError    AS BOOLEAN,;
		 loSetting  AS EMPTY,;
		 loSettings AS COLLECTION
		
		IF PCOUNT()>1 AND VARTYPE(tcHomePath)='C' THEN
		*Storage_Location works different with parameter set
		 lcFile    = THIS.Storage_Location(m.tcHomePath)
		ELSE  &&PCOUNT()>1 AND VARTYPE(tcHomePath)='C'
		 lcFile    = THIS.Storage_Location()
		ENDIF &&PCOUNT()>1 AND VARTYPE(tcHomePath)='C'
		
		IF ISNULL(m.lcFile) THEN
		 llError = True
		ELSE  &&ISNULL(m.lcFile)
		
		 lcStorage = THIS.Storage_Open(m.lcFile)
		
		 IF ISNULL(m.lcStorage) THEN
		  llError = True
		 ELSE  &&ISNULL(m.lcStorage)
		
		  loSettings = NEWOBJECT('collection')
		  THIS.Storage_Get("S",m.loSettings,m.lcStorage)
		
		*Storage Path
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Path",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',TRIM(m.lcFile))
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Path")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Path",5)
		
		*get FoxBin2Prg.prg
		  llWrite = THIS.Storage_Check_Bin2Prg(@loSettings,@llError) OR m.llWrite
		
		*GUI Path
		  IF !PEMSTATUS(_SCREEN,"gcB2T_GUI",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"gitk.exe")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_GUI")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_GUI",5)
		
		*auto commit [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Commit",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Commit")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Commit",5)
		
		*on git: Include pjx in run [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_GitPjx",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_GitPjx")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_GitPjx",5)
		
		*Include DBF of DBC [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_DBC",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_DBC")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_DBC",5)
		
		*optimize process [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Opt",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Opt")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Opt",5)
		
		*Delete files of classes removed [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Delete",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_Delete")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Delete",5)
		
		*Use bash for git operations [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_UseBash",5) THEN
		   loSetting = CREATEOBJECT('EMPTY')
		   ADDPROPERTY(loSetting,'gcFile',"0")
		   ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_UseBash")
		   loSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_UseBash",5)
		
		  IF !m.llError AND m.tlInterActive THEN
		*Interactive
		   _SCREEN.ADDPROPERTY("glSet",False)
		
		*run interactive form
		   THIS.PARENT.Storage_Get(m.loSettings)
		   THIS.PARENT.SHOW(1)
		   THIS.PARENT.Storage_Put(m.loSettings)
		
		   llWrite = loSettings.ITEM("glSet")
		   loSettings.REMOVE("glSet")
		
		  ENDIF  &&!m.llError AND !ISNULL(m.lcStorage) AND m.tlInterActive
		 ENDIF &&ISNULL(m.lcStorage)
		ENDIF  &&ISNULL(m.lcFile)
		
		IF m.llError THEN
		 lcStorage = NIL
		 THIS.Storage_Close(m.lcStorage,.T.)
		ELSE  &&m.llError
		 IF m.llWrite THEN
		  THIS.Storage_Set("S",m.loSettings,m.lcStorage)
		 ENDIF &&m.llWrite
		 IF m.tlInterActive THEN
		  THIS.Storage_Close(m.lcStorage,.T.)
		  lcStorage = NIL
		 ENDIF &&m.tlInterActive
		ENDIF &&m.llError
		
		RETURN m.lcStorage
		
	ENDPROC

	PROCEDURE storage_check_bin2prg		&& Check location of FoxBin2Prg.
		LPARAMETERS;
		 toSettings AS COLLECTION,;
		 tlError
		
		*!*	<pdm>
		*!*	<descr>Check if FoxBin2PRG is found, locate.</descr>
		*!*	<params name="toSettings" type="COLLECTION" byref="1" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail>Object with settings.</detail>
		*!*	</params>
		*!*	<params name="tlError" type="Boolean" byref="1" dir="" inb="0" outb="0">
		*!*	<short>Error</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 17.9.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile    AS CHARACTER,;
		 lnLoop    AS INTEGER,;
		 llSearch  AS BOOLEAN,;
		 loSetting AS EMPTY
		
		llSearch = False
		IF !PEMSTATUS(_SCREEN,"gcB2T_FB2T",5) THEN
		 llSearch = True
		ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_FB2T",5)
		
		IF !m.llSearch AND !FILE(_SCREEN.gcB2T_FB2T) THEN
		 llSearch = True
		 MESSAGEBOX('FoxBin2PRG not found in'+0h0D0A+;
		  '"'+_SCREEN.gcB2T_FB2T+'"',0,'Bin2Text v'+dcB2T_Verno)
		ENDIF &&!m.llSearch AND !FILE(_SCREEN.gcB2T_FB2T)
		IF m.llSearch THEN
		 lcFile = ''
		
		 IF FILE("FoxBin2PRG.prg") THEN
		  lcFile = FULLPATH("FoxBin2PRG.prg")
		 ELSE  &&FILE("FoxBin2PRG.prg")
		  lnLoop = 1
		  lcFile = SYS(16,m.lnLoop)
		
		  DO WHILE LEN(m.lcFile)>0
		
		   IF UPPER(JUSTEXT(m.lcFile)) = "APP" THEN
		    IF lcFile="PROCEDURE " THEN
		     lcFile = ADDBS(JUSTPATH(STREXTRACT(m.lcFile,' ',' ',2,2)))
		    ELSE  &&m.lcFile="PROCEDURE "
		     lcFile = JUSTPATH(m.lcFile)
		    ENDIF &&m.lcFile="PROCEDURE "
		    EXIT
		   ENDIF &&UPPER(JUSTEXT(m.lcFile)) = "APP"
		
		   IF UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="BIN2PRG";
		     OR UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="INTER_ACTIVE" THEN
		    lcFile = ADDBS(JUSTPATH(STREXTRACT(m.lcFile,' ',' ',2,2)))
		    EXIT
		   ENDIF &&UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="BIN2PRG" OR UPPER(STREXTRACT(m.lcFile,' ',' ',1))=="INTER_ACTIVE"
		   lnLoop = m.lnLoop+1
		   lcFile = SYS(16,m.lnLoop)
		  ENDDO &&LEN(m.lcFile)>0
		
		 ENDIF &&FILE("FoxBin2PRG.prg")
		
		*Try .. EndTry bei IntelliScript
		 LOCAL;
		  loException AS EXCEPTION
		
		 lcFile = FORCEPATH("FoxBin2PRG.prg",m.lcFile)
		 TRY
		*Was zu testen ist
		   lcFile = LOCFILE(m.lcFile,'prg')
		  CATCH TO loException
		   tlError = True
		  FINALLY
		*
		 ENDTRY
		
		 IF !FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG" THEN
		  tlError = True
		  lcFile  = ''
		  MESSAGEBOX('FoxBin2PRG not found',0,'Bin2Text v'+dcB2T_Verno)
		 ENDIF &&!FILE(m.lcFile) OR !UPPER(JUSTFNAME(m.lcFile))="FOXBIN2PRG.PRG"
		
		 IF toSettings.GETKEY("gcB2T_FB2T")>0 THEN
		*File defined but not found
		  toSettings.REMOVE("gcB2T_FB2T")
		 ENDIF &&toSettings.GetKey("gcB2T_FB2T")>0
		
		 loSetting = CREATEOBJECT('EMPTY')
		 ADDPROPERTY(loSetting,'gcFile',TRIM(m.lcFile))
		 ADDPROPERTY(loSetting,'gcUniqueId',"gcB2T_FB2T")
		 toSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		
		ENDIF &&m.llSearch
		*/get FoxBin2Prg.prg
		
	ENDPROC

	PROCEDURE storage_close		&& Close the storage file.
		LPARAMETERS;
		 tcStorage,;
		 tlReset
		
		*!*	<pdm>
		*!*	<descr>Close / reset storage table.</descr>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias to close.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlReset" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Reset dirty flag.</short>
		*!*	<detail>
		*The dirty flag of the Master record will be reset.
		*If not reset next call of <see pem="Storage_Open" /> will delete all records not of type master or setting.
		*</detail>
		*!*	</params>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		
		IF USED(NVL(m.tcStorage,'')) THEN
		 IF m.tlReset THEN
		*reset heart beat
		  UPDATE Cur1 SET;
		   iDirty    = 0,;
		   tLastUse  = DATETIME();
		   FROM (m.tcStorage) AS Cur1;
		   WHERE Cur1.cType=="X"
		 ENDIF &&m.tlReset
		
		 USE IN (m.tcStorage)
		ENDIF &&USED(m.tcStorage)
		
	ENDPROC

	PROCEDURE storage_get		&& Get settings information out of storage
		LPARAMETERS;
		 tcType,;
		 toSettings AS COLLECTION,;
		 tcStorage,;
		 tcWhere
		
		*!*	<pdm>
		*!*	<descr>Get settings from storage file.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to get settings value.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSettings" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object to write.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias of the storage table.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcWhere" type="Character" byref="0" dir="" inb="1" outb="1">
		*!*	<short>Expression for WHERE.</short>
		*!*	<detail>Used to filter records, in special the DBF for additional index per DBF (cType I).</detail>
		*!*	</params>
		*!*	<retval type="Boolean">At least one setting found.</retval>
		*!*	<remarks>
		*<p>Every record in <pdmpara num="3" /> marked with <pdmpara num="1" /> will be read
		*and stored into <pdmpara num="2" />.</p>
		*<p><pdmpara num="2" /> will be cleared before read.</p>
		*<p>For every item in <pdmpara num="2" /> a property of <expr>_SCREEN</expr> will be created.
		*Form: <expr>_SCREEN.ADDPROPERTY(TRIM(cUniqueID),TRIM(cFile))</expr></p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 llOk      AS BOOLEAN,;
		 loSetting AS EMPTY
		
		IF EMPTY(m.tcWhere) THEN
		 tcWhere = ''
		ELSE  &&EMPTY(m.tcWhere)
		 tcWhere = 'AND '+m.tcWhere
		ENDIF &&EMPTY(m.tcWhere) 
		
		SELECT;
		 Cur1.cFile,;
		 Cur1.cUniqueId;
		 FROM (m.tcStorage) AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cType==m.tcType;
		 &tcWhere
		
		llOk = RECCOUNT()>0
		toSettings.REMOVE(-1)
		SCAN
		 loSetting = CREATEOBJECT('EMPTY')
		 ADDPROPERTY(loSetting,'gcFile',TRIM(cFile))
		 ADDPROPERTY(loSetting,'gcUniqueId',TRIM(cUniqueId))
		
		 toSettings.ADD(m.loSetting,m.loSetting.gcUniqueId)
		 _SCREEN.ADDPROPERTY(m.loSetting.gcUniqueId,m.loSetting.gcFile)
		ENDSCAN
		
		USE IN SELECT('curHelp')
		
		RETURN m.llOk
		
	ENDPROC

	PROCEDURE storage_location		&& Get location for storage file.
		LPARAMETERS;
		 tcHomePath
		
		*!*	<pdm>
		*!*	<descr>Gets location for storage file</descr>
		*!*	<params name="tcHomePath" type="Character" byref="0" dir="" inb="1" outb="1">
		*!*	<short>Home path of he actual VFP IDE.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">
		*<p>Storage file if set by <pdmpara num="1" />, else if found, if not found best guess off directory.</p>
		*<p><expr>.NULL.</expr> if failed.</p>
		*</retval>
		*!*	<comment>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile AS CHARACTER
		
		DO CASE
		 CASE PCOUNT()>0 AND !VARTYPE(tcHomePath)="C"
		  lcFile = NIL
		 CASE PCOUNT()>0 AND !DIRECTORY(m.tcHomePath)
		  lcFile = NIL
		 CASE PCOUNT()>0 AND Is_git(m.tcHomePath)
		  lcFile = FORCEPATH('Bin2Txt.DBF',GetGitBaseDir(m.tcHomePath))
		 CASE PCOUNT()>0
		  lcFile = FORCEPATH('Bin2Txt.DBF',m.tcHomePath)
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		* we say we have a settings file
		  lcFile = _SCREEN.gcB2T_Path
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C';
		   AND FILE(FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path))
		* we say we have a settings file
		  lcFile = FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path)
		
		*o.k.
		*nothing
		*so start guesswork
		
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND DIRECTORY(_SCREEN.gcB2T_Path)
		* we say we have a settings locawe define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path)
		 CASE FILE(FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR())))
		* we say we have a settings file
		  lcFile = FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR()))
		 CASE _VFP.PROJECTS.COUNT>0
		* we say we have a settings loca, we define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',JUSTPATH(_VFP.ACTIVEPROJECT.NAME))
		 OTHERWISE
		*no more guesses, we define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR()))
		ENDCASE
		
		IF !ISNULL(m.lcFile) AND Is_git(JUSTPATH(m.lcFile)) THEN
		*the storage table should not be under git control, in case create / modify .gitignore
		 LOCAL;
		  lcX AS CHARACTER,;
		  lcY AS CHARACTER,;
		  lcZ AS CHARACTER
		
		 lcX = FORCEPATH('.gitignore',JUSTPATH(m.lcFile))
		 lcY = LOWER(FORCEEXT(JUSTFNAME(m.lcFile),"*"))
		 IF FILE(lcX) THEN
		  lcZ = FILETOSTR(lcX)
		  IF !lcY$lcZ THEN
		   IF 0h0D0A$lcZ THEN
		    lcZ = lcZ+0h0D0A+lcY
		   ELSE  &&0h0D0A$lcZ
		    lcZ = lcZ+0h0A+lcY
		   ENDIF &&0h0D0A$lcZ
		   STRTOFILE(lcZ,lcX)
		  ENDIF &&!lcx$lcy
		 ELSE &&FILE(lcIgnore)
		  STRTOFILE(lcY,lcX)
		 ENDIF &&FILE(lcX)
		ENDIF &&!ISNULL(m.lcFile) AND Is_git(JUSTPATH(m.lcFile))
		
		RETURN m.lcFile
		
	ENDPROC

	PROCEDURE storage_open		&& Opens the storage file.
		LPARAMETERS;
		 tcFile
		
		*!*	<pdm>
		*!*	<descr>Opens / create storage table.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>File to open or create.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">Alias of the storage table. <expr>.NULL.</expr> if error.</retval>
		*!*	<remarks>
		*</remarks>
		*<remarks>
		*<p>Table structure of the storage table</p>
		* <table border="1" cellspacing="0">
		*  <thead>
		*   <tr>
		*    <td>Field</td><td>type</td><td>usage</td>
		*   </tr>
		*  </thead>
		*  <tbody>
		*  <tr>
		*  <td>cType</td>
		*  <td>c(1)</td>
		*  <td>
		*   <p>A flag to mark the type of the record. Derived from SCCText / PJX</p>
		*   <p>Not supported types of PJX:
		*   H = Header, L = Library (DLL/FLL), P = Program, Q = Query, T = Text, X = other File, Z = Application</p>
		*   <p>Type W (Project Hook) of PJX is mapped to V/v.</p>
		*   <table border="1" cellspacing="0">
		*    <thead>
		*      <tr><td>Value</td><td>usage</td></tr>
		*    </thead>
		*    <tr><td>B</td><td>Label / </td></tr>
		*    <tr><td>D</td><td>Table / DBF</td></tr>
		*    <tr><td>d</td><td>Database / DBC</td></tr>
		*    <tr><td>K</td><td>Form / SCX</td></tr>
		*    <tr><td>k</td><td>Object of a Form</td></tr>
		*    <tr><td>M</td><td>Menu / MNX</td></tr>
		*    <tr><td>P</td><td>Project / PJX</td></tr>
		*    <tr><td>R</td><td>Report / FRX</td></tr>
		*    <tr><td>V</td><td>Classlibrary / VCX</td></tr>
		*    <tr><td>v</td><td>Class of a Classlibrary</td></tr>
		*    <tr><td></td><td><u>Other:</u></td></tr>
		*    <tr><td>f</td><td>Macro / FKY</td></tr>
		*    <tr><td>m</td><td>Variable file / MEM</td></tr>
		*    <tr><td></td><td><u>Internal:</u></td></tr>
		*    <tr><td>A</td><td>Additional file to process in <i>git commit All</i></td></tr>
		*    <tr><td>S</td><td>Setting</td></tr>
		*    <tr><td><b>X</b></td><td><b>Heart beat check</b></td></tr>
		*    </table>
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>cFile</td>
		*   <td>c(240)</td>
		*   <td>File to process. Allways the binary file, except for settings.</td>
		*  </tr>
		*  <tr>
		*   <td>cObjName</td>
		*   <td>c(240)</td>
		*   <td>For v and k records, the ObjName field of the vcx / scx.<br/>For A records, descriptive name.</td>
		*  </tr>
		*  <tr>
		*   <td>cUniqueID</td>
		*   <td>c(16)</td>
		*   <td>Something to identify the change status, timestamp field CRC etc.<br/>
		*    For settings record: date described.<br/>
		*    For Additional files record: UniqueID to identify record.<br/>
		*    For Heart beat Record: Version number of the table.
		*    Will be compared with internal number for structural changes.
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>iDitry</td>
		*   <td>I</td>
		*   <td>
		*   	<p>Marks an item as dirty from last run.</p>
		*    <table border="1" cellspacing="0">
		*     <tr><td colspan="2">Source; cType IN (B,D,d,f,K,k,M,m,R,V,v)</td></tr>
		*     <tr>
		*       <td>8</td>
		*       <td>
		*        Not deleted on last cleanup (full run with delete obsolete files)
		*        w/o any other action.
		*      </td>
		*     </tr>
		*     <tr><td>4</td><td>New</td></tr>
		*     <tr><td>2</td><td>Changed</td></tr>
		*     <tr><td>1</td><td>Direction to binaray. Additional to other positives</td></tr>
		*     <tr><td>0</td><td>0k</td></tr>
		*     <tr><td>-1</td><td>to delete</td></tr>
		*     <tr><td>-2</td><td>deleted</td></tr>
		*     <tr><td>-3</td><td>dirty by heart beat</td></tr>
		*     <tr><td>-4</td><td>dirty by watch dog (time)</td></tr>
		*     <tr><td colspan="2">Heart beat</td></tr>
		*     <tr><td>0</td><td>ok</td></tr>
		*     <tr><td><b>1</b></td><td><b>Error. Do not compare, process all.</b></td></tr>
		*    </table>
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>tLastUse</td>
		*   <td>T</td>
		*   <td>Internal timestamp, used for garbage collection.</td>
		*  </tr>
		*  </tbody>
		* </table>
		* <p>Checks version number on opening table.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 02.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 llError     AS BOOLEAN,;
		 loException AS EXCEPTION,;
		 lnResult    AS NUMBER
		
		llError = .F.
		
		IF !FILE(m.tcFile) THEN
		 TRY
		   CREATE TABLE (m.tcFile)(;
		    cType     c(1),;
		    cFile     c(240),;
		    cObjName  c(240),;
		    cUniqueId c(16) NOCPTRANS,;
		    iDirty    I,;
		    tLastUse  T)
		   INDEX ON cType		TAG _cType
		*Like SCCTEXT.prg
		*(d = DBC, D = DBF, K = Form, B = Label, M = Menu, R = Report, V = Classlibrary)
		*additional:
		*v = Class
		*k = Form timestamp
		*X = Heart beat check
		*S = Setting
		*A = Additional files
		   INDEX ON cFile		TAG _cFile
		   INDEX ON cObjName	TAG _cObj
		   INDEX ON cUniqueId	TAG _cUni
		   INDEX ON iDirty		TAG _iDirty
		   INDEX ON tLastUse	TAG _tLast
		
		   USE
		  CATCH TO m.loException
		* andere Fehler, Standardhandler rufen
		* ToDo
		   llError = .T.
		  FINALLY
		 ENDTRY
		
		 IF m.llError THEN
		*we can't handle
		*process all
		  USE IN SELECT('Storage')
		  RETURN NIL
		 ENDIF &&m.llError
		ENDIF &&!FILE(m.tcFile)
		
		TRY
		*Was zu testen ist
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage') EXCLUSIVE
		
		  SELECT Storage
		  PACK
		 CATCH TO m.loException
		* andere Fehler, Standardhandler rufen
		* ToDo
		*dann eben kein pack, egal
		  llError = .T.
		 FINALLY
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage')
		
		ENDTRY
		
		IF m.llError THEN
		*we can't handle
		*process all
		 USE IN SELECT('Storage')
		 RETURN NIL
		ENDIF &&m.llError
		
		*check heart beat for existence (and set as error to fix problems)
		SELECT;
		 Cur1.iDirty,;
		 Cur1.cUniqueId;
		 FROM Storage AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cType=="X"
		
		IF RECCOUNT()=0 THEN
		 INSERT INTO (m.tcFile);
		  (cFile,cObjName ,cType,cUniqueId,iDirty);
		  VALUES;
		  ("Check heart beat","internal","X",dcB2T_Verno  , 2)
		
		 SELECT;
		  Cur1.iDirty,;
		  Cur1.cUniqueId;
		  FROM Storage AS Cur1;
		  INTO CURSOR curHelp;
		  WHERE Cur1.cType=="X"
		ENDIF &&RECCOUNT()=0
		
		lnResult = Compare_Verno(cUniqueId,dcB2T_Verno)
		
		DO CASE
		 CASE EMPTY(cUniqueId)
		* we assume we are on the step to 1.x
		  USE IN SELECT('Storage')
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage') EXCLUSIVE
		
		*check for misplaced Key DBF / DBC
		  SELECT Storage
		  LOCATE;
		   FOR (cType=='D';
		   AND ATC('DBC',JUSTEXT(cFile))>0);
		   OR (cType=='d';
		   AND ATC('DBF',JUSTEXT(cFile))>0)
		
		  IF FOUND() THEN
		*Version before 1.0.0
		   REPLACE;
		    ALL;
		    cType WITH ICASE(cType=='D','d',cType=='d','D',cType)
		
		   UPDATE Storage SET;
		    cUniqueId = dcB2T_Verno;
		    WHERE cType=="X"
		
		  ENDIF &&FOUND()
		
		  USE IN SELECT('Storage')
		  USE (m.tcFile) ALIAS Storage IN SELECT('Storage')
		
		 CASE m.lnResult=1
		*table is of new version
		  ?"Bin2Text"
		  ?"Storage table is not fitting to this version. Expected: "+dcB2T_Verno+", new version found: "+cUniqueId
		  ?'Table: '+DBF('Storage')
		  USE IN curHelp
		  USE IN SELECT('Storage')
		  RETURN NIL
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))==SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2))
		*known pair, go ahead (only minor change w/o dbf change)
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2;
		   AND SUBSTR(cUniqueId,1,AT('.',cUniqueId,2))='1.0' AND SUBSTR(dcB2T_Verno,1,AT('.',dcB2T_Verno,2))='1.1'
		* change storage of additional path "inkomensurabel" to relative
		  UPDATE Storage SET;
		   cFile = SYS(2014,cFile,DBF('Storage'));
		   WHERE cType=="A"
		
		  UPDATE Storage SET;
		   cUniqueId = dcB2T_Verno;
		   WHERE cType=="X"
		
		 CASE m.lnResult=2
		*table is of old version
		*update added here ....
		  ?"Bin2Text"
		  ?"Storage table is not fitting to this version. Expected: "+dcB2T_Verno+", old version found: "+cUniqueId
		  ?'Table: '+DBF('Storage')
		  USE IN curHelp
		  USE IN SELECT('Storage')
		  RETURN NIL
		
		 OTHERWISE
		* CASE m.lnResult=0
		*version fit, do nothing
		
		ENDCASE
		
		*garbage collection
		SELECT;
		 Cur1.iDirty;
		 FROM Storage AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.iDirty#0;
		 AND Cur1.cType=="X"
		
		IF RECCOUNT()=0 THEN
		*mark old files for reprocess
		 UPDATE Cur1 SET;
		  iDirty    = -4;
		  FROM Storage AS Cur1;
		  WHERE Cur1.tLastUse<=GOMONTH(DATETIME(),-3);
		  AND !(Cur1.cType=="X";
		  OR Cur1.cType=="S";
		  OR Cur1.cType=="A")
		
		ELSE  &&RECCOUNT()=0
		*heart misses a beat, all dirty
		 UPDATE Cur1 SET;
		  iDirty    = -3;
		  FROM Storage AS Cur1;
		  WHERE Cur1.tLastUse<=GOMONTH(DATETIME(),-3);
		  AND !(Cur1.cType=="X";
		  OR Cur1.cType=="S";
		  OR Cur1.cType=="A")
		
		ENDIF &&RECCOUNT()=0
		
		USE IN curHelp
		
		*Set heart beat
		UPDATE Cur1 SET;
		 iDirty    = 1,;
		 tLastUse  = DATETIME();
		 FROM Storage AS Cur1;
		 WHERE Cur1.cType=="X"
		
		RETURN 'Storage'
		
	ENDPROC

	PROCEDURE storage_set		&& Set settings information to storage.
		LPARAMETERS;
		 tcType,;
		 toSettings AS COLLECTION,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Puts settings into storage file.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to assign settings value.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSettings" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object to read.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias of the storage table.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<remarks>
		*<p>Every item of the collection <pdmpara num="2" /> will create a record in <pdmpara num="3" />
		*with key and value.</p>
		*<p>Note that lenght of key is limited to 14 signs, see <see pem="Storage_Open" />.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcKey     AS CHARACTER,;
		 lcValue   AS CHARACTER,;
		 loSetting AS EMPTY
		
		FOR EACH loSetting IN toSettings FOXOBJECT  
		
		 lcKey    = m.loSetting.gcUniqueId
		 lcValue  = m.loSetting.gcFile
		
		 _SCREEN.ADDPROPERTY(m.lcKey,m.lcValue)
		
		 UPDATE cur1 SET;
		  cFile    = m.lcValue,;
		  iDirty   = 0,;
		  tLastUse = DATETIME();
		  FROM (m.tcStorage) AS cur1;
		  WHERE cur1.cUniqueId==m.lcKey;
		  AND cur1.cType==m.tcType
		
		 IF _TALLY=0 THEN
		  INSERT INTO (m.tcStorage);
		   (cType, cFile, cUniqueId, iDirty, tLastUse);
		   VALUES;
		   (m.tcType, m.lcValue, m.lcKey, 0, DATETIME())
		 ENDIF &&_TALLY=0
		ENDFOR &&loSetting 
		
	ENDPROC

	PROCEDURE sync_file		&& Test change of checksum (crc32) for a given file (pair) against the storage table.
		LPARAMETERS;
		 tcType,;
		 tcFile,;
		 tlText2Bin,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to sync the file.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>File to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="2" /> is changed.</retval>
		*!*	<remarks>
		*<p>The method calculates the checksum for the file and it's. memo file.</p>
		*<p>This will be compared with <pdmpara num="4" /> to determine if the file is changed and need to be reprocessed.</p>
		*</remarks>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile2    AS STRING,;
		 lcCell     AS STRING,;
		 lcTags     AS STRING,;
		 lcDataBase AS STRING,;
		 lnStep     AS NUMBER,;
		 llDirty    AS BOOLEAN,;
		 llRecall   AS BOOLEAN,;
		 llWithCDX  AS BOOLEAN
		
		* we only check the taginfo of the cdx, the data of the index itself will not be stored anyway.
		* no handling of additional CDX or IDX
		* I'm  not shure with the memo, my guess is, it will alter the table too but I'm to lazy to check :)
		lcTags =  ""
		DO CASE
		 CASE m.tcType="V"
		  lcFile2 = FORCEEXT(m.tcFile,'vct')
		 CASE m.tcType="R"
		  lcFile2 = FORCEEXT(m.tcFile,'frt')
		 CASE m.tcType="M"
		  lcFile2 = FORCEEXT(m.tcFile,'mnt')
		 CASE m.tcType="P"
		  lcFile2 = FORCEEXT(m.tcFile,'pjt')
		 CASE m.tcType="K"
		  lcFile2 = FORCEEXT(m.tcFile,'sct')
		 CASE m.tcType="D"
		  lcFile2 = FORCEEXT(m.tcFile,'fpt')
		*figure out tags, we just store the taginfo
		  LOCAL ARRAY;
		   laTags(1,6)
		  laTags = ''
		
		  SELECT 0
		  USE (m.tcFile) ALIAS cur_Tags
		  lcDataBase = CURSORGETPROP("Database")
		
		  ATAGINFO(laTags)
		
		  USE IN SELECT('cur_Tags')
		  IF !EMPTY(m.lcDataBase) AND EMPTY(DBC()) THEN
		   SET DATABASE TO (m.lcDataBase)
		   CLOSE DATABASES 
		  ENDIF &&!EMPTY(m.lcDataBase) AND EMPTY(DBC()) 
		
		  FOR EACH lcCell IN m.laTags
		   lcTags = lcTags+lcCell
		  ENDFOR &&lcTemp
		
		  RELEASE;
		   laTags
		
		 CASE m.tcType="d"
		  lcFile2 = FORCEEXT(m.tcFile,'dct')
		*figure out tags, we just store the taginfo
		  LOCAL ARRAY;
		   laTags(1,6)
		  laTags = ''
		
		  SELECT 0
		  USE (m.tcFile) ALIAS cur_Tags
		  ATAGINFO(laTags)
		  USE IN SELECT('cur_Tags')
		  FOR EACH lcCell IN m.laTags
		   lcTags = lcTags+lcCell
		  ENDFOR &&lcTemp
		
		  RELEASE;
		   laTags
		
		 CASE m.tcType="B"
		  lcFile2 = FORCEEXT(m.tcFile,'lbt')
		 CASE m.tcType="f"
		  lcFile2 = FORCEEXT(m.tcFile,'fky')
		 CASE m.tcType="m"
		  lcFile2 = FORCEEXT(m.tcFile,'mem')
		ENDCASE
		
		*set anything "ok" that was processed by last run
		lnDirty = IIF(m.tlText2Bin,1,0)
		UPDATE Cur1 SET;
		 iDirty   = m.lnDirty,;
		 tLastUse = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		 AND Cur1.cType==m.tcType;
		 AND Cur1.iDirty>=0
		
		*!*	Changed by: SF 5.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,13:09:00}">Changed by: SF<br />
		*!*	do not delete a file mark for delation (because it is not obsolete)
		*!*	</change>
		*!*	</pdm>
		
		*set files marked as "to delete" by "all cleanup" as "not to delete"
		*because file possibly exists (no existing will be parsed out below)
		lnDirty = IIF(m.tlText2Bin,9,8)
		UPDATE Cur1 SET;
		 iDirty    = m.lnDirty,;
		 tLastUse  = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		 AND Cur1.cType==m.tcType;
		 AND Cur1.iDirty=-1
		
		*!*	/Changed by: SF 5.6.2015
		
		*only to process per class, iff UseClassPerFile
		llRecall = INLIST(m.tcType,'V','K') AND _TALLY>0
		
		*create data
		SELECT;
		 Cur1.cUniqueId,;
		 Cur1.iDirty;
		 FROM (m.tcStorage) AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cFile==m.tcFile;
		 AND Cur1.cType==m.tcType
		
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE m.lnStep=1 AND RECCOUNT()=0   &&unknown, create
		   llDirty = True
		
		   lnDirty = IIF(m.tlText2Bin,5,4)
		   INSERT INTO (m.tcStorage);
		    (cType, cFile, cUniqueId, iDirty, tLastUse);
		    VALUES;
		    (m.tcType, m.tcFile, m.lcFile2, m.lnDirty, DATETIME())
		*/  &&m.lnStep=1 AND RECCOUNT()=0  &&unknown, create
		
		  CASE m.lnStep=1    &&just loop
		*/  &&m.lnStep=1   &&just loop
		
		  CASE m.lnStep=2 AND INLIST(iDirty,-3,-4)	  &&file is marked as dirty, process dirty
		   llDirty = True
		
		   lnDirty = IIF(m.tlText2Bin,3,2)
		   UPDATE Cur1 SET;
		    cUniqueId = m.lcFile2,;
		    iDirty    = m.lnDirty,;
		    tLastUse  = DATETIME();
		    FROM (m.tcStorage) AS Cur1;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType==m.tcType
		*/ &&m.lnStep=2 AND INLIST(iDirty,-3,-4)  &&file is marked as dirty, process dirty
		
		  CASE m.lnStep=2    &&just loop
		*/  &&m.lnStep=2   &&just loop
		
		  CASE m.lnStep=3	 	&&get file checksum
		*!*	Changed by: SF 20.5.2015
		*!*	<pdm>
		*!*	<change date="{^2015-05-20,06:44:00}">Changed by SF<br />
		*!*	Checksum changed to CRC32
		*!*	</change>
		*!*	</pdm>
		
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:00:00}">Changed by: SF<br />
		*!*	Ignore the first 4 bytes of a table. (means: bytes 1-3)
		*VFP seems to alter <i>Last update</i> on compile. If the rest of the table is not changed, we can ignore this.
		*!*	</change>
		*!*	</pdm>
		
		   IF FILE(m.lcFile2) THEN
		    lcFile2 = SYS(2007,SUBSTR(FILETOSTR(m.tcFile),5)+FILETOSTR(m.lcFile2)+m.lcTags,0,1)
		   ELSE  &&FILE(m.lcFile2)
		    lcFile2 = SYS(2007,SUBSTR(FILETOSTR(m.tcFile),5)+m.lcTags,0,1)
		   ENDIF &&FILE(m.lcFile2)
		
		*!*	IF FILE(m.lcFile2) THEN
		*!*	 m.lcFile2 = SYS(2007,FILETOSTR(m.tcFile)+FILETOSTR(m.lcFile2),0,1)
		*!*	ELSE  &&FILE(m.lcFile2)
		*!*	 lcFile2 = SYS(2007,FILETOSTR(m.tcFile),0,1)
		*!*	ENDIF &&FILE(m.lcFile2)
		
		*!*	/Changed by: SF 4.6.2015
		*!*	/Changed by SF 20.5.2015
		
		*/	&&m.lnStep=3 	&&get file checksum
		
		  CASE m.lnStep=4 AND !TRIM(cUniqueId)==m.lcFile2   	 	&&changed, process dirty
		   llDirty = True
		
		   lnDirty = IIF(m.tlText2Bin,3,2)
		   UPDATE Cur1 SET;
		    cUniqueId = m.lcFile2,;
		    iDirty    = m.lnDirty,;
		    tLastUse  = DATETIME();
		    FROM (m.tcStorage) AS Cur1;
		    WHERE Cur1.cFile==m.tcFile;
		    AND Cur1.cType==m.tcType
		*/  &&m.lnStep=4 AND !TRIM(cUniqueId)==m.lcFile2  	 	&&changed, process dirty
		
		  OTHERWISE
		*ok
		   llDirty = False
		   EXIT
		 ENDCASE
		
		 IF m.llDirty THEN
		  EXIT
		 ELSE  &&m.llDirty
		  lnStep = m.lnStep+1
		 ENDIF &&m.llDirty
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty OR m.llRecall
		
	ENDPROC

	PROCEDURE sync_objects		&& Compares a help cursor with the storage table. Compares objects of a vcx / scx.
		LPARAMETERS;
		 tcType,;
		 tcFile,;
		 tlText2Bin,;
		 tcSource,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Compares a help cursor with the storage table.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to sync the file.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Filename</short>
		*!*	<detail>File that is handled by <self list"1" /> and decribed in <pdmpara num="4" />.</detail>
		*!*	</params>
		*!*	<params name="tlText2Bin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcSource" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source cursor.</short>
		*!*	<detail>Cursor with relevant information about the <pdmpara num="2" />.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Classes of <pdmpara num="2" /> are changed.</retval>
		*!*	<remarks>
		*<p>To scx / vcx files</p>
		*<p>This will compare the actual timestamps and uniqueeid. If anything is changed the item will be marked.</p>
		*<p>Any mark will set the file is dirty and the function returns <expr>.T.</expr>.</p>
		*<p>The iDirty (see <see pem="Storage_Open"/>) column will be set to(positive odds are a result of <pdmpara num="3" /> is true):</p>
		*<dl>
		*<dt>8/9</dt><dd>File marked by global cleanup is not to delete.</dd>
		*<dt>4/5</dt><dd>new</dd>
		*<dt>2/3</dt><dd>changed</dd>
		*<dt>0/1</dt><dd>no change</dd>
		*<dt>-1</dt><dd>ClassPerFile is to be deleted.</dd>
		*</dl>
		*<p>Type of operation as set by SCCTEXT.prg with additional flag. See <see pem="Storage_Open"/>.</p>
		*<p>
		*<dl>
		* <dt>B</dt><dd>Label (lbx)</dd>
		* <dt>D</dt><dd>Free Table (dbf)</dd>
		* <dt>d</dt><dd>Database (dbc)</dd>
		* <dt>f</dt><dd>Macro file (fky)</dd>
		* <dt>K</dt><dd>Form (scx)</dd>
		* <dt>k</dt><dd>Object of Form</dd>
		* <dt>M</dt><dd>Menu (mnx)</dd>
		* <dt>m</dt><dd>Variable file (mem)</dd>
		* <dt>P</dt><dd>Project (pjx)</dd>
		* <dt>R</dt><dd>Report (frx)</dd>
		* <dt>V</dt><dd>Classlibrary (vcx)</dd>
		* <dt>v</dt><dd>Class of Classlibrary</dd>
		* <dt><b>X</b></dt><dd><b>Heart beat check</b></dd>
		*</dl>
		* This method basically deals with classes of vcx files and objects of scx files.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright>
		*!*	<img src="../../repository/vfpxbanner_small.png" alt="VFPX logo"/><br/>
		*!*	<p>This project is part of <a href="https://vfpx.github.io/"  title="Skip to VFPX" target="_blank">VFPX</a>.</p>
		*!*	<p><i>&copy; 02.03.2021 Lutz Scheffler Software Ingenieurbüro</i></p>
		*!*	</copyright>
		*!*	</pdm>
		
		IF PCOUNT()=0 THEN
		 CREATE CURSOR muh (i1 i)
		 RETURN
		ENDIF &&PCOUNT()=0
		
		LOCAL;
		 lnDirty AS INTEGER,;
		 llDirty AS BOOLEAN
		
		llDirty = .F.
		
		*so now let's see if something is changed
		#IF .F. THEN
		*beautify off
		 TEXT
		#ENDIF &&.F.
		
		*set anything "ok" that was processed by last run
		lnDirty = IIF(m.tlText2Bin,1,0)
		UPDATE Cur1 SET;
		 iDirty   = m.lnDirty,;
		 tLastUse = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		  AND Cur1.cType==m.tcType;
		  AND Cur1.iDirty>=0
		  
		*!*	Changed by: SF 5.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,13:09:00}">Changed by: SF<br />
		*!*	Do not delete a file marked for delation (because it is not automatic obsolete)
		*!*	</change>
		*!*	</pdm>
		
		*set files marked as "to delete" by "all cleanup" as "not to delete"
		*because file exists
		lnDirty = IIF(m.tlText2Bin,9,8)
		UPDATE Cur1 SET;
		 iDirty    = m.lnDirty,;
		 tLastUse  = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 WHERE Cur1.cFile==m.tcFile;
		  AND Cur1.cType==m.tcType;
		  AND Cur1.iDirty=-1
		*!*	/Changed by: SF 5.6.2015
		
		 SELECT;
		  .T. AS lNew,;
		  Cur1.cObjName,;
		  Cur1.cUniqueId;
		  FROM (tcSource) AS Cur1;
		  INTO CURSOR curHelp;
		  WHERE Cur1.cUniqueID-Cur1.cObjName NOT IN (;
		    SELECT;
		     Cur1_1.cUniqueId-Cur1_1.cObjName;
		     FROM (m.tcStorage) AS Cur1_1;
		     WHERE Cur1_1.cFile==m.tcFile;
		      AND Cur1_1.cType==m.tcType;
		   );
		UNION;
		 SELECT;
		  .F. AS lNew,;
		  Cur2.cObjName,;
		  Cur2.cUniqueId;
		  FROM (m.tcStorage) AS Cur2;
		  WHERE Cur2.cFile==m.tcFile;
		   AND Cur2.cType==m.tcType;
		   AND Cur2.cUniqueId-Cur2.cObjName NOT IN(;
		    SELECT;
		     Cur2_1.cUniqueID-Cur2_1.cObjName;
		     FROM (tcSource) AS Cur2_1;
		   )
		
		llDirty = RECCOUNT()>0  &&something is changed some way
		
		*Those will have files that will no longer be valid
		*Records will be deleted in the next run, due to post processing -> delete obsolete vc2 files!
		*Objects with both lNew AND !lNew have replaced UniqueId!
		UPDATE Cur1 SET;
		 iDirty   = -1,;
		 tLastUse = DATETIME();
		 FROM (m.tcStorage) AS Cur1;
		 INNER JOIN curHelp AS Cur2;
		  ON Cur1.cObjName==Cur2.cObjName;
		   AND Cur1.cFile==m.tcFile;
		   AND Cur1.cType==m.tcType;
		   AND !Cur2.lNew;
		  WHERE Cur2.cObjName NOT IN(;
		    SELECT;
		     Cur2_1.cObjName;
		     FROM curHelp AS Cur2_1;
		     WHERE Cur2_1.lNew;
		   )
		
		*Records changed - lNew AND !lNew needs to be checked
		 lnDirty = IIF(m.tlText2Bin,3,2)
		 UPDATE Cur1 SET;
		  cUniqueId =Cur2.cUniqueId,;
		  iDirty    = m.lnDirty,;
		  tLastUse  = DATETIME();
		  FROM (m.tcStorage) AS Cur1;
		  INNER JOIN curHelp AS Cur2;
		   ON Cur1.cObjName==Cur2.cObjName;
		    AND Cur1.cFile==m.tcFile;
		    AND Cur1.cType==m.tcType;
		    AND Cur2.lNew;
		  INNER JOIN curHelp AS Cur3;
		   ON Cur1.cObjName==Cur3.cObjName;
		    AND !Cur3.lNew;
		
		*Records marked as dirty for heart beat failure OR  garbage needs to be checked / reprocessed
		 UPDATE Cur1 SET;
		  iDirty    = m.lnDirty,;
		  tLastUse  = DATETIME();
		  FROM (m.tcStorage) AS Cur1;
		  WHERE Cur1.iDirty IN (-3,-4);
		   AND Cur1.cFile==m.tcFile;
		   AND Cur1.cType==m.tcType
		
		llDirty = m.llDirty OR _TALLY>0
		
		*new files
		 lnDirty = IIF(m.tlText2Bin,5,4)
		 INSERT INTO (m.tcStorage);
		  SELECT;
		   m.tcType AS cType,;
		   CAST(m.tcFile AS c(240)) AS cFile,;
		   Cur2.cObjName,;
		   Cur2.cUniqueId,;
		   CAST(m.lnDirty AS I) AS iDirty,;
		   DATETIME() AS tLastUse;
		   FROM curHelp AS Cur2;
		   WHERE Cur2.lNew;
		    AND Cur2.cObjName NOT IN(;
		     SELECT;
		      Cur3.cObjName;
		      FROM curHelp AS Cur3;
		      WHERE !Cur3.lNew;
		    )
		
		#IF .F. THEN
		*beautify on
		 ENDTEXT
		#ENDIF &&.F.
		
		USE IN SELECT('curHelp')
		
		*For one or the other reason. reprocess
		RETURN m.llDirty
		
	ENDPROC

ENDDEFINE
