*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="bin_2_text.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS cusstorage AS custom 		&& The stuff that does the work.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\stuff.h"
	*<DefinedPropArrayMethod>
		*m: check_scx		&& Checks a given scx file for changes.
		*m: check_vcx		&& Checks a given vcx file for changes.
		*m: convert		&& Convert complete set, not partial.
		*m: filestoprocess		&& Test if files are changed since last run.
		*m: get_converter		&& Create FoxBin2PRG object.
		*m: get_md5
		*m: oget_setting		&& Returns a settings object of a given path with config from FoxBin2PRG.
		*m: process_bin2text		&& Process all files of a given ayrray.
		*m: storage_check		&& Check for valid  storage settings, alter settings
		*m: storage_check_bin2prg		&& Check location of FoxBin2Prg.
		*m: storage_close		&& Close the storage file.
		*m: storage_get		&& Get settings information out of storage
		*m: storage_location		&& Get location for storage file.
		*m: storage_open		&& Opens the storage file.
		*m: storage_set		&& Set settings information to storage.
		*m: sync_file		&& Test change of checksum (crc32) for a given file (pair) against the storage table.
		*m: sync_objects		&& Compares a help cursor with the storage table. Compares objects of a vcx / scx.
	*</DefinedPropArrayMethod>

	Name = "cusstorage"
	
	PROCEDURE check_scx		&& Checks a given scx file for changes.
		LPARAMETERS;
		 tcFile,;
		 tcPath,;
		 tlToBin,;
		 tcStorage,;
		 toSett
		
		*!*	<pdm>
		*!*	<descr>Checks a given scx file for changes.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Full qualified file to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Path of the operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlToBin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSett" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail>Object with folder settings of FoxBin2PRG.</detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="1" /> is changed.</retval>
		*!*	<remarks>
		*<p>This will test checksum first.</p>
		*<p>If checksum is changed check SCX for timestamp change.</p>
		*<p>A object is a record in the scx with <expr>PLATFORM=="WINDOWS" AND LEN(PARENT)=0</expr>.
		* basically dataenvironment and form.</p>
		*<p>FoxBin2PRG separates them, for whatever reason, so I keep track.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 10.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnStep      AS INTEGER,;
		 llDirty     AS BOOLEAN,;
		 llOk        AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llDirty = .F.
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE lnStep=1   &&test for changes on file (checksum)
		*llOk - nothing changed on file
		   llOk = !THIS.Sync_File('K',tcFile,tlToBin,tcStorage)
		*/  &&lnStep=1  &&test for changes on file (checksum)
		
		  CASE lnStep=2 AND toSett.n_UseClassPerFile=0    &&Do not split classlib into classlib.class.vc2
		*Sync_File was dirty,
		*this could be one out of two problems
		*-file is not to be deleted (8,9) - we are not dirty
		   SELECT;
		    Cur1.iDirty;
		    FROM (tcStorage) AS Cur1;
		    WHERE Cur1.cFile==tcFile;
		    AND Cur1.cType=='K';
		    AND Cur1.iDirty IN (8,9)
		*-if not found we are dirty
		   llDirty = _TALLY=0
		* and done
		   llOk = .T.
		*/  &&lnStep=2 AND toSett.n_UseClassPerFile=0   &&Do not split classlib into classlib.class.vc2
		
		  CASE lnStep=2
		*just loop
		
		  CASE lnStep=3  &&Test access
		   TRY
		*Was zu testen ist
		     USE (tcFile) ALIAS scx IN SELECT('scx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&lnStep=3 &&Test  access
		
		  CASE lnStep=4    &&Test if VCX is usable
		*okä, now test this thing
		   SELECT;
		    Cur1.UniqueID,;
		    COUNT(*) AS nCount;
		    FROM scx AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0;
		    GROUP BY 1 HAVING nCount>1
		
		*/  &&lnStep=4   &&Test if SCX is usable
		
		  CASE lnStep=5 AND RECCOUNT()>0
		*UniqueID not so unique
		*rebuild, delete from Storage
		   TRY
		*Was zu testen ist
		     USE (tcFile) ALIAS vcx IN SELECT('vcx') EXCLUSIVE
		
		     SELECT vcx
		     REPLACE;
		      UniqueID WITH SYS(2015);
		      FOR PLATFORM='WINDOWS'
		
		     USE (tcFile) ALIAS scx IN SELECT('scx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&lnStep=5 &&Test if SCX is usable
		
		  CASE lnStep=5
		*just loop
		
		  CASE lnStep=6  &&test for changes on classes
		*(only if checksum is changed)
		
		*so now let's see if something is changed
		*get vcx data
		   SELECT;
		    CAST(Cur1.ObjName AS c(240))         AS cObjName,;
		    Cur1.UniqueID+BINTOC(Cur1.TIMESTAMP) AS cUniqueId;
		    FROM scx AS Cur1;
		    INTO CURSOR curSCX;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0
		
		   INDEX ON cObjName  TAG _cObj
		   INDEX ON cUniqueId TAG _cUni
		
		   llDirty = THIS.Sync_Objects('k',tcFile,tlToBin,'curSCX',tcStorage)
		
		*/   &&lnStep=2 &&test for changes on classes
		
		  OTHERWISE && end loop
		   EXIT
		 ENDCASE
		
		 IF llDirty OR llOk THEN
		  EXIT
		 ELSE  &&llDirty
		  lnStep = lnStep+1
		 ENDIF &&llDirty
		
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		USE IN SELECT('scx')
		USE IN SELECT('curSCX')
		
		*For one or the other reason. reprocess
		RETURN llDirty
		
		
	ENDPROC

	PROCEDURE check_vcx		&& Checks a given vcx file for changes.
		LPARAMETERS;
		 tcFile,;
		 tcPath,;
		 tlToBin,;
		 tcStorage,;
		 toSett
		
		*!*	<pdm>
		*!*	<descr>Checks a given vcx file for changes.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Full qualified file to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Path of the operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlToBin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSett" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object.</short>
		*!*	<detail>Object with folder settings of FoxBin2PRG.</detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="1" /> is changed.</retval>
		*!*	<remarks>
		*<p>This will test checksum first.</p>
		*<p>If checksum is changed and multi class processing it will check single classes for change.</p>
		*<p>This will parse out any class in a given vcx.
		*It checks for uniquenes of the UniqueID field of the vcx.
		*If this is not unique it will first make it unique.</p>
		*<p>A class is a record in the vcx with <expr>PLATFORM=="WINDOWS" AND LEN(PARENT)=0</expr> .</p>
		*<p>It will store information about the classes, not the classlib.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 10.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lnStep      AS INTEGER,;
		 llDirty     AS BOOLEAN,;
		 llOk        AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llDirty = .F.
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE lnStep=1   &&test for changes on file (checksum)
		*llOk - nothing changed on file
		   llOk = !THIS.Sync_File('V',tcFile,tlToBin,tcStorage)
		*/  &&lnStep=1  &&test for changes on file (checksum)
		
		  CASE lnStep=2 AND toSett.n_UseClassPerFile=0    &&Do not split classlib into classlib.class.vc2
		*Sync_File was dirty, we are dirty and done
		*Sync_File was dirty,
		*this could be one out of two problems
		*-file is not to be deleted (8,9) - we are not dirty
		   SELECT;
		    Cur1.iDirty;
		    FROM (tcStorage) AS Cur1;
		    WHERE Cur1.cFile==tcFile;
		    AND Cur1.cType=='V';
		    AND Cur1.iDirty IN (8,9)
		*-if not found we are dirty
		   llDirty = _TALLY=0
		* and done
		   llOk = .T.
		*/  &&lnStep=2 AND toSett.n_UseClassPerFile=0  &&Do not split classlib into classlib.class.vc2
		
		  CASE lnStep=2
		*just loop
		
		  CASE lnStep=3  &&Test access
		   TRY
		*Was zu testen ist
		     USE (tcFile) ALIAS vcx IN SELECT('vcx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&lnStep=3 &&Test  access
		
		  CASE lnStep=4    &&Test if VCX is usable
		*okä, now test this thing
		   SELECT;
		    Cur1.UniqueID,;
		    COUNT(*) AS nCount;
		    FROM vcx AS Cur1;
		    INTO CURSOR curHelp;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0;
		    GROUP BY 1 HAVING nCount>1
		
		*/  &&lnStep=4   &&Test if VCX is usable
		
		  CASE lnStep=5 AND RECCOUNT()>0
		*UniqueID not so unique
		*rebuild, delete from Storage
		   TRY
		*Was zu testen ist
		     USE (tcFile) ALIAS vcx IN SELECT('vcx') EXCLUSIVE
		
		     SELECT vcx
		     REPLACE;
		      UniqueID WITH SYS(2015);
		      FOR PLATFORM='WINDOWS'
		
		     USE (tcFile) ALIAS vcx IN SELECT('vcx')
		    CATCH TO loException
		* irgendein Problem
		     llDirty = .T.
		    FINALLY
		*
		   ENDTRY
		*/   &&lnStep=5 &&Test if VCX is usable
		
		  CASE lnStep=5
		*just loop
		
		  CASE lnStep=6  &&test for changes on classes
		*(only if checksum is changed)
		
		*so now let's see if something is changed
		*get vcx data
		   SELECT;
		    CAST(Cur1.ObjName AS c(240))         AS cObjName,;
		    Cur1.UniqueID+BINTOC(Cur1.TIMESTAMP) AS cUniqueId;
		    FROM vcx AS Cur1;
		    INTO CURSOR curVCX;
		    WHERE Cur1.PLATFORM=="WINDOWS";
		    AND LEN(Cur1.PARENT)=0
		
		   INDEX ON cObjName  TAG _cObj
		   INDEX ON cUniqueId TAG _cUni
		
		   llDirty = THIS.Sync_Objects('v',tcFile,tlToBin,'curVCX',tcStorage)
		
		*/   &&lnStep=6 &&test for changes on classes
		
		  OTHERWISE && end loop
		   EXIT
		 ENDCASE
		
		 IF llDirty OR llOk THEN
		  EXIT
		 ELSE  &&llDirty
		  lnStep = lnStep+1
		 ENDIF &&llDirty
		
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		USE IN SELECT('vcx')
		USE IN SELECT('curVCX')
		
		*For one or the other reason. reprocess
		RETURN llDirty
		
		
	ENDPROC

	PROCEDURE convert		&& Convert complete set, not partial.
		LPARAMETERS;
		 taFiles,;
		 tlProcess,;
		 toConverter,;
		 tnOffset
		
		*!*	<pdm>
		*!*	<descr>Converts a preprocessed bunch of files with FoxBin2Prg.Execute</descr>
		*!*	<params name="taFiles" type="Array" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*<p>A two column array.</p>
		*<dl>
		* <dt>Column one</dt><dd>File to process.</dd>
		* <dt>Column two</dt><dd>Second parameter of Execute</dd>
		*</dl>
		*</detail>
		*!*	</params>
		*!*	<params name="tlProcess" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Value for FoxBin2PRG's l_ProcessFiles.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<params name="tnOffset" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Offset for progress bar.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Operation successfully ended.</retval>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile      AS CHARACTER,;
		 lnFile      AS NUMBER,;
		 lnFiles     AS NUMBER,;
		 llOk        AS BOOLEAN
		
		lnFiles  = ALEN(taFiles,1)
		llOk     = True
		
		toConverter.l_AutoClearProcessedFiles = .T.
		
		FOR lnFile = 1 TO lnFiles
		ACTIVATE SCREEN
		 lcFile = taFiles(lnFile,1)
		 ?JUSTFNAME(lcFile)
		 IF !FILE(lcFile) THEN
		  ?? " - not found"
		  LOOP
		 ENDIF &&!FILE(lcFile)
		
		
		 toConverter.l_ProcessFiles = .T.
		 toConverter.UpdateProgressbar('',lnFile+tnOffset,lnFiles+tnOffset+1,0)
		 toConverter.l_ProcessFiles = tlProcess
		
		 IF toConverter.Execute(lcFile,taFiles(lnFile,2),"0","0","0","0","1")#0 THEN
		  llOk = .F.
		  EXIT
		 ENDIF &&toConverter.Execute(lcFile,taFiles(lnFile,2),"0","0","1","0","1")#0
		
		 toConverter.l_AutoClearProcessedFiles = .F.
		ENDFOR &&lnFile
		
		RETURN llOk
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS;
		 tnError,;
		 tcMethod,;
		 tnLine
		
		LOCAL ARRAY;
		 laError(1,7)
		
		AERROR(laError)
		MESSAGEBOX('Error:'+PADL(tnError,5)+', '+MESSAGE()+0h0d0a+;
		 'Code block: '+THIS.CLASS+'.'+tcMethod+0h0d0a+;
		 'Code line: '+PADL(tnLine,7),;
		 64,'Ooops, works not as expected.')
		DEBUG
		SUSPEND
		RETRY
		CANCEL
		
		*!*	<pdm>
		*!*	<descr>Just a bit more then just let it crash.</descr>
		*!*	<params name="tnError" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcMethod" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tnLine" type="Numeric" byref="0" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
	ENDPROC

	PROCEDURE filestoprocess		&& Test if files are changed since last run.
		LPARAMETERS;
		 taFiles,;
		 tcPath,;
		 tlToBin,;
		 tlCheckAll,;
		 tcStorage,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Test if files are changed since last run.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*<p>The output of FoxBin2Prg <b>Get_Processed</b> method.</p>
		*<p>After return the Array will hold files to be processed.</p>
		*</detail>
		*!*	</params>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source path of the Operation.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlToBin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*<p>Checks if all files listed in <pdmpara num="5" /> are used in <pdmpara num="1" />.</p>
		*<p>If a file is not found, text file corresponding will be deleted.</p>
		*<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<retval type="Boolean">Notes if the array need to be processed.</retval>
		*!*	<remarks>
		*<p>Parses <pdmpara num="1" /> for binaries that can be checked for changed. For now this will be scx and vcx files.</p>
		*<p>The actual state will be stored in a file <b>Bin2Txt.DBF</b> in <pdmpara num="2" /> path.</p>
		*<p>This file will hold information about any object of a vcx and information about scx.</p>
		*<p>The function will not handle any <b>source</b> file not found in the Array.</p>
		*<p>It is possible to delete splitted classes text file if the class is removed from an scx /vcx.</p>
		*<p>If <pdmpara num="4" /> is true, text files for binary files removed might be deleted too.</p>
		*</remarks>
		*!*	<copyright><i>&copy; 5.6.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" />
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile    AS CHARACTER,;
		 lnLine    AS NUMBER,;
		 lnLines   AS NUMBER,;
		 lnInPut   AS NUMBER,;
		 lnDirty   AS NUMBER,;
		 llDirty   AS BOOLEAN,;
		 loSett    AS OBJECT
		
		STORE ALEN(taFiles,1) TO;
		 lnLines,;
		 lnInPut
		
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:31:00}">Changed by: SF<br />
		*!*	Handle deletion of obsolete text files for binaries.
		*!*	</change>
		*!*	</pdm>
		
		 IF tlCheckAll THEN
		*we clean up now, because of post-processing
		*we clean up deleted now, because of post-processing
		 DELETE Cur1;
		  FROM (tcStorage) AS Cur1;
		  WHERE Cur1.iDirty=-2
		
		*check obsolete files
		 UPDATE Cur1 SET;
		  iDirty   = -1,;
		  tLastUse = DATETIME();
		  FROM (tcStorage) AS Cur1;
		  WHERE !EMPTY(Cur1.cFile);
		  AND Cur1.cType IN ('V','v','R','M','d','D','P','B','K','k')
		ENDIF &&tlCheckAll
		*!*	/Changed by: SF 4.6.2015
		
		lnDirty = 0
		FOR lnLine = lnLines TO 1 STEP -1
		 lcFile  = taFiles(lnLine,1)
		 llDirty = .F.
		 DO CASE
		  CASE !TRIM(taFiles(lnLine,2))=="O" AND  tlToBin
		*ToBin, we process only output (binaries only)
		   lnInPut = lnInPut-1
		  CASE !TRIM(taFiles(lnLine,2))=="I" AND !tlToBin
		*ToText, we process only input
		   lnInPut = lnInPut-1
		  CASE !TRIM(taFiles(lnLine,3))=="P1"
		*File must be processed
		   lnInPut = lnInPut-1
		  CASE !TRIM(taFiles(lnLine,6))=="X0"
		*file must be main file, no split file
		   lnInPut = lnInPut-1
		  CASE UPPER(JUSTEXT(lcFile))=="VCX"
		   loSett  = THIS.OGet_Setting(JUSTPATH(lcFile),toConverter)
		   llDirty = THIS.Check_VCX(UPPER(lcFile),tcPath,tlToBin,tcStorage,loSett)
		  CASE UPPER(JUSTEXT(lcFile))=="FRX"
		   llDirty = THIS.Sync_File('R',UPPER(lcFile),tlToBin,tcStorage)
		  CASE UPPER(JUSTEXT(lcFile))=="MNX"
		   llDirty = THIS.Sync_File('M',UPPER(lcFile),tlToBin,tcStorage)
		  CASE UPPER(JUSTEXT(lcFile))=="DBF"
		   llDirty = THIS.Sync_File('d',UPPER(lcFile),tlToBin,tcStorage)
		  CASE UPPER(JUSTEXT(lcFile))=="DBC"
		   llDirty = THIS.Sync_File('D',UPPER(lcFile),tlToBin,tcStorage)
		  CASE UPPER(JUSTEXT(lcFile))=="PJX"
		   llDirty = THIS.Sync_File('P',UPPER(lcFile),tlToBin,tcStorage)
		  CASE UPPER(JUSTEXT(lcFile))=="LBX"
		   llDirty = THIS.Sync_File('B',UPPER(lcFile),tlToBin,tcStorage)
		  CASE UPPER(JUSTEXT(lcFile))=="SCX"
		   loSett  = THIS.OGet_Setting(JUSTPATH(lcFile),toConverter)
		   llDirty = THIS.Check_SCX(UPPER(lcFile),tcPath,tlToBin,tcStorage,loSett)
		  OTHERWISE
		   llDirty = .T.
		 ENDCASE
		 IF llDirty THEN
		  lnDirty = lnDirty+1
		 ELSE  &&llDirty
		  ADEL(taFiles,MAX(lnLine,1))
		 ENDIF &&llDirty
		ENDFOR &&lnLine
		
		DIMENSION;
		 taFiles(MAX(lnDirty,1),ALEN(taFiles,2))
		
		IF lnDirty<1 THEN
		 taFiles = ''
		ENDIF &&lnLine<1
		
		RETURN IIF(lnDirty=lnInPut,NIL,lnDirty>0)
		
	ENDPROC

	PROCEDURE get_converter		&& Create FoxBin2PRG object.
		LPARAMETERS;
		 tcStorage,;
		 toConverter,;
		 tlCloseTable
		
		*!*	<pdm>
		*!*	<descr>Create converter object and open storage table</descr>
		*!*	<params name="tcStorage" type="Character" byref="1" dir="Out" inb="0" outb="0">
		*!*	<short>Alias of storage table.</short>
		*!*	<detail><expr>.NULL.</expr> if not found or closed by <pdmpara num="3" />. </detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Character" byref="1" dir="Out" inb="0" outb="0">
		*!*	<short>Instance of FoxBin2PRG.</short>
		*!*	<detail><expr>.NULL.</expr> id not instantiated. </detail>
		*!*	</params>
		*!*	<params name="tlCloseTable" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Do not keep storage table open.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Error</retval>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 llOk AS BOOLEAN
		
		llOk = True
		IF PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path) THEN
		 tcStorage = THIS.Storage_Open(_SCREEN.gcB2T_Path)
		ELSE  &&PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		 tcStorage = THIS.Storage_Check(False)
		 IF ISNULL(tcStorage) THEN
		  llOk = False
		 ENDIF &&ISNULL(tcStorage)
		ENDIF &&PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		
		IF llOk THEN
		 toConverter = NEWOBJECT("c_foxbin2prg",_SCREEN.gcB2T_FB2T)
		 IF !VARTYPE(toConverter)="O" OR ISNULL(toConverter) THEN
		  toConverter = NIL
		  llOk = False
		 ENDIF &&!TYPE(toConverter)="O" OR ISNULL(toConverter)
		ELSE  &&llok
		 toConverter = NIL
		ENDIF &&llok
		
		llOk = !llOk
		IF (llOk OR tlCloseTable) AND !ISNULL(tcStorage) THEN
		 THIS.Storage_Close(tcStorage,True)
		 tcStorage = NIL
		ENDIF &&llOk OR lloktlCloseTable
		
		RETURN llOk
		
	ENDPROC

	PROCEDURE get_md5
		#IF .F. THEN
		 #include "C:\Program Files (x86)\Microsoft Visual FoxPro 9\ffc\wincrypt.h"
		
		* This routine takes a string as input
		* and returns an MD5 hash value as a string.
		*
		* The calculation in implemented using the MS Crypto API and the RSA provider.
		 LPARAMETERS;
		  tcData
		
		 LOCAL;
		  lnStatus,;
		  lnErr,;
		  lhProv,;
		  lhHashObject,;
		  lnDataSize,;
		  lcHashValue,;
		  lnHashSize
		
		 lhProv = 0
		 lhHashObject = 0
		 lnDataSize = LEN(tcData)
		 lcHashValue = REPLICATE(CHR(0), 16)
		 lnHashSize = LEN(lcHashValue)
		
		
		 TRY
		
		   DECLARE INTEGER GetLastError ;
		    IN win32api AS GetLastError
		
		   DECLARE INTEGER CryptAcquireContextA ;
		    IN WIN32API AS CryptAcquireContext ;
		    INTEGER @lhProvHandle, ;
		    STRING  cContainer, ;
		    STRING  cProvider, ;
		    INTEGER nProvType, ;
		    INTEGER nFlags
		
		* load a crypto provider
		   lnStatus = CryptAcquireContext(@lhProv, 0, 0, dnPROV_RSA_FULL, dnCRYPT_VERIFYCONTEXT)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		   DECLARE INTEGER CryptCreateHash ;
		    IN WIN32API AS CryptCreateHash ;
		    INTEGER hProviderHandle, ;
		    INTEGER nALG_ID, ;
		    INTEGER hKeyhandle, ;
		    INTEGER nFlags, ;
		    INTEGER @hCryptHashHandle
		
		* create a hash object that uses MD5 algorithm
		   lnStatus = CryptCreateHash(lhProv, dnCALG_MD5, 0, 0, @lhHashObject)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptHashData ;
		    IN WIN32API AS CryptHashData ;
		    INTEGER hHashHandle, ;
		    STRING  @cData, ;
		    INTEGER nDataLen, ;
		    INTEGER nFlags
		
		* add the input data to the hash object
		   lnStatus = CryptHashData(lhHashObject, tcData, lnDataSize, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptGetHashParam ;
		    IN WIN32API AS CryptGetHashParam ;
		    INTEGER hHashHandle, ;
		    INTEGER nParam, ;
		    STRING  @cHashValue, ;
		    INTEGER @nHashSize, ;
		    INTEGER nFlags
		
		* retrieve the hash value, if caller did not provide enough storage (16 bytes for MD5)
		* this will fail with dnERROR_MORE_DATA and lnHashSize will contain needed storage size
		   lnStatus = CryptGetHashParam(lhHashObject, dnHP_HASHVAL, @lcHashValue, @lnHashSize, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptDestroyHash ;
		    IN WIN32API AS CryptDestroyHash;
		    INTEGER hKeyHandle
		
		* free the hash object
		   lnStatus = CryptDestroyHash(lhHashObject)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		
		   DECLARE INTEGER CryptReleaseContext ;
		    IN WIN32API AS CryptReleaseContext ;
		    INTEGER hProvHandle, ;
		    INTEGER nReserved
		
		* release the crypto provider
		   lnStatus = CryptReleaseContext(lhProv, 0)
		   IF lnStatus = 0
		    THROW GetLastError()
		   ENDIF
		
		  CATCH TO lnErr
		
		* clean up the hash object and release provider
		   IF lhHashObject != 0
		    CryptDestroyHash(lhHashObject)
		   ENDIF
		
		
		   IF lhProv != 0
		    CryptReleaseContext(lhProv, 0)
		   ENDIF
		
		   ERROR("HashMD5 Failed")
		
		 ENDTRY
		
		 RETURN lcHashValue
		#ENDIF &&.F.
		
	ENDPROC

	PROCEDURE oget_setting		&& Returns a settings object of a given path with config from FoxBin2PRG.
		LPARAMETERS;
		 tcPath,;
		 toConverter
		
		*!*	<pdm>
		*!*	<descr>Returns FoxBin2Prg's setting.</descr>
		*!*	<params name="tcPath" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source path of the operation</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toConverter" type="Object" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Converter object</short>
		*!*	<detail>Instance of FoxBin2PRG for further operation.</detail>
		*!*	</params>
		*!*	<retval type="Object">Settings object of FoxBin2Prg.</retval>
		*!*	<remarks>Returns FoxBin2Prg's setting for path <pdmpara num="1" />.</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 13.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcTemp    AS CHARACTER,;
		 loSett    AS OBJECT,;
		 loSetts   AS COLLECTION
		
		
		IF !PEMSTATUS(THIS,'goSetts',5) THEN
		 THIS.ADDPROPERTY('goSetts',NEWOBJECT("COLLECTION"))
		ENDIF &&!PEMSTATUS(THIS,'goSetts',5)
		
		lcTemp = SYS(2007,UPPER(tcPath),0,2)
		IF THIS.goSetts.GETKEY(lcTemp)#0 THEN
		 loSett = THIS.goSetts.ITEM(lcTemp)
		ELSE  &&THIS.goSetts.GETKEY(lcTemp)#0
		 loSett = toConverter.Get_DirSettings(tcPath)
		 THIS.goSetts.ADD(loSett,lcTemp)
		ENDIF &&THIS.goSetts.GETKEY(lcTemp)#0
		
		RETURN loSett
		
	ENDPROC

	PROCEDURE process_bin2text		&& Process all files of a given ayrray.
		LPARAMETERS;
		 taFiles,;
		 tlToBin,;
		 tcMode,;
		 tlCheckAll
		
		*!*	<pdm>
		*!*	<descr>Process all files of a given Array.</descr>
		*!*	<params name="taFiles" type="Array" byref="1" dir="In/Out" inb="0" outb="0">
		*!*	<short>Array with files.</short>
		*!*	<detail>
		*<p>List of files to process.</p>
		*<p>Allways binaries, even if as target not existing yet!.</p>
		*<p>The method determines correct extensions for text files itself.</p>
		*<p>The array can be one or two dimensional</p>
		*<dl>
		* <dt>Column one</dt><dd>Binary file with path.</dd>
		* <dt>Column two</dt>
		*  <dd>
		*   Optional. Defines a ProjectHook.<br />
		*   <expr>.NULL.</expr> if not determined, Empty, if no ProjectHook is to be processed.<br />
		*   Only valid for PJX files in column one.
		*  </dd>
		*</dl>
		*</detail>
		*!*	</params>
		*!*	<params name="tlToBin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction. If <expr>.T.</expr> files will be converted to binary.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcMode" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>FoxBin2PRG's mode switch.</short>
		*!*	<detail>
		*<p>Used for PJX / PJ2 files, values "*", "*-", "".</p>
		*<p>All other files will be processed with default like "".</p>
		*<p></p>
		*</detail>
		*!*	</params>
		*!*	<params name="tlCheckAll" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Check existence of files.</short>
		*!*	<detail>
		*<p>Checks if all files listed in <pdmpara num="1" /> are used.</p>
		*<p>If a file is not found, text file corresponding will be deleted.</p>
		*<p>Only if <b>Delete obsolete files</b> is checked in settings dialog.</p>
		*</detail>
		*!*	</params>
		*!*	<retval type="Boolean">Returns succcess of operation.</retval>
		*!*	<remarks>
		*<b>This is the main method. What makes it different from a plain call to FoxBin2Prg is:</b>
		*<ul>
		* <li>Accepts a mixed array of files. (including whole PJX) </li>
		* <li>Can limit the Bin2Text operation to dirty files only.</li>
		* <li>Can delete obsolete class files in ClassPerFile operations.</li>
		* <li>Can delete obsolete files for removed binaries if <pdmpara num="4" />.</li>
		*</ul>
		*<p>If text to binary, it just passes the files to FoxBin2Prg</p>
		*<p>Creating text files, depending on a setting, it first let check FoxBin2Prg what to do.
		* IOW what files are included in the process.</p>
		*<p>Then it calls for <see pem="FilesToProcess" /> to see if files are changed.
		* Only files marked as dirty will be processed.</p>
		*<p>A postprocess will delete / remove obsolete text files.</p>
		*!*	</remarks>
		*!*	<copyright><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,11:19:00}">Changed by: SF<br />
		*!*	New parameter <pdmpara num="4" />
		*!*	</change>
		*!*	</pdm>
		
		EXTERNAL ARRAY;
		 taFiles
		
		LOCAL;
		 lcFile      AS CHARACTER,;
		 lcMode      AS CHARACTER,;
		 lcPath      AS CHARACTER,;
		 lcSourceExt AS CHARACTER,;
		 lcStorage   AS CHARACTER,;
		 lcTarget    AS CHARACTER,;
		 lnFile      AS NUMBER,;
		 lnFiles     AS NUMBER,;
		 lnOffset    AS NUMBER,;
		 lnOffsets   AS NUMBER,;
		 lnReturn    AS NUMBER,;
		 llFound     AS BOOLEAN,;
		 llMaxiLoop  AS BOOLEAN,;
		 lvTime      AS VARIANT,;
		 loProject   AS PROJECT,;
		 loSett      AS OBJECT,;
		 loConverter AS "c_foxbin2prg" OF "E:\x\Helper\ThirdParty\VFPX\FoxBin2PRG\FOXBIN2PRG.PRG"
		
		lvTime = SECONDS()
		IF THIS.Get_Converter(@lcStorage,@loConverter) THEN
		 RETURN False
		ENDIF &&THIS.Get_Converter(@lcStorage,@loConverter)
		
		LOCAL ARRAY;
		 laFiles(ALEN(taFiles,1),4)
		
		laFiles = NIL
		STORE ALEN(taFiles,1) TO;
		 lnFiles,;
		 lnOffsets
		
		lcMode = IIF(tlToBin,"PRG2BIN","BIN2PRG")
		
		*process sourcefiles
		FOR lnFile = 1 TO lnFiles
		*wie machen wir das wenn wir noch keine pjx haben?!!!
		 IF tlToBin THEN
		  loSett      = THIS.oGet_Setting(JUSTPATH(taFiles(lnFile,1)),loConverter)
		  lcSourceExt = UPPER(JUSTEXT(taFiles(lnFile,1)))
		
		  DO CASE
		   CASE UPPER(lcSourceExt)=="VCX"
		    lcSourceExt = loSett.c_VC2
		   CASE UPPER(lcSourceExt)=="FRX"
		    lcSourceExt = loSett.c_FR2
		   CASE UPPER(lcSourceExt)=="MNX"
		    lcSourceExt = loSett.c_MN2
		   CASE UPPER(lcSourceExt)=="DBF"
		    lcSourceExt = loSett.c_DB2
		   CASE UPPER(lcSourceExt)=="DBC"
		    lcSourceExt = loSett.c_DC2
		   CASE UPPER(lcSourceExt)=="PJX"
		    lcSourceExt = loSett.c_PJ2
		   CASE UPPER(lcSourceExt)=="LBX"
		    lcSourceExt = loSett.c_LB2
		   CASE UPPER(lcSourceExt)=="SCX"
		    lcSourceExt = loSett.c_CC2
		   OTHERWISE
		  ENDCASE
		
		  laFiles(lnFile,1) = FORCEEXT(taFiles(lnFile,1),lcSourceExt)	&&Source File of transformation; Bin or Text
		 ELSE  &&tlToBin
		  laFiles(lnFile,1) = taFiles(lnFile,1)							&&Source File of transformation; Bin or Text
		 ENDIF &&tlToBin
		
		 laFiles(lnFile,2) = tcMode 									&&a project file bin or text
		 laFiles(lnFile,3) = taFiles(lnFile,1)							&&VFP Bin File
		 DO CASE
		  CASE !UPPER(JUSTEXT(taFiles(lnFile,1)))='PJX'
		*nothing to do
		   laFiles(lnFile,4) = 0										&&No Hook
		   laFiles(lnFile,2) = lcMode									&&not a project file
		  CASE ALEN(taFiles,2)<2
		*nothing defined yet, parse later
		   laFiles(lnFile,4) = 2										&&No Hook, but mybe after conversion
		  CASE ALEN(taFiles,2)<2 AND !tlToBin
		*nothing defined, parse later
		   laFiles(lnFile,4) = 1										&&No Hook, but maybe
		  CASE ISNULL(taFiles(lnFile,2))
		*nothing defined yet, parse again after processing (if pjx changed)
		   laFiles(lnFile,4) = 2										&&No Hook, but mybe after conversion
		  CASE ISNULL(taFiles(lnFile,2)) AND !tlToBin
		*nothing defined yet, parse later
		   laFiles(lnFile,4) = 1										&&No Hook, but maybe
		  CASE EMPTY(taFiles(lnFile,2))
		*nothing hook defined yet, but may change again after processing (if pjx changed)
		   laFiles(lnFile,4) = 2										&&No Hook, but mybe after conversion
		  CASE EMPTY(taFiles(lnFile,2)) AND !tlToBin
		*no Hook, do nothing
		   laFiles(lnFile,4) = 0										&&No Hook
		  CASE tlToBin
		   laFiles(lnFile,4) = 2										&&we have a hook, but check after conversion again
		  OTHERWISE  && tlToBin
		*Hook, to text
		   lnOffsets = lnOffsets+1
		   DIMENSION;
		    laFiles(lnOffsets,4)
		
		   laFiles(lnOffsets,1) = taFiles(lnFile,2)						&&Source File of transformation; Bin
		   laFiles(lnOffsets,2) = lcMode								&&not a project file
		   laFiles(lnOffsets,3) = taFiles(lnFile,2)						&&VFP Bin File
		   laFiles(lnOffsets,4) = 0										&&no Hook
		
		   laFiles(lnFile,4) = 0
		 ENDCASE
		ENDFOR &&lnFile
		
		*!*	Change by: SF 15.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-15,06:56:00}">Change by: SF<br />
		*!*	Preprocessing <expr>PROJECTHOOKLIBRARY</expr> only for Bin 2 Text
		*!*	</change>
		*!*	</pdm>
		
		IF !tlToBin THEN
		*process transformation, only for Bin 2 Text (Text 2 Bin will be read after recreating)
		FOR lnFile = 1 TO lnFiles
		 lcFile = laFiles(lnFile,3)
		 IF laFiles(lnFile,4)=1 AND FILE(lcFile) AND UPPER(JUSTEXT(lcFile))=='PJX' THEN
		
		  MODIFY PROJECT (lcFile) NOWAIT NOSHOW NOPROJECTHOOK
		  loProject = _VFP.PROJECTS(JUSTFNAME(lcFile))
		  lcFile    = loProject.PROJECTHOOKLIBRARY
		  loProject.CLOSE
		
		  IF !EMPTY(lcFile) THEN
		   lnOffsets = lnOffsets+1
		   DIMENSION;
		    laFiles(lnOffsets,5)
		
		   laFiles(lnOffsets,1) = lcFile								&&Source File of transformation; Bin
		   laFiles(lnOffsets,2) = lcMode								&&not a project file
		   laFiles(lnOffsets,3) = lcFile								&&VFP Bin File
		   laFiles(lnOffsets,4) = 0										&&No Hook :)
		  ENDIF &&!EMPTY(lcFile)
		 ENDIF &&laFiles(lnFile,4)=1 AND FILE(lcFile) AND UPPER(JUSTEXT(lcFile))=='PJX'
		ENDFOR &&lnFile
		ENDIF &&!tlToBin 
		
		*!*	/Change by: SF 15.6.2015
		
		* only bin to text for now and switch not all set
		llMaxiLoop = !tlToBin AND !ISNULL(lcStorage) AND TYPE('_SCREEN.gcB2T_Opt')="C" AND _SCREEN.gcB2T_Opt=="1"
		llFound = .T.
		
		lcPath = JUSTPATH(_SCREEN.gcB2T_Path)
		
		loConverter.LoadProgressbarForm()
		ACTIVATE SCREEN
		
		llFound = THIS.Convert(@laFiles,!llMaxiLoop,loConverter,0)
		
		*ReRun only file(s) changed
		IF llFound THEN
		 LOCAL ARRAY;
		  laFiles2(1,2)
		
		 laFiles2 = ''
		 IF loConverter.Get_Processed(@laFiles2)#0 THEN
		*Call FilesToProcess in every case, if run after Text2Bin it will set Storage to
		*actual values
		
		*Note! This will change the array!
		*just process all if
		* !maxiloop and !isnull(storage) -> just process files
		* maxiloop (nur wenn !ISNULL(storage!!)) and processfiles -> run partial
		*maxiloop and isnull(storage)
		*SET STEP ON
		  IF !llMaxiLoop AND !ISNULL(lcStorage) THEN
		*Complet convert is done, just store result
		   THIS.FilesToProcess(@laFiles2,lcPath,tlToBin,tlCheckAll,lcStorage,loConverter)
		*but if we create binaries we may have still undone stuff like new hooks
		   IF tlToBin THEN
		    DIMENSION;
		     laFiles2(1,2)
		
		    lnOffset = 0
		    FOR lnFile = 1 TO lnFiles
		     lcFile = laFiles(lnFile,3)
		     IF laFiles(lnFile,4)>1 AND FILE(lcFile) AND UPPER(JUSTEXT(lcFile))=='PJX' THEN
		
		*!*	Changed by: SF 11.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-11,20:50:00}">Changed by: SF<br />
		*!* <expr>NOPROJECTHOOK</expr> will open the hook, but not use. So it fails with libray not existing
		*!*	</change>
		*!*	</pdm>
		
		*!*	      MODIFY PROJECT (lcFile) NOWAIT NOSHOW NOPROJECTHOOK
		*!*	      loProject = _VFP.PROJECTS(JUSTFNAME(lcFile))
		*!*	      lcFile    = loProject.PROJECTHOOKLIBRARY
		*!*	      loProject.CLOSE
		
		      USE (lcFile) ALIAS curPJX IN SELECT('curPJX')
		      SELECT;
		       Cur1.NAME AS cFile;
		       FROM curPJX AS Cur1;
		       INTO CURSOR curW;
		       WHERE TYPE=='W'
		
		      IF RECCOUNT()=0 OR EMPTY(cFile) THEN
		       lcFile    = ''
		      ELSE  &&RECCOUNT()=0
		       lcFile    = ADDBS(JUSTPATH(lcFile))+SYS(2014,ALLTRIM(cFile),lcFile)
		      ENDIF &&RECCOUNT()=0
		      USE IN curW
		      USE IN curPJX
		
		*!*	/Changed by: SF 11.6.2015
		
		      IF !EMPTY(lcFile) THEN
		       lnOffset = lnOffset+1
		       DIMENSION;
		        laFiles2(lnOffset,2)
		
		       loSett      = THIS.oGet_Setting(JUSTPATH(lcFile),loConverter)
		       lcSourceExt = loSett.c_VC2
		
		       laFiles2(lnOffset,1) = FORCEEXT(lcFile,lcSourceExt)			&&Source File of transformation; Bin
		       laFiles2(lnOffset,2) = lcMode								&&not a project file
		      ENDIF &&!EMPTY(lcFile)
		     ENDIF &&laFiles(lnFile,4)>1 AND FILE(lcFile) AND UPPER(JUSTEXT(lcFile))=='PJX'
		    ENDFOR &&lnFile
		
		    IF lnOffset>0 THEN
		     ACTIVATE SCREEN
		     ?"post process projcet hooks"
		     llFound = THIS.Convert(@laFiles2,.T.,loConverter,lnFiles)
		
		     DIMENSION;
		      laFiles2(1,1)
		*just rework hooks in storage table
		     IF loConverter.Get_Processed(@laFiles2)#0 THEN
		      THIS.FilesToProcess(@laFiles2,lcPath,tlToBin,.F.,lcStorage,loConverter)
		     ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		    ENDIF &&lnOffset>0
		
		   ENDIF &&tlToBin
		  ELSE  &&!llMaxiLoop AND !ISNULL(lcStorage)
		   llProcess = THIS.FilesToProcess(@laFiles2,lcPath,tlToBin,tlCheckAll,lcStorage,loConverter)
		   DO CASE
		    CASE ISNULL(llProcess)
		*need to process all files -> just let FoxBin2PRG do, faster.
		     llFound = THIS.Convert(@laFiles,.T.,loConverter,lnFiles)
		    CASE llProcess
		*If not processed in first loop, process now, file by file.
		     loConverter.l_ProcessFiles = .T.
		     loConverter.l_AutoClearProcessedFiles = .T.
		
		     lnFiles  = ALEN(laFiles2,1)
		*just set "not a project"
		     FOR lnFile = 1 TO lnFiles
		      laFiles2(lnFile,2) = lcMode
		     ENDFOR &&lnFile
		     llFound = THIS.Convert(@laFiles2,.T.,loConverter,lnOffsets)
		   ENDCASE
		
		  ENDIF &&!llMaxiLoop AND !ISNULL(lcStorage)
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:40:00}">Changed by: SF<br />
		*!*	Code to delte / backup text files no more needed.
		*!*	</change>
		*!*	</pdm>
		
		  IF _SCREEN.gcB2T_Delete=="1" THEN
		*Delete obsolete classes from classlibs
		   SELECT (lcStorage)
		*sfx todo SQL
		   SCAN FOR iDirty=-1
		
		    loSett      = THIS.oGet_Setting(JUSTPATH(cFile),loConverter)
		    lcSourceExt = UPPER(JUSTEXT(cFile))
		
		    DO CASE
		     CASE UPPER(lcSourceExt)=="VCX"
		      lcSourceExt = loSett.c_VC2
		     CASE UPPER(lcSourceExt)=="FRX"
		      lcSourceExt = loSett.c_FR2
		     CASE UPPER(lcSourceExt)=="MNX"
		      lcSourceExt = loSett.c_MN2
		     CASE UPPER(lcSourceExt)=="DBF"
		      lcSourceExt = loSett.c_DB2
		     CASE UPPER(lcSourceExt)=="DBC"
		      lcSourceExt = loSett.c_DC2
		     CASE UPPER(lcSourceExt)=="PJX"
		      lcSourceExt = loSett.c_PJ2
		     CASE UPPER(lcSourceExt)=="LBX"
		      lcSourceExt = loSett.c_LB2
		     CASE UPPER(lcSourceExt)=="SCX"
		      lcSourceExt = loSett.c_CC2
		     OTHERWISE
		      LOOP
		    ENDCASE
		
		    lcFile = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		     EVL(FORCEEXT(ALLTRIM(cObjName),lcSourceExt),lcSourceExt)
		
		    DO CASE
		     CASE !FILE(lcFile)
		*nothing found, nothing to do
		     CASE loSett.n_ExtraBackupLevels>0
		*Backup (only one level deep)
		      lcSourceExt = lcSourceExt+'.Del.Bak'
		      lcTarget = JUSTPATH(cFile)+'\'+JUSTSTEM(cFile)+'.'+;
		       EVL(FORCEEXT(ALLTRIM(cObjName),lcSourceExt),lcSourceExt)
		
		      IF FILE(lcTarget) THEN
		       DELETE FILE &lcTarget
		      ENDIF &&FILE(lcTarget)
		      RENAME &lcFile TO &lcTarget
		
		     OTHERWISE
		*Delete
		      DELETE FILE &lcFile
		    ENDCASE
		*sfx todo SQL
		    REPLACE;
		     iDirty WITH -2
		   ENDSCAN &&iDirty=-1
		  ENDIF &&_SCREEN.gcB2T_Delete=="1"
		*!*	/Changed by: SF 4.6.2015
		
		 ENDIF &&loConverter.Get_Processed(@laFiles2)#0
		ENDIF &&llFound
		
		loConverter.UnloadProgressbarForm()
		loConverter =  NIL
		
		THIS.Storage_Close(lcStorage,llFound)
		
		ACTIVATE SCREEN
		IF !llFound THEN
		 ?"Conversion is canceled"
		ENDIF &&!llFound
		??' Duration:',SECONDS()-lvTime
		
		RETURN llFound
		
	ENDPROC

	PROCEDURE storage_check		&& Check for valid  storage settings, alter settings
		LPARAMETERS;
		 tlInterActive,;
		 tcHomePath
		
		*!*	<pdm>
		*!*	<descr>Check program settings.</descr>
		*!*	<params name="tlInterActive" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Interactive settings.</short>
		*!*	<detail>display the parent form to change the settings.</detail>
		*!*	</params>
		*!*	<params name="tcHomePath" type="Character" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Home path of he actual VFP IDE.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">
		*Alias of the storage table. <expr>.NULL.</expr> if error or <pdmpara num="1" />.
		*</retval>
		*!*	<remarks>
		*<p>Opens the storage file and read settings. Test if settings are existing, not if valid.</p>
		*<p>If set <pdmpara num="1" /> the form will be opened to change and store settings.</p>
		*<p>The storage file will kept open if not <pdmpara num="1" />, the alias will be returned if open.</p>
		*</remarks>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile    AS CHARACTER,;
		 lcStorage AS CHARACTER,;
		 llSearch  AS BOOLEAN,;
		 llWrite   AS BOOLEAN,;
		 llError   AS BOOLEAN,;
		 loSetting AS COLLECTION
		
		IF PCOUNT()>1 AND VARTYPE(tcHomePath)='C' THEN
		*Storage_Location works different with parameter set
		 lcFile    = THIS.Storage_Location(tcHomePath)
		ELSE  &&PCOUNT()>1 AND VARTYPE(tcHomePath)='C'
		 lcFile    = THIS.Storage_Location()
		ENDIF &&PCOUNT()>1 AND VARTYPE(tcHomePath)='C'
		
		IF ISNULL(lcFile) THEN
		 llError = True
		ELSE  &&ISNULL(lcFile)
		
		 lcStorage = THIS.Storage_Open(lcFile)
		
		 IF ISNULL(lcStorage) THEN
		  llError = True
		 ELSE  &&ISNULL(lcStorage)
		
		  loSetting = NEWOBJECT('collection')
		  THIS.Storage_Get("S",loSetting,lcStorage)
		
		*Storage Path
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Path",5) THEN
		   loSetting.ADD(lcFile,"gcB2T_Path")
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Path",5)
		
		*get FoxBin2Prg.prg
		  llWrite = THIS.Storage_Check_Bin2Prg(@loSetting,@llError) OR llWrite
		
		*auto commit [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Commit",5) THEN
		   loSetting.ADD("0","gcB2T_Commit")
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Commit",5)
		
		*on git: Include pjx in run [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_GitPjx",5) THEN
		   loSetting.ADD("0","gcB2T_GitPjx")
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_GitPjx",5)
		
		*optimize process [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Opt",5) THEN
		   loSetting.ADD("0","gcB2T_Opt")
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Opt",5)
		
		*Delete files of classes removed [1 On; else OFF]
		  IF !PEMSTATUS(_SCREEN,"gcB2T_Delete",5) THEN
		   loSetting.ADD("0","gcB2T_Delete")
		   llWrite = True
		  ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_Delete",5)
		
		  IF !llError AND tlInterActive THEN
		*Interactive
		   _SCREEN.ADDPROPERTY("glSet",False)
		
		*run interactive form
		   THIS.PARENT.Storage_Get(loSetting)
		   THIS.PARENT.SHOW(1)
		   THIS.PARENT.Storage_Put(loSetting)
		
		   llWrite = loSetting.ITEM("glSet")
		   loSetting.REMOVE("glSet")
		
		  ENDIF  &&!llError AND !ISNULL(lcStorage) AND tlInterActive
		 ENDIF &&ISNULL(lcStorage)
		ENDIF  &&ISNULL(lcFile)
		
		IF llError THEN
		 lcStorage = NIL
		 THIS.Storage_Close(lcStorage,.T.)
		ELSE  &&llError
		 IF llWrite THEN
		  THIS.Storage_Set("S",loSetting,lcStorage)
		 ENDIF &&llWrite
		 IF tlInterActive THEN
		  THIS.Storage_Close(lcStorage,.T.)
		  lcStorage = NIL
		 ENDIF &&tlInterActive
		ENDIF &&llError
		
		RETURN lcStorage
		
	ENDPROC

	PROCEDURE storage_check_bin2prg		&& Check location of FoxBin2Prg.
		LPARAMETERS;
		 toSetting AS COLLECTION,;
		 tlError
		
		*!*	<pdm>
		*!*	<descr>Check if FoxBin2PRG is found, locate.</descr>
		*!*	<params name="toSetting" type="COLLECTION" byref="1" dir="" inb="0" outb="0">
		*!*	<short></short>
		*!*	<detail>Object with settings.</detail>
		*!*	</params>
		*!*	<params name="tlError" type="Boolean" byref="1" dir="" inb="0" outb="0">
		*!*	<short>Error</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<comment>
		*!*	<retval type=""></retval>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 17.9.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm> 
		
		LOCAL;
		 lcFile   AS CHARACTER,;
		 lnLoop   AS INTEGER,;
		 llSearch AS BOOLEAN,;
		 llWrite  AS BOOLEAN
		
		llSearch = False
		IF !PEMSTATUS(_SCREEN,"gcB2T_FB2T",5) THEN
		 llSearch = True
		ENDIF &&!PEMSTATUS(_SCREEN,"gcB2T_FB2T",5)
		
		IF !llSearch AND !FILE(_SCREEN.gcB2T_FB2T) THEN
		 llSearch = True
		 MESSAGEBOX('FoxBin2PRG not found in'+0h0D0A+;
		  '"'+_SCREEN.gcB2T_FB2T+'"')
		ENDIF &&!llsearch AND !FILE(_SCREEN.gcB2T_FB2T)
		IF llSearch THEN
		 lcFile = ''
		
		 IF FILE("FoxBin2PRG.prg") THEN
		  lcFile = FULLPATH("FoxBin2PRG.prg")
		 ELSE  &&FILE("FoxBin2PRG.prg")
		  lnLoop = 1
		  lcFile = SYS(16,lnLoop)
		  DO WHILE LEN(lcFile)>0
		   IF UPPER(JUSTEXT(lcFile)) = "APP" THEN
		    IF lcFile="PROCEDURE " THEN
		     lcFile = ADDBS(JUSTPATH(STREXTRACT(lcFile,' ',' ',2,2)))
		    ELSE  &&lcFile="PROCEDURE "
		     lcFile = JUSTPATH(lcFile)
		    ENDIF &&lcFile="PROCEDURE "
		    EXIT
		   ENDIF &&UPPER(JUSTEXT(lcFile)) = "APP"
		   IF UPPER(STREXTRACT(lcFile,' ',' ',1))=="BIN2PRG";
		     OR UPPER(STREXTRACT(lcFile,' ',' ',1))=="INTER_ACTIVE" THEN
		    lcFile = ADDBS(JUSTPATH(STREXTRACT(lcFile,' ',' ',2,2)))
		    EXIT
		   ENDIF &&UPPER(STREXTRACT(lcFile,' ',' ',1))=="BIN2PRG" OR UPPER(STREXTRACT(lcFile,' ',' ',1))=="INTER_ACTIVE"
		   lnLoop = lnLoop+1
		   lcFile = SYS(16,lnLoop)
		  ENDDO &&LEN(lcFile)>0
		 ENDIF &&FILE("FoxBin2PRG.prg")
		
		*Try .. EndTry bei IntelliScript
		 LOCAL;
		  loException AS EXCEPTION
		
		 lcFile = FORCEPATH("FoxBin2PRG.prg",lcFile)
		 TRY
		*Was zu testen ist
		   lcFile = LOCFILE(lcFile,'prg')
		  CATCH TO loException
		   tlError = True
		  FINALLY
		*
		 ENDTRY
		
		 IF !FILE(lcFile) OR !UPPER(JUSTFNAME(lcFile))="FOXBIN2PRG.PRG" THEN
		  tlError = True
		  lcFile  = ''
		  MESSAGEBOX('FoxBin2PRG not found')
		 ENDIF &&!FILE(lcFile) OR !UPPER(JUSTFNAME(lcfile))="FOXBIN2PRG.PRG"
		
		 IF toSetting.GETKEY("gcB2T_FB2T")>0 THEN
		*File defined but not found
		  toSetting.REMOVE("gcB2T_FB2T")
		 ENDIF &&loSetting.GetKey("gcB2T_FB2T")>0
		 toSetting.ADD(lcFile,"gcB2T_FB2T")
		 llWrite = True
		ENDIF &&llSearch
		*/get FoxBin2Prg.prg
		
	ENDPROC

	PROCEDURE storage_close		&& Close the storage file.
		LPARAMETERS;
		 tcStorage,;
		 tlReset
		
		*!*	<pdm>
		*!*	<descr>Close / reset storage table.</descr>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias to close.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlReset" type="Boolean" byref="0" dir="" inb="1" outb="0">
		*!*	<short>Reset dirty flag.</short>
		*!*	<detail>
		*The dirty flag of the Master record will be reset.
		*If not reset next call of <see pem="Storage_Open" /> will delete all records not of type master or setting.
		*</detail>
		*!*	</params>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		
		IF USED(NVL(tcStorage,'')) THEN
		 IF tlReset THEN
		*reset heart beat
		  UPDATE Cur1 SET;
		   iDirty    = 0,;
		   tLastUse  = DATETIME();
		   FROM (tcStorage) AS Cur1;
		   WHERE Cur1.cType=="X"
		 ENDIF &&tlReset
		
		 USE IN (tcStorage)
		ENDIF &&USED(tcStorage)
		
	ENDPROC

	PROCEDURE storage_get		&& Get settings information out of storage
		LPARAMETERS;
		 tcType,;
		 toSetting AS COLLECTION,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Get settings from storage file.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to get settings value.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSetting" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object to write.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias of the storage table.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">At least one setting found.</retval>
		*!*	<remarks>
		*<p>Every record in <pdmpara num="3" /> marked with <pdmpara num="1" /> will be read
		*and stored into <pdmpara num="2" />.</p>
		*<p><pdmpara num="2" /> will be cleared before read.</p>
		*<p>For every item in <pdmpara num="2" /> a property of <expr>_SCREEN</expr> will be created.
		*Form: <expr>_SCREEN.ADDPROPERTY(TRIM(cUniqueID),TRIM(cFile))</expr></p>
		*</remarks>
		*!*	<copyright><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 llOk AS BOOLEAN
		
		SELECT;
		 cur1.cFile,;
		 cur1.cUniqueId;
		 FROM (tcStorage) AS cur1;
		 INTO CURSOR curHelp;
		 WHERE cur1.cType==tcType
		
		llOk = RECCOUNT()>0
		toSetting.REMOVE(-1)
		SCAN
		 toSetting.ADD(TRIM(cFile),TRIM(cUniqueId))
		 _SCREEN.ADDPROPERTY(TRIM(cUniqueId),TRIM(cFile))
		ENDSCAN
		
		USE IN SELECT('curHelp')
		
		RETURN llOk
		
	ENDPROC

	PROCEDURE storage_location		&& Get location for storage file.
		LPARAMETERS;
		 tcHomePath
		
		*!*	<pdm>
		*!*	<descr>Gets location for storage file</descr>
		*!*	<params name="tcHomePath" type="Character" byref="0" dir="" inb="1" outb="1">
		*!*	<short>Home path of he actual VFP IDE.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">
		*<p>Storage file if set by <pdmpara num="1" />, else if found, if not found best guess off directory.</p>
		*<p><expr>.NULL.</expr> if failed.</p>
		*</retval>
		*!*	<comment>
		*!*	<remarks></remarks>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcFile AS CHARACTER
		
		DO CASE
		 CASE PCOUNT()>0 AND !VARTYPE(tcHomePath)="C"
		  lcFile = NIL
		 CASE PCOUNT()>0 AND !DIRECTORY(tcHomePath)
		  lcFile = NIL
		 CASE PCOUNT()>0 AND Is_git(tcHomePath)
		  lcFile = FORCEPATH('Bin2Txt.DBF',GetGitBaseDir(tcHomePath))
		 CASE PCOUNT()>0
		  lcFile = FORCEPATH('Bin2Txt.DBF',tcHomePath)
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND FILE(_SCREEN.gcB2T_Path)
		* we say we have a settings file
		  lcFile = _SCREEN.gcB2T_Path
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C';
		   AND FILE(FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path))
		* we say we have a settings file
		  lcFile = FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path)
		
		*o.k.
		*nothing
		*so start guesswork
		
		 CASE PEMSTATUS(_SCREEN,'gcB2T_Path',5) AND VARTYPE(_SCREEN.gcB2T_Path)='C' AND DIRECTORY(_SCREEN.gcB2T_Path)
		* we say we have a settings locawe define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',_SCREEN.gcB2T_Path)
		 CASE FILE(FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR())))
		* we say we have a settings file
		  lcFile = FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR()))
		 CASE _VFP.PROJECTS.COUNT>0
		* we say we have a settings loca, we define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',JUSTPATH(_VFP.ACTIVEPROJECT.NAME))
		 OTHERWISE
		*no more guesses, we define active directory
		  lcFile = FORCEPATH('Bin2Txt.DBF',FULLPATH(CURDIR()))
		ENDCASE
		
		IF !ISNULL(lcFile) AND Is_git(JUSTPATH(lcFile)) THEN
		*the storage table should not be under git control, in case create / modify .gitignore
		 LOCAL;
		  lcX AS CHARACTER,;
		  lcY AS CHARACTER,;
		  lcZ AS CHARACTER
		
		 lcX = FORCEPATH('.gitignore',JUSTPATH(lcFile))
		 lcY = LOWER(FORCEEXT(JUSTFNAME(lcFile),"*"))
		 IF FILE(lcX) THEN
		  lcZ = FILETOSTR(lcX)
		  IF !lcY$lcZ THEN
		   IF 0h0D0A$lcZ THEN
		    lcZ = lcZ+0h0D0A+lcY
		   ELSE  &&0h0D0A$lcZ
		    lcZ = lcZ+0h0A+lcY
		   ENDIF &&0h0D0A$lcZ
		   STRTOFILE(lcZ,lcX)
		  ENDIF &&!lcx$lcy
		 ELSE &&FILE(lcIgnore)
		  STRTOFILE(lcY,lcX)
		 ENDIF &&FILE(lcX)
		ENDIF &&!ISNULL(lcFile) AND Is_git(JUSTPATH(lcFile))
		
		RETURN lcFile
		
	ENDPROC

	PROCEDURE storage_open		&& Opens the storage file.
		LPARAMETERS;
		 tcFile
		
		*!*	<pdm>
		*!*	<descr>Opens / create storage table.</descr>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>File to open or create.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Character">Alias of the storage table. <expr>.NULL.</expr> if error.</retval>
		*!*	<remarks>
		*</remarks>
		*<remarks>
		*<p>Table structure of the storage table</p>
		* <table border="1" cellspacing="0">
		*  <thead>
		*   <tr>
		*    <td>Field</td><td>type</td><td>usage</td>
		*   </tr>
		*  </thead>
		*  <tbody>
		*  <tr>
		*  <td>cType</td>
		*  <td>c(1)</td>
		*  <td>
		*   <p>A flag to mark the type of the record. Derived from SCCText</p>
		*   <table border="1" cellspacing="0">
		*    <tr><td>d</td><td>DBC</td></tr>
		*    <tr><td>D</td><td>DBF</td></tr>
		*    <tr><td>K</td><td>Form</td></tr>
		*    <tr><td>B</td><td>Label</td></tr>
		*    <tr><td>M</td><td>Menu</td></tr>
		*    <tr><td>R</td><td>Report</td></tr>
		*    <tr><td>V</td><td>Classlibrary</td></tr>
		*    <tr><td>S</td><td>Setting</td></tr>
		*    <tr><td><b>X</b></td><td><b>Heart beat check</b></td></tr>
		*    <tr><td>P</td><td>Project</td></tr>
		*    <tr><td>v</td><td>Class of a vcx</td></tr>
		*    <tr><td>k</td><td>Object of a scx</td></tr>
		*    </table>
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>cFile</td>
		*   <td>c(240)</td>
		*   <td>File to process. Allways a binary except for settings.</td>
		*  </tr>
		*  <tr>
		*   <td>cObjName</td>
		*   <td>c(240)</td>
		*   <td>For v and k records, the ObjName field of the vcx / scx</td>
		*  </tr>
		*  <tr>
		*   <td>cUniqueID</td>
		*   <td>c(16)</td>
		*   <td>Something to identify the change status, timestamp field CRC etc.
		*    For settings record: date described.
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>iDitry</td>
		*   <td>I</td>
		*   <td>
		*   	<p>Marks an item as dirty from last run.</p>
		*    <table border="1" cellspacing="0">
		*     <tr><td colspan="2">Source; cType IN (d,D,K,B,M,R,V,v,k)</td></tr>
		*     <tr>
		*       <td>8</td>
		*       <td>
		*        Not deleted on last cleanup (full run with delete obsolete files)
		*        w/o any other action.
		*      </td>
		*     </tr>
		*     <tr><td>4</td><td>New</td></tr>
		*     <tr><td>2</td><td>Changed</td></tr>
		*     <tr><td>1</td><td>Direction to binaray. Additional to other positives</td></tr>
		*     <tr><td>0</td><td>0k</td></tr>
		*     <tr><td>-1</td><td>to delete</td></tr>
		*     <tr><td>-2</td><td>deleted</td></tr>
		*     <tr><td>-3</td><td>dirty by heart beat</td></tr>
		*     <tr><td>-4</td><td>dirty by watch dog (time)</td></tr>
		*     <tr><td colspan="2">Heart beat</td></tr>
		*     <tr><td>0</td><td>ok</td></tr>
		*     <tr><td><b>1</b></td><td><b>Error. Do not compare, process all.</b></td></tr>
		*    </table>
		*   </td>
		*  </tr>
		*  <tr>
		*   <td>tLastUse</td>
		*   <td>T</td>
		*   <td>Internal timestamp, used for garbage collection.</td>
		*  </tr>
		*  </tbody>
		* </table>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 19.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 llError     AS BOOLEAN,;
		 loException AS EXCEPTION
		
		llError = .F.
		
		IF !FILE(tcFile) THEN
		 TRY
		   CREATE TABLE (tcFile) (cType c(1), cFile c(240), cObjName c(240), cUniqueId c(16) NOCPTRANS, iDirty I, tLastUse T)
		   INDEX ON cType		TAG _cType
		*Like SCCTEXT.prg
		*(d=DBC, D=DBF, K=Form, B=Label, M=Menu, R=Report, V=Classlibrary)
		*additional:
		*v=Class
		*k=Form timestamp
		*X=Heart beat check
		*S=Setting
		   INDEX ON cFile		TAG _cFile
		   INDEX ON cObjName	TAG _cObj
		   INDEX ON cUniqueId	TAG _cUni
		   INDEX ON iDirty		TAG _iDirty
		   INDEX ON tLastUse	TAG _tLast
		
		   USE
		  CATCH TO loException
		* andere Fehler, Standardhandler rufen
		* ToDo
		   llError = .T.
		  FINALLY
		 ENDTRY
		
		 IF llError THEN
		*we can't handle
		*process all
		  USE IN SELECT('Storage')
		  RETURN NIL
		 ENDIF &&llError
		ENDIF &&!FILE(tcFile)
		
		TRY
		*Was zu testen ist
		  USE (tcFile) ALIAS Storage IN SELECT('Storage') EXCLUSIVE
		
		  SELECT Storage
		  PACK
		 CATCH TO loException
		* andere Fehler, Standardhandler rufen
		* ToDo
		*dann eben kein pack, egal
		  llError = .T.
		 FINALLY
		  USE (tcFile) ALIAS Storage IN SELECT('Storage')
		ENDTRY
		
		IF llError THEN
		*we can't handle
		*process all
		 USE IN SELECT('Storage')
		 RETURN NIL
		ENDIF &&llError
		
		*check heart beat for existence (and set as error to fix problems)
		SELECT;
		 Cur1.iDirty;
		 FROM Storage AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cType=="X"
		
		IF RECCOUNT()=0 THEN
		 INSERT INTO (tcFile);
		  (cFile,cObjName ,cType,iDirty);
		  VALUES;
		  ("Check heart beat","internal","X", 2)
		ENDIF &&RECCOUNT()=0
		
		*garbage collection
		SELECT;
		 Cur1.iDirty;
		 FROM Storage AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.iDirty#0;
		 AND Cur1.cType=="X"
		
		IF RECCOUNT()=0 THEN
		*mark old files for reprocess
		 UPDATE Cur1 SET;
		  iDirty    = -4;
		  FROM Storage AS Cur1;
		  WHERE Cur1.tLastUse<=GOMONTH(DATETIME(),-3);
		  AND !(Cur1.cType=="X";
		  OR Cur1.cType=="S")
		
		ELSE  &&RECCOUNT()=0
		*heart misses a beat, all dirty
		 UPDATE Cur1 SET;
		  iDirty    = -3;
		  FROM Storage AS Cur1;
		  WHERE Cur1.tLastUse<=GOMONTH(DATETIME(),-3);
		  AND !(Cur1.cType=="X";
		  OR Cur1.cType=="S")
		
		ENDIF &&RECCOUNT()=0
		
		USE IN curHelp
		
		*Set heart beat
		UPDATE Cur1 SET;
		 iDirty    = 1,;
		 tLastUse  = DATETIME();
		 FROM Storage AS Cur1;
		 WHERE Cur1.cType=="X"
		
		RETURN 'Storage'
		
	ENDPROC

	PROCEDURE storage_set		&& Set settings information to storage.
		LPARAMETERS;
		 tcType,;
		 toSetting AS COLLECTION,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Puts settings into storage file.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to assign settings value.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="toSetting" type="COLLECTION" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Settings object to read.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias of the storage table.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<remarks>
		*<p>Every item of the collection <pdmpara num="2" /> will create a record in <pdmpara num="3" />
		*with key and value.</p>
		*<p>Note that lenght of key is limited to 14 signs, see <see pem="Storage_Open" />.</p>
		*</remarks>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		 
		LOCAL;
		 lnItem AS INTEGER,;
		 llOk   AS BOOLEAN
		
		FOR lnItem = 1 TO toSetting.COUNT
		 lcKey   = toSetting.GETKEY(lnItem)
		 lcValue = toSetting.ITEM(lnItem)
		
		 _SCREEN.ADDPROPERTY(lcKey,lcValue)
		
		 UPDATE cur1 SET;
		  cFile    = lcValue,;
		  iDirty   = 0,;
		  tLastUse = DATETIME();
		  FROM (tcStorage) AS cur1;
		  WHERE cur1.cUniqueId==lcKey;
		  AND cur1.cType==tcType
		
		 IF _TALLY=0 THEN
		  INSERT INTO (tcStorage);
		   (cType, cFile, cUniqueId, iDirty, tLastUse);
		   VALUES;
		   (tcType, lcValue, lcKey, 0, DATETIME())
		 ENDIF &&_TALLY=0
		ENDFOR &&lnLoop
		
	ENDPROC

	PROCEDURE sync_file		&& Test change of checksum (crc32) for a given file (pair) against the storage table.
		LPARAMETERS;
		 tcType,;
		 tcFile,;
		 tlToBin,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<!-- <descr></descr> -->
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to sync the file.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>File to check.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tlToBin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Alias to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean"><pdmpara num="2" /> is changed.</retval>
		*!*	<remarks>
		*<p>The method calculates the checksum for the file and it's. memo file.</p>
		*<p>This will be compared with <pdmpara num="4" /> to determine if the file is changed and need to be reprocessed.</p>
		*</remarks>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		LOCAL;
		 lcTemp   AS CHARACTER,;
		 lnStep   AS NUMBER,;
		 llDirty  AS BOOLEAN,;
		 llRecall AS BOOLEAN
		
		* we do not process the index since it will change with the data anyway.
		* I'm  not shure with the memo, my guess is it will alter the table too but I'm to lazy to check :)
		DO CASE
		 CASE tcType="V"
		  lcTemp = FORCEEXT(tcFile,'vct')
		 CASE tcType="R"
		  lcTemp = FORCEEXT(tcFile,'frt')
		 CASE tcType="M"
		  lcTemp = FORCEEXT(tcFile,'mnt')
		 CASE tcType="d"
		  lcTemp = FORCEEXT(tcFile,'fpt')
		 CASE tcType="D"
		  lcTemp = FORCEEXT(tcFile,'dct')
		 CASE tcType="P"
		  lcTemp = FORCEEXT(tcFile,'pjt')
		 CASE tcType="B"
		  lcTemp = FORCEEXT(tcFile,'lbt')
		 CASE tcType="K"
		  lcTemp = FORCEEXT(tcFile,'sct')
		ENDCASE
		
		*set anything "ok" that was processed by last run
		lnDirty = IIF(tlToBin,1,0)
		UPDATE Cur1 SET;
		 iDirty   = lnDirty,;
		 tLastUse = DATETIME();
		 FROM (tcStorage) AS Cur1;
		 WHERE Cur1.cFile==tcFile;
		 AND Cur1.cType==tcType;
		 AND Cur1.iDirty>=0
		
		*!*	Changed by: SF 5.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,13:09:00}">Changed by: SF<br />
		*!*	do not deltet  a file mark for delation (because it is not obsolete)
		*!*	</change>
		*!*	</pdm>
		
		*set files marked as "to delete" by "all cleanup" as "not to delete"
		*because file possibly exists (no existing will be parsed out below)
		lnDirty = IIF(tlToBin,9,8)
		UPDATE Cur1 SET;
		 iDirty    = lnDirty,;
		 tLastUse  = DATETIME();
		 FROM (tcStorage) AS Cur1;
		 WHERE Cur1.cFile==tcFile;
		 AND Cur1.cType==tcType;
		 AND Cur1.iDirty=-1
		
		*!*	/Changed by: SF 5.6.2015
		
		*only to process per class, iff UseClassPerFile
		llRecall = INLIST(tcType,'V','K') AND _TALLY>0
		
		*create data
		SELECT;
		 Cur1.cUniqueId,;
		 Cur1.iDirty;
		 FROM (tcStorage) AS Cur1;
		 INTO CURSOR curHelp;
		 WHERE Cur1.cFile==tcFile;
		 AND Cur1.cType==tcType
		
		lnStep  = 1
		DO WHILE .T.
		 DO CASE
		  CASE lnStep=1 AND RECCOUNT()=0   &&unknown, create
		   llDirty = True
		
		   lnDirty = IIF(tlToBin,5,4)
		   INSERT INTO (tcStorage);
		    (cType, cFile, cUniqueId, iDirty, tLastUse);
		    VALUES;
		    (tcType, tcFile, lcTemp, lnDirty, DATETIME())
		*/  &&lnStep=1 AND RECCOUNT()=0  &&unknown, create
		
		  CASE lnStep=1    &&just loop
		*/  &&lnStep=1   &&just loop
		
		  CASE lnStep=2 AND INLIST(iDirty,-3,-4)	  &&file is marked as dirty, process dirty
		   llDirty = True
		
		   lnDirty = IIF(tlToBin,3,2)
		   UPDATE Cur1 SET;
		    cUniqueId = lcTemp,;
		    iDirty    = lnDirty,;
		    tLastUse  = DATETIME();
		    FROM (tcStorage) AS Cur1;
		    WHERE Cur1.cFile==tcFile;
		    AND Cur1.cType==tcType
		*/ &&lnStep=2 AND INLIST(iDirty,-3,-4)  &&file is marked as dirty, process dirty
		
		  CASE lnStep=2    &&just loop
		*/  &&lnStep=2   &&just loop
		
		  CASE lnStep=3	 	&&get file checksum
		*!*	Changed by: SF 20.5.2015
		*!*	<pdm>
		*!*	<change date="{^2015-05-20,06:44:00}">Changed by SF<br />
		*!*	Checksum changed to CRC32
		*!*	</change>
		*!*	</pdm>
		
		*!*	Changed by: SF 4.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-04,11:00:00}">Changed by: SF<br />
		*!*	Ignore the first 4 bytes of a table. (means: bytes 1-3)
		*VFP seems to alter <i>Last update</i> on compile. If the rest of the table is not changed, we can ignore this.
		*!*	</change>
		*!*	</pdm>
		
		   IF FILE(lcTemp) THEN
		    lcTemp = SYS(2007,SUBSTR(FILETOSTR(tcFile),5)+FILETOSTR(lcTemp),0,1)
		   ELSE  &&FILE(lcTemp)
		    lcTemp = SYS(2007,SUBSTR(FILETOSTR(tcFile),5),0,1)
		   ENDIF &&FILE(lcTemp)
		
		*!*	IF FILE(lcTemp) THEN
		*!*	 lcTemp = SYS(2007,FILETOSTR(tcFile)+FILETOSTR(lcTemp),0,1)
		*!*	ELSE  &&FILE(lcTemp)
		*!*	 lcTemp = SYS(2007,FILETOSTR(tcFile),0,1)
		*!*	ENDIF &&FILE(lcTemp)
		
		*!*	/Changed by: SF 4.6.2015
		*!*	/Changed by SF 20.5.2015
		*/	&&lnStep=3 	&&get file checksum
		
		  CASE lnStep=4 AND !TRIM(cUniqueId)==lcTemp   	 	&&changed, process dirty
		   llDirty = True
		
		   lnDirty = IIF(tlToBin,3,2)
		   UPDATE Cur1 SET;
		    cUniqueId = lcTemp,;
		    iDirty    = lnDirty,;
		    tLastUse  = DATETIME();
		    FROM (tcStorage) AS Cur1;
		    WHERE Cur1.cFile==tcFile;
		    AND Cur1.cType==tcType
		*/  &&lnStep=4 AND !TRIM(cUniqueId)==lcTemp  	 	&&changed, process dirty
		
		  OTHERWISE
		*ok
		   llDirty = False
		   EXIT
		 ENDCASE
		
		 IF llDirty THEN
		  EXIT
		 ELSE  &&llDirty
		  lnStep = lnStep+1
		 ENDIF &&llDirty
		ENDDO &&.T.
		
		USE IN SELECT('curHelp')
		
		*For one or the other reason. reprocess
		RETURN llDirty OR llRecall
		
	ENDPROC

	PROCEDURE sync_objects		&& Compares a help cursor with the storage table. Compares objects of a vcx / scx.
		LPARAMETERS;
		 tcType,;
		 tcFile,;
		 tlToBin,;
		 tcSource,;
		 tcStorage
		
		*!*	<pdm>
		*!*	<descr>Compares a help cursor with the storage table.</descr>
		*!*	<params name="tcType" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Type of the storage file to sync the file.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<params name="tcFile" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Filename</short>
		*!*	<detail>File that is handled by <self list"1" /> and decribed in <pdmpara num="4" />.</detail>
		*!*	</params>
		*!*	<params name="tlToBin" type="Boolean" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Direction.</short>
		*!*	<detail>If <expr>.T.</expr> files changed and new will be set as unmodified.</detail>
		*!*	</params>
		*!*	<params name="tcSource" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Source cursor.</short>
		*!*	<detail>Cursor with relevant information about the <pdmpara num="2" />.</detail>
		*!*	</params>
		*!*	<params name="tcStorage" type="Character" byref="0" dir="" inb="0" outb="0">
		*!*	<short>Table to store actual values.</short>
		*!*	<detail></detail>
		*!*	</params>
		*!*	<retval type="Boolean">Classes of <pdmpara num="2" /> are changed.</retval>
		*!*	<remarks>
		*<p>To scx / vcx files</p>
		*<p>This will compare the actual timestamps and uniqueeid. If anything is changed the item will be marked.</p>
		*<p>Any mark will set the file is dirty and the function returns <expr>.T.</expr>.</p>
		*<p>The iDirty (see <see pem="Storage_Open"/>) column will be set to(positive odds are a result of <pdmpara num="3" /> is true):</p>
		*<dl>
		*<dt>8/9</dt><dd>File marked by global cleanup is not to delete.</dd>
		*<dt>4/5</dt><dd>new</dd>
		*<dt>2/3</dt><dd>changed</dd>
		*<dt>0/1</dt><dd>no change</dd>
		*<dt>-1</dt><dd>ClassPerFile is to be deleted.</dd>
		*</dl>
		*<p>Type of operation as set by SCCTEXT.prg with additional flag. See <see pem="Storage_Open"/>.</p>
		*<p>
		*<dl>
		* <dt>d</dt><dd>DBC</dd>
		* <dt>D</dt><dd>DBF</dd>
		* <dt>K</dt><dd>Form</dd>
		* <dt>B</dt><dd>Label</dd>
		* <dt>M</dt><dd>Menu</dd>
		* <dt>R</dt><dd>Report</dd>
		* <dt>V</dt><dd>Classlibrary</dd>
		* <dt><b>C</b></dt><dd><b>Class</b></dd>
		* <dt><b>X</b></dt><dd><b>Heart beat check</b></dd>
		* <dt>P</dt><dd>Project</dd>
		* <dt>v</dt><dd>Class of vcx</dd>
		* <dt>k</dt><dd>Object of scx</dd>
		*</dl>
		* This method basically deals with classes of vcx files and objects of scx files.</p>
		*</remarks>
		*!*	<comment>
		*!*	<example></example>
		*!*	<seealso>
		*!*	 <see loca="" class="" pem=""></see>
		*!*	</seealso>
		*!*	<appliesto toref="0" toalso="0" />
		*!*	</comment>
		*!*	<copyright><i>&copy; 14.4.2015 Lutz Scheffler Software Ingenieurbüro</i></copyright>
		*!*	</pdm>
		
		IF PCOUNT()=0 THEN
		 CREATE CURSOR muh (i1 i)
		 RETURN
		ENDIF &&PCOUNT()=0
		
		LOCAL;
		 lnDirty AS INTEGER,;
		 llDirty AS BOOLEAN
		
		llDirty = .F.
		
		*so now let's see if something is changed
		#IF .F. THEN
		*beautify off
		 TEXT
		#ENDIF &&.F.
		
		*set anything "ok" that was processed by last run
		lnDirty = IIF(tlToBin,1,0)
		UPDATE Cur1 SET;
		 iDirty   = lnDirty,;
		 tLastUse = DATETIME();
		 FROM (tcStorage) AS Cur1;
		 WHERE Cur1.cFile==tcFile;
		  AND Cur1.cType==tcType;
		  AND Cur1.iDirty>=0
		  
		*!*	Changed by: SF 5.6.2015
		*!*	<pdm>
		*!*	<change date="{^2015-06-05,13:09:00}">Changed by: SF<br />
		*!*	do not deltet  a file mark for delation (because it is not automatic obsolete)
		*!*	</change>
		*!*	</pdm>
		
		*set files marked as "to delete" by "all cleanup" as "not to delete"
		*because file exists
		lnDirty = IIF(tlToBin,9,8)
		UPDATE Cur1 SET;
		 iDirty    = lnDirty,;
		 tLastUse  = DATETIME();
		 FROM (tcStorage) AS Cur1;
		 WHERE Cur1.cFile==tcFile;
		  AND Cur1.cType==tcType;
		  AND Cur1.iDirty=-1
		*!*	/Changed by: SF 5.6.2015
		
		 SELECT;
		  .T. AS lNew,;
		  Cur1.cObjName,;
		  Cur1.cUniqueId;
		  FROM (tcSource) AS Cur1;
		  INTO CURSOR curHelp;
		  WHERE Cur1.cUniqueID-Cur1.cObjName NOT IN (;
		    SELECT;
		     Cur1_1.cUniqueId-Cur1_1.cObjName;
		     FROM (tcStorage) AS Cur1_1;
		     WHERE Cur1_1.cFile==tcFile;
		      AND Cur1_1.cType==tcType;
		   );
		UNION;
		 SELECT;
		  .F. AS lNew,;
		  Cur2.cObjName,;
		  Cur2.cUniqueId;
		  FROM (tcStorage) AS Cur2;
		  WHERE Cur2.cFile==tcFile;
		   AND Cur2.cType==tcType;
		   AND Cur2.cUniqueId-Cur2.cObjName NOT IN(;
		    SELECT;
		     Cur2_1.cUniqueID-Cur2_1.cObjName;
		     FROM (tcSource) AS Cur2_1;
		   )
		
		llDirty = RECCOUNT()>0  &&something is changed some way
		
		*Those will have files that will no longer be valid
		*Records will be deleted in the next run, due to post processing -> delete obsolete vc2 files!
		*Objects with both lNew AND !lNew have replaced UniqueId!
		UPDATE Cur1 SET;
		 iDirty   = -1,;
		 tLastUse = DATETIME();
		 FROM (tcStorage) AS Cur1;
		 INNER JOIN curHelp AS Cur2;
		  ON Cur1.cObjName==Cur2.cObjName;
		   AND Cur1.cFile==tcFile;
		   AND Cur1.cType==tcType;
		   AND !Cur2.lNew;
		  WHERE Cur2.cObjName NOT IN(;
		    SELECT;
		     Cur2_1.cObjName;
		     FROM curHelp AS Cur2_1;
		     WHERE Cur2_1.lNew;
		   )
		
		*Records changed - lNew AND !lNew needs to be checked
		 lnDirty = IIF(tlToBin,3,2)
		 UPDATE Cur1 SET;
		  cUniqueId =Cur2.cUniqueId,;
		  iDirty    = lnDirty,;
		  tLastUse  = DATETIME();
		  FROM (tcStorage) AS Cur1;
		  INNER JOIN curHelp AS Cur2;
		   ON Cur1.cObjName==Cur2.cObjName;
		    AND Cur1.cFile==tcFile;
		    AND Cur1.cType==tcType;
		    AND Cur2.lNew;
		  INNER JOIN curHelp AS Cur3;
		   ON Cur1.cObjName==Cur3.cObjName;
		    AND !Cur3.lNew;
		
		*Records marked as dirty for heart beat failure OR  garbage needs to be checked / reprocessed
		 UPDATE Cur1 SET;
		  iDirty    = lnDirty,;
		  tLastUse  = DATETIME();
		  FROM (tcStorage) AS Cur1;
		  WHERE Cur1.iDirty IN (-3,-4);
		   AND Cur1.cFile==tcFile;
		   AND Cur1.cType==tcType
		
		llDirty = llDirty OR _TALLY>0
		
		*new files
		 lnDirty = IIF(tlToBin,5,4)
		 INSERT INTO (tcStorage);
		  SELECT;
		   tcType AS cType,;
		   CAST(tcFile AS c(240)) AS cFile,;
		   Cur2.cObjName,;
		   Cur2.cUniqueId,;
		   CAST(lnDirty AS I) AS iDirty,;
		   DATETIME() AS tLastUse;
		   FROM curHelp AS Cur2;
		   WHERE Cur2.lNew;
		    AND Cur2.cObjName NOT IN(;
		     SELECT;
		      Cur3.cObjName;
		      FROM curHelp AS Cur3;
		      WHERE !Cur3.lNew;
		    )
		
		#IF .F. THEN
		*beautify on
		 ENDTEXT
		#ENDIF &&.F.
		
		USE IN SELECT('curHelp')
		
		*For one or the other reason. reprocess
		RETURN llDirty
		
	ENDPROC

ENDDEFINE
